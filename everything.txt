/*
 *  eval.c
 *  Simfpl
 *
 *  Created by Michael Dickens on 1/17/10.
 *  
 */

#include "eval.h"

int init_evaluator()
{
	print_info_p = FALSE;
	
	global_variables = value_hash_init();
	outer_variables = value_hash_init();
	ud_functions = value_hash_init();
	
	// This is a work in progress.
	value type;
	
	type.type = VALUE_TYP;
	
	type.core.u_type = VALUE_NIL;
	value_hash_put_var(&global_variables, type_to_string(type.core.u_type), type);
	type.core.u_type = VALUE_BOO;
	value_hash_put_var(&global_variables, type_to_string(type.core.u_type), type);
	type.core.u_type = VALUE_MPZ;
	value_hash_put_var(&global_variables, type_to_string(type.core.u_type), type);
	type.core.u_type = VALUE_MPF;
	value_hash_put_var(&global_variables, type_to_string(type.core.u_type), type);
	type.core.u_type = VALUE_STR;
	value_hash_put_var(&global_variables, type_to_string(type.core.u_type), type);
	type.core.u_type = VALUE_RGX;
	value_hash_put_var(&global_variables, type_to_string(type.core.u_type), type);
	type.core.u_type = VALUE_ARY;
	value_hash_put_var(&global_variables, type_to_string(type.core.u_type), type);
	type.core.u_type = VALUE_LST;
	value_hash_put_var(&global_variables, type_to_string(type.core.u_type), type);
	type.core.u_type = VALUE_HSH;
	value_hash_put_var(&global_variables, type_to_string(type.core.u_type), type);
	type.core.u_type = VALUE_TRE;
	value_hash_put_var(&global_variables, type_to_string(type.core.u_type), type);
	type.core.u_type = VALUE_PTR;
	value_hash_put_var(&global_variables, type_to_string(type.core.u_type), type);
	type.core.u_type = VALUE_BLK;
	value_hash_put_var(&global_variables, type_to_string(type.core.u_type), type);
	type.core.u_type = VALUE_RNG;
	value_hash_put_var(&global_variables, type_to_string(type.core.u_type), type);
	type.core.u_type = VALUE_NAN;
	value_hash_put_var(&global_variables, type_to_string(type.core.u_type), type);
	type.core.u_type = VALUE_INF;
	value_hash_put_var(&global_variables, type_to_string(type.core.u_type), type);
	type.core.u_type = VALUE_TYP;
	value_hash_put_var(&global_variables, type_to_string(type.core.u_type), type);
	type.core.u_type = VALUE_ERROR;
	value_hash_put_var(&global_variables, type_to_string(type.core.u_type), type);
	
	
	primitive_funs = value_hash_init_capacity(500);
	function_funs = value_hash_init();
	
	primitive_names = value_hash_init_capacity(500);
	primitive_specs = value_hash_init_capacity(500);
	symbol_ids = value_hash_init_capacity(50);
	function_ids = value_hash_init();
		
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
	
	/*
	 How the function's spec string works: 
	 
	 If it starts with an 'o', take the first number. That is the 
	 point after which arguments become optional. 0 means that all 
	 are optional, 1 means that all but the first are optional, etc.
	 
	 The first three characters are each either true ('t') or false 
	 ('f'). They denote whether (1) the function takes variables, 
	 (2) the function keeps the first argument if it is a variable, 
	 and (3) the function's arguments are not evaluated before the 
	 function is called. These are used for (1) control functions  
	 and iterators, (2) assignment, and (3) control functions. If (1) 
	 is 'u', ud_functions is passed in instead of the current variables.
	 
	 An x denotes that there may be any number of arguments greater than 
	 or equal to the given arg count.
	 
	 The first remaining  character denotes the number of arguments, 
	 the second denotes left or right precedence, and the rest 
	 denote what precedence the operator has.
	 */

	/*
	 Precedence Levels
	 
	 19: at.
	 18: Quote and eval.
	 17: Range operators (..) and (...).
	 16: Unary functions and user-defined unary functions.
	 15: Other functions and user-defined functions.
	 14: 
	 13: Multiplication, Division, Modulo: *, /, %
	 12: Addition and Subtraction: +, -
	 11: Shift: <<, >>
	 10: Comparison: <, <=, >=, >
	  9: Equality: ==, !=
	  8: Logical AND: &
	  7: Logical XOR: ^
	  6: Logical OR: |
	  5: Conditional AND: &&
	  4: Conditional OR: ||
	  3: Assignment functions: =, +=, *=, ...
	  2: Functions that usually have their own line: print, import, 
	     break, def, if, ...
	  1: Commas.
	  0: Semicolons.
	 */

	add_function("import", value_set_fun(&value_import_arg), "1r2");
	add_function("=", value_set_fun(&value_assign_arg), "ttf2r3");
	add_function("+=", value_set_fun(&value_assign_add_arg), "ttf2r3");
	add_function("-=", value_set_fun(&value_assign_sub_arg), "ttf2r3");
	add_function("*=", value_set_fun(&value_assign_mul_arg), "ttf2r3");
	add_function("/=", value_set_fun(&value_assign_div_arg), "ttf2r3");
	add_function("%=", value_set_fun(&value_assign_mod_arg), "ttf2r3");
	add_function("&=", value_set_fun(&value_assign_and_arg), "ttf2r3");
	add_function("^=", value_set_fun(&value_assign_xor_arg), "ttf2r3");
	add_function("|=", value_set_fun(&value_assign_or_arg), "ttf2r3");
	add_function("<<=", value_set_fun(&value_assign_shl_arg), "ttf2r3");
	add_function(">>=", value_set_fun(&value_assign_shr_arg), "ttf2r3");
	
	add_function("**", value_set_fun(&value_pow_arg), "2r16");
	add_function("!", value_set_fun(&value_not_p_arg), "1l16");
	add_function("~", value_set_fun(&value_not_arg), "1l16");
	add_function("--", value_set_fun(&value_uminus_arg), "1l16");
	add_function("++", value_set_fun(&value_uplus_arg), "1l16");
	add_function("abs", value_set_fun(&value_abs_arg), "1l16");
	add_function("exp", value_set_fun(&value_exp_arg), "1l16");
	add_function("log", value_set_fun(&value_log_arg), "1l16");
	add_function("log2", value_set_fun(&value_log2_arg), "1l16");
	add_function("log10", value_set_fun(&value_log10_arg), "1l16");
	add_function("sqrt", value_set_fun(&value_sqrt_arg), "1l16");
	add_function("factorial", value_set_fun(&value_factorial_arg), "1l16");
	add_function("choose", value_set_fun(&value_choose_arg), "2l15");
	add_function("sin", value_set_fun(&value_sin_arg), "1l16");
	add_function("cos", value_set_fun(&value_cos_arg), "1l16");
	add_function("tan", value_set_fun(&value_tan_arg), "1l16");
	add_function("csc", value_set_fun(&value_csc_arg), "1l16");
	add_function("sec", value_set_fun(&value_sec_arg), "1l16");
	add_function("cot", value_set_fun(&value_cot_arg), "1l16");
	add_function("asin", value_set_fun(&value_asin_arg), "1l16");
	add_function("acos", value_set_fun(&value_acos_arg), "1l16");
	add_function("atan", value_set_fun(&value_atan_arg), "1l16");
	add_function("sinh", value_set_fun(&value_sinh_arg), "1l16");
	add_function("cosh", value_set_fun(&value_cosh_arg), "1l16");
	add_function("tanh", value_set_fun(&value_tanh_arg), "1l16");
	add_function("csch", value_set_fun(&value_csch_arg), "1l16");
	add_function("sech", value_set_fun(&value_sech_arg), "1l16");
	add_function("coth", value_set_fun(&value_coth_arg), "1l16");
	add_function("asinh", value_set_fun(&value_asinh_arg), "1l16");
	add_function("acosh", value_set_fun(&value_acosh_arg), "1l16");
	add_function("atanh", value_set_fun(&value_atanh_arg), "1l16");
	add_function("deriv", value_set_fun(&value_deriv_arg), "1l16");
	add_function("probab_prime?", value_set_fun(&value_probab_prime_p_arg), "1l16");
	add_function("nextprime", value_set_fun(&value_nextprime_arg), "1l16");
	add_function("gcd", value_set_fun(&value_gcd_arg), "2l15");
	add_function("seconds", value_set_fun(&value_seconds_arg), "0l15");
	
	add_function("times", value_set_fun(&value_times_arg), "tff2r15");
	add_function("summation", value_set_fun(&value_summation_arg), "tff2r15");

	add_function("to_a", value_set_fun(&value_to_a_arg), "1l16");
	add_function("to_f", value_set_fun(&value_to_f_arg), "1l16");
	add_function("to_h", value_set_fun(&value_to_h_arg), "1l16");
	add_function("to_i", value_set_fun(&value_to_i_arg), "1l16");
	add_function("to_l", value_set_fun(&value_to_l_arg), "1l16");
	add_function("to_s", value_set_fun(&value_to_s_arg), "1l16");
	add_function("to_r", value_set_fun(&value_to_r_arg), "1l16");
	add_function("to_s_base", value_set_fun(&value_to_s_base_arg), "2l15");
	add_function("type", value_set_fun(&value_type_arg), "1l16");
	
	add_function("*", value_set_fun(&value_mul_arg), "2l13");
	add_function("/", value_set_fun(&value_div_arg), "2l13");
	add_function("%", value_set_fun(&value_mod_arg), "2l13");
	add_function("+", value_set_fun(&value_add_arg), "2l12");
	add_function("-", value_set_fun(&value_sub_arg), "2l12");
	add_function("<<", value_set_fun(&value_shl_arg), "2l11");
	add_function(">>", value_set_fun(&value_shr_arg), "2l11");
	add_function("<", value_set_fun(&value_lt_arg), "2l10");
	add_function("<=", value_set_fun(&value_le_arg), "2l10");
	add_function(">", value_set_fun(&value_gt_arg), "2l10");
	add_function(">=", value_set_fun(&value_ge_arg), "2l10");
	add_function("==", value_set_fun(&value_eq_arg), "2l9");
	add_function("!=", value_set_fun(&value_ne_arg), "2l9");
	add_function("&", value_set_fun(&value_and_arg), "2l8");
	add_function("^", value_set_fun(&value_xor_arg), "2l7");
	add_function("|", value_set_fun(&value_or_arg), "2l6");
	add_function("&&", value_set_fun(&value_and_p_arg), "2l5");
	add_function("||", value_set_fun(&value_or_p_arg), "2l4");
	
	add_function("set", value_set_fun(&value_set_arg), "ftt1l16");
	add_function("true?", value_set_fun(&value_true_p_arg), "1l16");
	add_function("..", value_set_fun(&value_range_to_arg), "2l17");
	add_function("...", value_set_fun(&value_range_until_arg), "2l17");
	add_function("rand", value_set_fun(&value_rand_arg), "1l16");
	add_function("array", value_set_fun(&value_array_arg), "x0r15");
	add_function("list", value_set_fun(&value_list_arg), "x0r15");
	add_function("hash", value_set_fun(&value_hash_arg), "x0r15");
	add_function("->", value_set_fun(&value_make_pair_arg), "2r15");
	add_function("print", value_set_fun(&value_print_arg), "1l2");
	add_function("println", value_set_fun(&value_println_arg), "1l2");	
	add_function("printf", value_set_fun(&value_printf_arg), "x0l2");
	
	add_function("gets", value_set_fun(&value_gets_arg), "0l16");
	
	add_function("asc", value_set_fun(&value_asc_arg), "1l16");
	add_function("capitalize", value_set_fun(&value_capitalize_arg), "1l16");
	add_function("chop", value_set_fun(&value_chop_arg), "1l16");
	add_function("chop!", value_set_fun(&value_chop_now_arg), "1l16");
	add_function("chr", value_set_fun(&value_chr_arg), "1l16");
	add_function("contains?", value_set_fun(&value_contains_p_arg), "2l15");
	add_function("ends_with?", value_set_fun(&value_ends_with_p_arg), "2l15");
	add_function("index", value_set_fun(&value_index_arg), "2l15");
	add_function("insert", value_set_fun(&value_insert_arg), "3l15");
	add_function("insert!", value_set_fun(&value_insert_now_arg), "3l15");
	add_function("alpha?", value_set_fun(&value_alpha_p_arg), "1l16");
	add_function("alnum?", value_set_fun(&value_alnum_p_arg), "1l16");
	add_function("num?", value_set_fun(&value_num_p_arg), "1l16");
	add_function("length", value_set_fun(&value_length_arg), "1l16");
	add_function("lstrip", value_set_fun(&value_lstrip_arg), "1l16");
	add_function("range", value_set_fun(&value_range_arg), "3l15");
	add_function("replace", value_set_fun(&value_replace_arg), "3l15");
	add_function("replace!", value_set_fun(&value_replace_now_arg), "3l15");
	add_function("reverse", value_set_fun(&value_reverse_arg), "1l16");
	add_function("reverse!", value_set_fun(&value_reverse_now_arg), "1l16");
	add_function("rstrip", value_set_fun(&value_rstrip_arg), "1l16");
	add_function("scan", value_set_fun(&value_scan_arg), "2l15");
	add_function("split", value_set_fun(&value_split_arg), "2l15");
	add_function("starts_with?", value_set_fun(&value_starts_with_p_arg), "2l15");
	add_function("strip", value_set_fun(&value_strip_arg), "1l16");
	add_function("strip!", value_set_fun(&value_strip_now_arg), "1l16");
	add_function("to_upper", value_set_fun(&value_to_upper_arg), "1l16");
	add_function("to_lower", value_set_fun(&value_to_lower_arg), "1l16");
	
	add_function("match?", value_set_fun(&value_match_p_arg), "2l15");
	add_function("match", value_set_fun(&value_match_arg), "2l15");
	
	add_function("append", value_set_fun(&value_append_arg), "2l15");
	add_function("append!", value_set_fun(&value_append_now_arg), "2l15");
	add_function("array_with_length", value_set_fun(&value_array_with_length_arg), "1l15");
	add_function("at", value_set_fun(&value_at_arg), "o1xl19");
	add_function("at_equals", value_set_fun(&value_at_assign_arg), "o3tffxl3");
	add_function("at_add_equals", value_set_fun(&value_at_assign_add_arg), "o3tffxl3");
	add_function("at_sub_equals", value_set_fun(&value_at_assign_sub_arg), "o3tffxl3");
	add_function("at_mul_equals", value_set_fun(&value_at_assign_mul_arg), "o3tffxl3");
	add_function("at_div_equals", value_set_fun(&value_at_assign_div_arg), "o3tffxl3");
	add_function("at_mod_equals", value_set_fun(&value_at_assign_mod_arg), "o3tffxl3");
	add_function("at_and_equals", value_set_fun(&value_at_assign_and_arg), "o3tffxl3");
	add_function("at_xor_equals", value_set_fun(&value_at_assign_xor_arg), "o3tffxl3");
	add_function("at_or_equals", value_set_fun(&value_at_assign_or_arg), "o3tffxl3");
	add_function("at_shl_equals", value_set_fun(&value_at_assign_shl_arg), "o3tffxl3");
	add_function("at_shr_equals", value_set_fun(&value_at_assign_shr_arg), "o3tffxl3");
	add_function("concat", value_set_fun(&value_concat_arg), "2l15");
	add_function("delete", value_set_fun(&value_delete_arg), "2l15");
	add_function("delete_all", value_set_fun(&value_delete_all_arg), "2l15");
	add_function("delete_at", value_set_fun(&value_delete_at_arg), "2l15");
	add_function("delete_at!", value_set_fun(&value_delete_at_now_arg), "2l15");
	add_function("each", value_set_fun(&value_each_arg), "tff2l15");
	add_function("each_index", value_set_fun(&value_each_index_arg), "tff2l15");
	add_function("empty?", value_set_fun(&value_empty_p_arg), "1l16");
	add_function("filter", value_set_fun(&value_filter_arg), "tff2l15");
	add_function("find", value_set_fun(&value_find_arg), "tff2l15");
	add_function("flatten", value_set_fun(&value_flatten_arg), "1l16");
	add_function("flatten!", value_set_fun(&value_flatten_now_arg), "1l16");
	add_function("fold", value_set_fun(&value_fold_arg), "tff3l15");
	add_function("join", value_set_fun(&value_join_arg), "2l15");
	add_function("last", value_set_fun(&value_last_arg), "1l16");
	add_function("map", value_set_fun(&value_map_arg), "tff2l15");
	add_function("map!", value_set_fun(&value_map_now_arg), "tff2l15");
	add_function("pop", value_set_fun(&value_pop_arg), "1l16");
	add_function("pop!", value_set_fun(&value_pop_now_arg), "1l16");
	add_function("shuffle", value_set_fun(&value_shuffle_arg), "1l16");
	add_function("shuffle!", value_set_fun(&value_shuffle_now_arg), "1l16");
	add_function("size", value_set_fun(&value_size_arg), "1l16");
	add_function("sort", value_set_fun(&value_sort_arg), "1l16");
	add_function("sort!", value_set_fun(&value_sort_now_arg), "1l16");
	add_function("uniq", value_set_fun(&value_uniq_arg), "1l16");
	add_function("uniq!", value_set_fun(&value_uniq_now_arg), "1l16");
	add_function("uniq_sort", value_set_fun(&value_uniq_sort_arg), "1l16");
	add_function("uniq_sort!", value_set_fun(&value_uniq_sort_now_arg), "1l16");
	
	add_function("cons", value_set_fun(&value_cons_arg), "2r15");
	add_function("cons!", value_set_fun(&value_cons_now_arg), "2r15");
	add_function("drop", value_set_fun(&value_drop_arg), "2l15");
	add_function("head", value_set_fun(&value_head_arg), "1l16");
	add_function("tail", value_set_fun(&value_tail_arg), "1l16");
	add_function("take", value_set_fun(&value_take_arg), "2l15");
	
	add_function("contains_value?", value_set_fun(&value_contains_value_arg), "2l15");
		
	add_function(";", value_set_fun(&value_do_both_arg), "tft2l0");
	add_function(",", value_set_fun(&value_comma_arg), "fff2l1");
	add_function("do_all", value_set_fun(&value_do_all_arg), "tftx0l15");
	add_function("if", value_set_fun(&value_if_arg), "o2ttt3l15");
	add_function("unless", value_set_fun(&value_unless_arg), "o2ttt3l15");
	add_function("while", value_set_fun(&value_while_arg), "ttt2l15");
	add_function("until", value_set_fun(&value_until_arg), "ttt2l15");
	add_function("switch", value_set_fun(&value_switch_arg), "o1ttt2l15");
	add_function("for", value_set_fun(&value_for_arg), "ttt2l15");
	
	add_function("break", value_set_fun(&value_break_arg), "fff0l2");
	add_function("continue", value_set_fun(&value_continue_arg), "fff0l2");
	add_function("yield", value_set_fun(&value_yield_arg), "fff1l2");
	add_function("return", value_set_fun(&value_return_arg), "fff1l2");
	add_function("exit", value_set_fun(&value_exit_arg), "fff0l2");
	
	add_function("def", value_set_fun(&value_def_arg), "uft3l2");
		
	add_function("quote", value_set_fun(&value_quote_all_arg), "ftt1l18");
	add_function("`", value_set_fun(&value_quote_arg), "ttt1l18");
	add_function("dq", value_set_fun(&value_dequote_arg), "tft1l18");
	add_function("dv", value_set_fun(&value_devar_arg), "tft1l18");
	add_function("eval", value_set_fun(&value_eval_arg), "tff1l18");

	add_function("optimize", value_set_fun(&value_optimize_arg), "o1fff2l16");

	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

	value_hash_put_str(&symbol_ids, "nl", value_init_nil()); // newline
	value_hash_put_str(&symbol_ids, "(", value_init_nil());
	value_hash_put_str(&symbol_ids, ")", value_init_nil());
	value_hash_put_str(&symbol_ids, "[", value_init_nil());
	value_hash_put_str(&symbol_ids, "]", value_init_nil());
	value_hash_put_str(&symbol_ids, "{", value_init_nil());
	value_hash_put_str(&symbol_ids, "}", value_init_nil());
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
	
	
	return 0;
}

void add_function(char *name, value fun, char *spec)
{
	value vname = value_set_id(name);
	value vspec;
	
	vspec.type = VALUE_SPEC;
	vspec.core.u_spec = compile_spec(spec);
	fun.core.u_bif->spec = vspec.core.u_spec;
	value_hash_put_refs(&primitive_funs, &vname, &fun);
	value_hash_put_refs(&primitive_specs, &fun, &vspec);
	vname.type = VALUE_VAR;
	value_hash_put_refs(&primitive_names, &fun, &vname);
}

/* 
 * The new evaluation function. Takes an S-expression and evaluates it.
 */

value eval_generic(value *variables, value sexp, int outer_was_block_p)
{	
	if (sexp.type == VALUE_VAR) {
		if (value_hash_exists(*variables, sexp))
			return value_hash_get(*variables, sexp);
		else if (value_hash_exists(global_variables, sexp))
			return value_hash_get(global_variables, sexp);
		else {
			value_error(1, "Error: Unrecognized function or value %s.", sexp);
			return value_init_error();
		}
	} else if (sexp.type != VALUE_BLK)
		return value_set(sexp);
				
	size_t length = sexp.core.u_blk.length;
	value res = value_init_nil();
	
	int error_p = FALSE;
	
	if (sexp.core.u_blk.a[0].type == VALUE_UDF_SHELL) {
		// Fix the code so that this conversion only happens one time, and after that it's 
		// remembered. This is actually taking up a pretty big chunk of the running time.
		value name = value_set_str(sexp.core.u_blk.a[0].core.u_udf->name);
		name.type = VALUE_VAR;
		value_clear(&sexp.core.u_blk.a[0]);
		sexp.core.u_blk.a[0] = value_hash_get(ud_functions, name);
		
		// This ought to fix the repeated-conversion bug. I don't think it does but I need 
		// to do more testing.
		value_hash_put(&ud_functions, name, sexp.core.u_blk.a[0]);

		value_clear(&name);
	}
	
	if (sexp.core.u_blk.a[0].type == VALUE_BIF) {
		
		res = value_bifcall_sexp(variables, &ud_functions, sexp);
		
	} else if (sexp.core.u_blk.a[0].type == VALUE_UDF) {
		
		// Evaluate the function.
		res = value_udfcall(variables, sexp.core.u_blk.a[0], sexp.core.u_blk.length - 1, sexp.core.u_blk.a + 1);
		
		// This fixes the problem where a UDF_SHELL has to be repeatedly set to a UDF. But since this happens 
		// every time a UDF is called, I doubt that it's any faster. At least it's a solution, but I need an 
		// elegant solution.
		// Later: I put this code in the place where a UDF_SHELL is found.
//		value name = value_set_str(sexp.core.u_blk.a[0].core.u_udf->name);
//		name.type = VALUE_VAR;
//		value_hash_put(&ud_functions, name, sexp.core.u_blk.a[0]);
		
	} else if (length == 1) {
		if (sexp.core.u_blk.a[0].type == VALUE_VAR) {
			if (value_hash_exists(*variables, sexp.core.u_blk.a[0]))
				return value_hash_get(*variables, sexp.core.u_blk.a[0]);
			else if (value_hash_exists(global_variables, sexp.core.u_blk.a[0]))
				return value_hash_get(global_variables, sexp.core.u_blk.a[0]);
			else {
				value_error(1, "Error: Unrecognized function or value %s.", sexp.core.u_blk.a[0]);
				return value_init_error();
			}
		} else
			return value_set(sexp.core.u_blk.a[0]);
	} else {
		value_error(1, "Syntax Error: S-expressions are undefined where the first element is %ts.", sexp.core.u_blk.a[0]);
		res = value_init_error();
	}
	
	if (print_errors_p && outer_was_block_p == FALSE && res.type == VALUE_ERROR) {
		value_printf("\tin %s\n", sexp);
	}
	
	return res;
}

int is_primitive(value id)
{
	if (id.type == VALUE_BIF)
		return value_hash_exists(primitive_specs, id);
	return value_hash_exists(primitive_funs, id);
}

int is_function(value id)
{
	if (id.type == VALUE_BIF)
		return value_hash_exists(primitive_specs, id);
	if (id.type == VALUE_UDF)
		return value_hash_exists(ud_functions, id);
	if (id.type == VALUE_UDF_SHELL)
		; // Do something.
	return value_hash_exists(primitive_funs, id);
}

int is_symbol(char *id)
{
	return value_hash_exists_str(symbol_ids, id);
}

struct value_spec compile_spec(char *str)
{
	struct value_spec spec;
	
	if (str == NULL) {
		spec.change_scope_p = 0;
		spec.needs_variables_p = 0;
		spec.keep_arg_p = 0;
		spec.delay_eval_p = 0;
		spec.argc = 0;
		spec.optional = 0;
		spec.rest_p = 0;
		spec.associativity = 0;
		spec.precedence = 0;
		spec.not_stop_p = 0;
		return spec;
	}
	
	char *ptr = str;
	
	spec.optional = INT_MAX;
	if (*ptr == 'o') {
		spec.optional = 0;
		while (isdigit(*(++ptr)))
			spec.optional = (10 * spec.optional) + (*ptr - '0');
	}
	
	spec.change_scope_p = TRUE;
	
	if (*ptr == 't')
		spec.needs_variables_p = TRUE;
	else if (*ptr == 'f')
		spec.needs_variables_p = FALSE;
	else if (*ptr == 'u')
		spec.needs_variables_p = NEEDS_UD_FUNCTIONS;
	else {
		spec.needs_variables_p = FALSE;
		--ptr;
	}
	++ptr;

	if (*ptr == 't')
		spec.keep_arg_p = TRUE;
	else if (*ptr == 'f')
		spec.keep_arg_p = FALSE;
	else {
		spec.keep_arg_p = FALSE;
		--ptr;
	}
	++ptr;

	if (*ptr == 't')
		spec.delay_eval_p = TRUE;
	else if (*ptr == 'f')
		spec.delay_eval_p = FALSE;
	else {
		spec.delay_eval_p = FALSE;
		--ptr;
	}
	++ptr;
	
	spec.argc = 0;
	if (*ptr == 'x') {
		spec.rest_p = TRUE;
		++ptr;
	} else {
		spec.rest_p = FALSE;
	}

	while (isdigit(*ptr))
		spec.argc = (10 * spec.argc) + (*(ptr++) - '0');
	
	if (*ptr == 'l')
		spec.associativity = 'l';
	else if (*ptr == 'r')
		spec.associativity = 'r';
	else {
		value_error(1, "Internal error: In spec string \"%s\", associativity has an undefined value.", str);
		spec = value_nil_function_spec;
		return spec;
	}
	
	spec.precedence = 0;
	while (isdigit(*(++ptr)))
		spec.precedence = (10 * spec.precedence) + *ptr - '0';
	
	spec.not_stop_p = FALSE;
	
	return spec;
}

struct value_spec get_spec(value id)
{
	if (id.type == VALUE_BIF) {
		return id.core.u_bif->spec;
	} else if (id.type == VALUE_UDF) {
		return id.core.u_udf->spec;
	}
	
	return compile_spec(NULL);
}

int primitive_needs_variables(value id)
{
	value *refp = value_hash_get_ref(primitive_specs, id);
	return refp->core.u_spec.needs_variables_p;	
}

int primitive_keep_arg(value id)
{
	value *refp = value_hash_get_ref(primitive_specs, id);
	return refp->core.u_spec.keep_arg_p;	
}

int primitive_delay_eval(value id)
{
	value *refp = value_hash_get_ref(primitive_specs, id);
	return refp->core.u_spec.delay_eval_p;	
}

size_t arg_count(value id)
{
	if (id.type == VALUE_BIF) {	
		return id.core.u_bif->spec.argc;
	} else if (id.type == VALUE_UDF) {
		return id.core.u_udf->vars.core.u_a.length;
	} else if (id.type == VALUE_UDF_SHELL) {
		return id.core.u_udf->spec.argc;
	} else {
		return -1;
	}

}

char primitive_associativity(value id)
{
	if (!is_primitive(id))
		return 1;

	value *val = value_hash_get_ref(primitive_specs, id);
	return val->core.u_spec.associativity;
}

int primitive_precedence(value id)
{
	if (!is_primitive(id)) {
		value_error(1, "Compiler Error: unknown id %ts.", id);
		return -1;
	}

	value *val = value_hash_get_ref(primitive_specs, id);
	return val->core.u_spec.precedence;
}

/*
 *  eval.h
 *  Simfpl
 *
 *  Created by Michael Dickens on 1/17/10.
 *  
 *  This file is used for evaluating s-expressions.
 *  
 */

#include "value.h"

int print_info_p;


// global_variables declared in values.h.
value outer_variables;
value ud_functions;

// These are initialized in init_interpreter().
value function_funs;

int init_evaluator();
void add_function(char *name, value fun, char *spec);

int is_primitive(value id);
int is_function(value id);
int is_symbol(char *id);

// See value.h for declaration of compile_spec().

struct value_spec get_spec(value id);
int primitive_needs_variables(value id);
int primitive_keep_arg(value id);
int primitive_delay_eval(value id);
size_t arg_count(value id);
char primitive_associativity(value id);
int primitive_precedence(value id);

/*
 *  interpreter.c
 *  Simfpl
 *
 *  Created by Michael Dickens on 5/8/10.
 *
 */



#include "interpreter.h"

int init_interpreter()
{
	same_type_determiner = SAME_TYPE_VALUE;
	print_interpreter_stuff = FALSE;
	is_eof = FALSE;
	previous_truth_value = FALSE;
	previous_was_if_statement;
	
	assume_first_is_function = TRUE;
	
	line_queue = value_init(VALUE_LST);
	line_queue_back = line_queue;
	
	input_stream = stdin;
//	input_stream = fopen("benchmarks/recursive benchmark 1.txt", "r");
	if (input_stream == NULL) {
		value_error(0, "IO Error: Unknown file stream.");
		input_stream = stdin;
	}
	
	stream_paren_balance = stream_bracket_balance = stream_curly_balance = stream_quote_balance = stream_regex_balance = 0;
		
	return 0;
}

/* Interprets an input stream.
 */
int run_interpreter()
{
	int i;
	print_interpreter_stuff = TRUE;
	
	value values, result = value_init_nil();
	for (i = 0; is_eof == FALSE; ++i) {
		if (input_stream == stdin && value_empty_p(line_queue))
			printf(">>> ");
		
		values = get_values();
		if (values.type == VALUE_ARY)
			result = interpret_values(&outer_variables, values.core.u_a.a, value_length(values));
		else result = value_init_nil();
				
		value_clear(&values);
		if (result.type == VALUE_STOP && result.core.u_stop.type == STOP_EXIT) {
			value_clear(&result);
			break;
		}
				
		if (input_stream == stdin && value_empty_p(line_queue)) {
			printf("==> ");
			value_printf("%s\n", result);
		} else if (result.type == VALUE_ERROR) {
			// If one of the statements is an error, stop running, but only if the input stream is a 
			// file and not stdin.
			value_clear(&result);
			return 1;
		}
		
		value_clear(&result);
	}
	
	return 0;
}

value interpret_given_statement(value *variables, char *statement)
{
	value holder = statement_to_values(statement);
	if (holder.type == VALUE_ARY) {
		value res = interpret_values(variables, holder.core.u_a.a, value_length(holder));
		value_clear(&holder);
		return res;
	} else return holder;
}

value compile_statement(char *statement)
{
	value values = statement_to_values(statement);
	if (values.type == VALUE_ARY) {
		value sexp = compile_values(values.core.u_a.a, values.core.u_a.length);
		value_clear(&values);
		return sexp;
	} else return values;
}

/* A return value of 1 indicates EOF.
 */
int get_line(char *str, int length, FILE *stream)
{
	char *ret = fgets(str, length, stream);
	++linenum;
	if (ret == NULL) {
		is_eof = TRUE;
		return 1;
	}
	
	return fix_up_line(str, TRUE);
}

int fix_up_line(char *str, int is_first)
{
	char *ptr;
	int is_prev_backslash = 0;
	int result = 0;
	
	ptr = str - 1;
	while (*(++ptr)) {
		// Remove comments.
		if (*ptr == '/' && *(ptr+1) == '/' && stream_quote_balance == 0 && stream_regex_balance == 0) {
			*ptr = '\n';
			*(ptr+1) = '\0';
			break;
		}
		
		switch(*ptr) {
		case '(':
			++stream_paren_balance; break;
		case ')':
			--stream_paren_balance; break;
		case '[':
			++stream_bracket_balance; break;
		case ']':
			--stream_bracket_balance; break;
		case '{':
			++stream_curly_balance; break;
		case '}':
			--stream_curly_balance; break;
		case '"':
			if (is_prev_backslash == 0)
				stream_quote_balance ^= 1;
			break;
		case '\'':
			if (is_prev_backslash == 0)
				stream_regex_balance ^= 1;
			break;
		case '\\':
			is_prev_backslash ^= 1;
			break;
		}
	}
	
	return result;
}

char * get_statement()
{
	char buffer[BIGBUFSIZE];
	size_t length = 0;

	stream_paren_balance = stream_bracket_balance = stream_curly_balance = stream_quote_balance = stream_regex_balance = 0;
	int incompleteness_type = STATEMENT_COMPLETE;
	
	do {
		if (incompleteness_type == STATEMENT_INCOMPLETE_CURLY) {
			buffer[length++] = ' ';
			buffer[length++] = 'n';
			buffer[length++] = 'l';
			buffer[length++] = ' ';
		}

		
		get_line(buffer + length, BIGBUFSIZE - length, input_stream);
		length += strlen(buffer + length);
		
		if (is_eof) break;
		
	} while ((incompleteness_type = is_statement_complete(buffer)) != STATEMENT_COMPLETE);
	
	char *res = value_malloc(NULL, length + 1);
	if (res == NULL) return NULL;
	strncpy(res, buffer, length);
	res[length] = '\0';
		
	return res;
}

value get_values()
{
	value x;
	
	if (value_empty_p(line_queue)) {
		char *str = get_statement();
		if (is_eof)
			return value_init_nil();
		x = statement_to_values(str);
		value_free(str);
		return x;
	} else {
		x = line_dequeue();
		return x;
	}
}

void statement_to_words(char *words[], size_t wordcount, char *statement)
{	
	int i;
	char *ptr = statement, *start;
	char *temp;
	
	ptr = skip_whitespace(ptr);
	for (i = 0; *ptr && i < wordcount; ++i) {
		start = ptr;
		ptr = end_of_word(start);
		
		temp = value_malloc(NULL, ptr-start+1);
		if (temp == NULL) return;
		strncpy(temp, start, ptr-start);
		temp[ptr-start] = '\0';
		
		words[i] = temp;
		ptr = skip_whitespace(ptr);
	}
	
	for (; i < wordcount; ++i)
		words[i] = NULL;
}

value statement_to_values(char *statement)
{
	if (*(skip_whitespace(statement)) == '\0') {
		return value_init_nil();
	}
	
	size_t wordcount = count_words(statement);
	if (wordcount == 0)
		return value_init_nil();
	
	/* Stage 1: Read in (statement) and put each word into (words). */
	
	size_t i;
	char *words[wordcount];
	char *ptr = statement, *start;
	char *temp;
	
	ptr = skip_whitespace(ptr);
	for (i = 0; *ptr; ++i) {
		start = ptr;
		ptr = end_of_word(start);
		
		temp = value_malloc(NULL, ptr-start+1);
		if (temp == NULL) return value_init_error();
		strncpy(temp, start, ptr-start);
		temp[ptr-start] = '\0';
		
		words[i] = temp;
		ptr = skip_whitespace(ptr);
	}
	
	value values[wordcount];
	int error_p = words_to_values(values, words, wordcount);
	for (i = 0; i < wordcount; ++i) {
		value_free(words[i]);
	}
	if (error_p)
		return value_init_error();
	
	return value_set_ary_ref(values, wordcount);
}

char * values_to_statement(value values[], size_t length)
{
	char str[BIGBUFSIZE];
	char *ptr = str;
	size_t i;
	for (i = 0; i < length; ++i) {
		strcpy(ptr, values[i].core.u_s);
		ptr += strlen(ptr);
		*(ptr++) = ' ';
	}
	
	*ptr = '\0';
	return str;
}

int words_to_values(value values[], char *words[], size_t wordcount)
{
	size_t i;
	value x;
	
	for (i = 0; i < wordcount; ++i) {
		if ((values[i] = value_set_str_smart(words[i], 0)).type == VALUE_ERROR) {
			value_clear(&values[i]);
			values[i].type = VALUE_ID;
			values[i].core.u_id = value_malloc(NULL, strlen(words[i])+1);
			if (values[i].core.u_id == NULL) return VALUE_ERROR;
			strcpy(values[i].core.u_id, words[i]);
			
			/* Is values[i] a user-defined function? */
			values[i].type = VALUE_VAR;
			// Pull a copy of x out of ud_functions. It would be better if it could pull 
			// the value out instead of a copy, because that way UDF_SHELLs could be 
			// converted into UDFs and it would only have to be done one time.
			x = value_hash_get(ud_functions, values[i]);
			if (x.type != VALUE_NIL) {
				value_clear(&values[i]);
				values[i] = x;
				continue;			
			}
			
			/* Is values[i] a built-in function? */
			value_clear(&x);
			values[i].type = VALUE_ID;
			x = value_hash_get(primitive_funs, values[i]);
			if (x.type != VALUE_NIL) {
				value_clear(&values[i]);
				values[i] = x;					
				continue;
			}
			
			value_clear(&x);
			values[i].type = VALUE_ID;
			if (is_symbol(values[i].core.u_id)) {
				// Do nothing.
			} else {
				values[i].type = VALUE_VAR;
			}
		}
	}
		
	return 0;
}

/* 
 * Compiles a list of values into an S-expression. Does not guarantee that 
 * (words) will be intact -- some values may change.
 */
value compile_values(value words[], size_t wordcount)
{
	if (wordcount == 0) {
		previous_truth_value = FALSE;
		previous_was_if_statement = FALSE;
		return value_init_nil();
	}
	
	value sexp = value_init_nil();
	
	size_t i, j, inx = -1, binx = -1, cinx = -1;
	int parens = 0, brackets = 0, curlies = 0;
	
	// Do a preliminary compilation. Find IDs that look like functions and make them  
	// into UDF shells.
	for (i = 0; i < wordcount; ++i) {
		if (words[i].type == VALUE_BIF && words[i].core.u_bif->f == &value_def_arg) {
			assume_first_is_function = FALSE;
			
			// If the function was previously defined, delete the old definition.
			if (words[i+1].type == VALUE_UDF) {
				value temp = words[i+1];
				words[i+1] = value_set_str(temp.core.u_udf->name);
				words[i+1].type = VALUE_VAR;
				value_clear(&temp);
			}
			
			// A function is being defined. Find the name of the function and the 
			// number of arguments.
			value name = words[i+1];
			size_t argc = 0;
			for (j = i+3; j < wordcount; ++j)
				if (words[j].type == VALUE_ID && streq(words[j].core.u_id, ")"))
					break;
				else if (words[j].type == VALUE_VAR) ++argc;
									
			value shell = value_init(VALUE_UDF_SHELL);
			shell.core.u_udf->name = value_malloc(NULL, strlen(name.core.u_var) + 1);
			return_if_null(shell.core.u_udf->name);
			strcpy(shell.core.u_udf->name, name.core.u_var);
			shell.core.u_udf->spec.associativity = 'l';
			shell.core.u_udf->spec.argc = argc;
			if (argc == 1)
				shell.core.u_udf->spec.precedence = 16;
			else shell.core.u_udf->spec.precedence = 15;
			
			// Find every call to the defined function, and convert it to a 
			// function shell.
			i = j - 1;
			for (; j < wordcount; ++j) {
				var_to_shell(&words[j], name, shell);
			}
			
			value_clear(&shell);
		}
	}
	
	value res;
	
	// Find parentheses and brackets. Also determine if the expression contains any functions.
	int first_function_index = -1;
	int scope_assume_first_is_function = assume_first_is_function;
	for (i = 0; i < wordcount; ++i) {
		if (parens == 0 && brackets == 0 && curlies == 0 && 
				(words[i].type == VALUE_BIF || words[i].type == VALUE_UDF || words[i].type == VALUE_UDF_SHELL))
			if (first_function_index == -1)
				first_function_index = i;
		
		if (words[i].type == VALUE_BIF && words[i].core.u_bif->f == &value_for_arg)
			assume_first_is_function = FALSE;

		
		if (words[i].type != VALUE_ID) {
//			continue;
				
		} else if (streq(words[i].core.u_id, "(")) {
			if (parens == 0)
				inx = i;
			++parens;
		} else if (streq(words[i].core.u_id, ")")) {
			--parens;
			if (parens < 0) {
				value_error(1, "Syntax Error: Opening parenthesis not found.");
				value_clear(&sexp);
				return value_init_error();

			} else if (parens == 0 && brackets == 0 && curlies == 0) {
				// If we are inside brackets, don't evaluate the statement in parentheses just yet.
				
				if (inx == -1) {
					value_error(1, "Syntax Error: Opening parenthesis not found.");
					value_clear(&sexp);
					return value_init_error();
				}
				
				res = compile_values(words+inx+1, i-inx-1);
								
				if (res.type == VALUE_ERROR)
					break;
				
				// 
				// This code removes all the words that have been evaluated, 
				// i.e. the words in between the parentheses and the 
				// parentheses themselves.
				// 
				wordcount = delete_from_words(words, wordcount, res, i, inx);
								
				// Move (i) back to the beginning of the parentheses.
				i = inx;
				
			} // if (paren_balance)
			
		} else if (streq(words[i].core.u_id, "[")) {
			if (brackets == 0)
				binx = i;
			++brackets;
		} else if (streq(words[i].core.u_id, "]")) {
			--brackets;
			if (curlies < 0) {
				value_error(1, "Syntax error: Opening square bracket not found.");
				value_clear(&sexp);
				return value_init_error();
				
			} else if (parens == 0 && brackets == 0 && curlies == 0) {
				
				if (binx == -1) {
					value_error(1, "Syntax error: Opening square bracket not found.");
					value_clear(&sexp);
					return value_init_error();
				}
				
				// res = the value inside the brackets.
				res = compile_values(words+binx+1, i-binx-1);				
				if (res.type == VALUE_ERROR)
					break;
				
				int is_infix = infix_p(words, wordcount);
				
				value_clear(&words[binx]);
								
				int offset = 0;
				int at_assign = 0;
				int word_i = -1;
				
				// Set words[binx] to the function, be it at(), at=(), at+=(), etc.
				if (is_infix && words[word_i = i+1].type == VALUE_BIF || 
						!is_infix && binx >= 2 && words[word_i = binx-2].type == VALUE_BIF) {
					// If there is an assignment operator nearby, convert this from at() to at=() 
					// or something similar.
					
					at_assign = 1;
					if (words[word_i].core.u_bif->f == &value_assign_arg)
						words[binx] = value_set_fun(&value_at_assign_arg);
					else if (words[word_i].core.u_bif->f == &value_assign_add_arg)
						words[binx] = value_set_fun(&value_at_assign_add_arg);
					else if (words[word_i].core.u_bif->f == &value_assign_sub_arg)
						words[binx] = value_set_fun(&value_at_assign_sub_arg);
					else if (words[word_i].core.u_bif->f == &value_assign_mul_arg)
						words[binx] = value_set_fun(&value_at_assign_mul_arg);
					else if (words[word_i].core.u_bif->f == &value_assign_div_arg)
						words[binx] = value_set_fun(&value_at_assign_div_arg);
					else if (words[word_i].core.u_bif->f == &value_assign_mod_arg)
						words[binx] = value_set_fun(&value_at_assign_mod_arg);
					else if (words[word_i].core.u_bif->f == &value_assign_and_arg)
						words[binx] = value_set_fun(&value_at_assign_and_arg);
					else if (words[word_i].core.u_bif->f == &value_assign_xor_arg)
						words[binx] = value_set_fun(&value_at_assign_xor_arg);
					else if (words[word_i].core.u_bif->f == &value_assign_or_arg)
						words[binx] = value_set_fun(&value_at_assign_or_arg);
					else if (words[word_i].core.u_bif->f == &value_assign_shl_arg)
						words[binx] = value_set_fun(&value_at_assign_shl_arg);
					else if (words[word_i].core.u_bif->f == &value_assign_shr_arg)
						words[binx] = value_set_fun(&value_at_assign_shr_arg);
					else {
						at_assign = 0;
						words[binx] = value_set_fun(&value_at_arg);
					}
					
				} else {
					words[binx] = value_set_fun(&value_at_arg);
				}
				
				offset += at_assign;
				
				value *specptr = value_hash_get_ref(primitive_specs, words[binx]);
				if (specptr == NULL) {
					value_error(1, "Error: Undefined value %ts. Probably you tried to call a function internally which does not exist.", words[binx]);
				}
				words[binx].core.u_bif->spec = specptr->core.u_spec;
				
				// Put res into words[binx+1].
				value_clear(&words[binx+1]);
				words[binx+1] = res;
				res.type = VALUE_NIL; // Now res can't be accidentally cleared.
				
				// If the statement is in prefix notation don't do (a at i), instead do (at a i).
				if (!is_infix && binx >= 1) {
					value temp = words[binx];
					words[binx] = words[binx-1];
					words[binx-1] = temp;
				}
				
				// See if there are multiple brackets in a row.
//				j = i;
//				while (words[j+1].type == VALUE_ID && streq(words[j+1].core.u_id, "[")) {
//					res = compile_values(...stuff...);
//				}
				
				if (is_infix) {
					// If at_assign is 0, then the function is at(). Otherwise, it is at=(), at+=(), etc.
					if (at_assign != 0) {
						// Flip the (at) with the value inside the brackets, so (a[0] = x) will compile to 
						// (a 0 at_equals x) instead of (a at_equals 0 x). This will make it compile to 
						// prefix as expected.
						value temp = words[binx];
						words[binx] = words[binx+1];
						words[binx+1] = temp;
					}
					
					// The statement is in infix notation. Remove any stray words inside the brackets, 
					// the closing bracket, and possibly the assignment operator if offset == 1.
					for (j = 1; i+j+offset < wordcount; ++j) {
						value_clear(&words[binx+1+j]);
						words[binx+1+j] = words[i+j+offset];
						words[i+j+offset].type = VALUE_NIL;
					}
					wordcount = binx + 1 + j;
				
				} else if (!is_infix && offset) {
					// If the expression is in prefix notation and the array index is being assigned, 
					// the assignment operator still needs to be deleted.
					for (j = 1; i+j < wordcount; ++j) {
						value_clear(&words[binx+1+j]);
						words[binx+1+j] = words[i+j];
						words[i+j].type = VALUE_NIL;
					}
					
					wordcount = binx + 1 + j;
					for (j = binx-2; j+1 < wordcount; ++j)
						words[j] = words[j+1];
					words[j].type = VALUE_NIL;
					--wordcount;
				}
				
				i = binx + 1;
				
			}
			
		} else if (streq(words[i].core.u_id, "{")) {
			if (curlies == 0)
				cinx = i;
			++curlies;
		} else if (streq(words[i].core.u_id, "}")) {
			--curlies;
			if (curlies < 0) {
				value_error(1, "Syntax Error: Opening curly bracket was not found.");
				value_clear(&sexp);
				return value_init_error();

			} else if (parens == 0 && brackets == 0 && curlies == 0) {
				// If we are inside brackets, don't evaluate the statement in parentheses just yet.
				
				if (cinx == -1) {
					// Probably, this code never executes because curlies would be < 0 so the error 
					// will be caught earlier. It's still here just in case.
					value_error(1, "Syntax Error: Opening curly bracket not found.");
					value_clear(&sexp);
					return value_init_error();
				}
								
				// Newlines that aren't near any expressions are ignored. Others are converted to 
				// semicolons.
				size_t prev_nl_inx = cinx;
				int inner_curlies = 0;
				for (j = cinx+1; j < i; ++j) {
					if (words[j].type != VALUE_ID)
						continue;
					
					// Keep track of whether there are any curly brackets inside of the block. If there are, 
					// don't delete their nl's because those curly brackets will need them later. For example, 
					// if you have { { 3 nl 2 } } it's supposed to compile to (; 3 2), but if the outer curly 
					// brackets remove the nl, then the inner curly brackets will see { 3 2 } which won't 
					// compile correctly.
					if (streq(words[j].core.u_id, "{")) {
						++inner_curlies;
					} else if (streq(words[j].core.u_id, "}")) {
						--inner_curlies;
					
					} else if (inner_curlies == 0 && streq(words[j].core.u_id, "nl")) {
						if (words[j-1].type == VALUE_ID && streq(words[j-1].core.u_id, "{")	|| // previous was a curly bracket
							words[j-1].type == VALUE_BIF && words[j-1].core.u_bif->f == &value_do_both_arg || // previous was a semicolon
							words[j+1].type == VALUE_ID && (streq(words[j+1].core.u_id, "}") || // next is a curly bracket or newline
															streq(words[j+1].core.u_id, "nl"))) {
							// The nl is not surrounded by expressions. Delete it.
							value_clear(&words[j]);
							size_t k;
							for (k = j; k < wordcount-1; ++k)
								words[k] = words[k+1];
							words[k].type = VALUE_NIL;
							--wordcount;
							--i;
							--j;
						} else {
							// The nl is surrounded by expressions. Do something with it.
							
							res = compile_values(words+prev_nl_inx+1, j-prev_nl_inx-1);
							if (res.type == VALUE_ERROR)
								break;
							
							size_t old_wordcount = wordcount;
							wordcount = delete_from_words(words, wordcount, res, j-1, prev_nl_inx+1);
							i -= old_wordcount - wordcount;
							j -= old_wordcount - wordcount;
														
							// Convert the nl to a semicolon. It has to pull the function from (primitive_funs) 
							// rather than just using value_set_fun() because it has to get the function spec 
							// correct.
							value_clear(&words[j]);
							value key = value_set_id(";");
							words[j] = value_hash_get(primitive_funs, key);
							value_clear(&key);
							
							prev_nl_inx = j;
						}

					}
				}
				
				if (prev_nl_inx != cinx) {
					res = compile_values(words+prev_nl_inx+1, j-prev_nl_inx-1);
					if (res.type == VALUE_ERROR)
						break;
					
					size_t old_wordcount = wordcount;
					wordcount = delete_from_words(words, wordcount, res, j-1, prev_nl_inx+1);
					i -= old_wordcount - wordcount;
					j -= old_wordcount - wordcount;
				}
				
				res = compile_values(words+cinx+1, i-cinx-1);
								
				if (res.type == VALUE_ERROR)
					break;
				
				// 
				// This code removes all the words that have been evaluated, 
				// i.e. the words in between the brackets and the brackets
				// themselves.
				// 
				value_clear(&words[cinx]);
				words[cinx] = res;
				res.type = VALUE_NIL;
				for (j = 1; i+j < wordcount; ++j) {
					value_clear(&words[cinx+j]);
					words[cinx+j] = words[i+j];
					words[i+j].type = VALUE_NIL;
				}
				
				wordcount = cinx + j;
				
				// Move (i) back to the beginning of the brackets.
				i = cinx;
				
			} // if (paren_balance)
			
		}

		
	} // find parentheses and brackets
	
	if (sexp.type == VALUE_ERROR)
		return sexp;
	if (res.type == VALUE_ERROR)
		return res;
	
	// If there are more values before the first function than that function has arguments, 
	// there is probably a mistake in the syntax.
	if (scope_assume_first_is_function && first_function_index != -1 && 
			words[first_function_index].type != VALUE_UDF_SHELL) {
		
		struct value_spec wspec = get_spec(words[first_function_index]);
		if (wspec.argc < first_function_index && wspec.optional >= wspec.argc) {
			value tmpexp;
			tmpexp.type = VALUE_BLK;
			tmpexp.core.u_blk.a = words;
			tmpexp.core.u_blk.length = wordcount;
			tmpexp.core.u_blk.s = NULL;
			value_error(0, "Warning: Expression %s will probably not evaluate as expected (function at index %d has arg count %d).", tmpexp, first_function_index, arg_count(words[first_function_index]));
		}
	}
	
	// Convert to prefix notation.
	
	if (infix_p(words, wordcount)) {
		value old_words[wordcount];
		
		for (i = 0; i < wordcount; ++i) {
			old_words[i] = words[i];
			words[i].type = VALUE_NIL;
		}
		
		int error_p = infix_to_prefix(words, old_words, wordcount);

		if (error_p) {
			value_clear(&sexp);
			sexp = value_init_error();
		}
	}

	if (sexp.type == VALUE_ERROR)
		return sexp;
	
	// Fix things like (a[i][j] = x). It compiles to (at_equals at a i j x) so 
	// change it to (at_equals a i j x). This is an inelegant solution because 
	// it should be changed earlier, but at least it works.
	value func_at = value_set_fun(&value_at_arg);
	for (i = 0; i < wordcount-1; ++i) {
		if (value_eq(words[i+1], func_at) && words[i].type == VALUE_BIF) {
			if (
			words[i].core.u_bif->f == &value_at_assign_arg || 
			words[i].core.u_bif->f == &value_at_assign_add_arg || 
			words[i].core.u_bif->f == &value_at_assign_sub_arg || 
			words[i].core.u_bif->f == &value_at_assign_mul_arg || 
			words[i].core.u_bif->f == &value_at_assign_div_arg || 
			words[i].core.u_bif->f == &value_at_assign_mod_arg || 
			words[i].core.u_bif->f == &value_at_assign_and_arg || 
			words[i].core.u_bif->f == &value_at_assign_xor_arg || 
			words[i].core.u_bif->f == &value_at_assign_or_arg || 
			words[i].core.u_bif->f == &value_at_assign_shl_arg || 
			words[i].core.u_bif->f == &value_at_assign_shr_arg
			) {
				value_clear(&words[i+1]);
				for (j = i+1; j < wordcount-1; ++j) {
					words[j] = words[j+1];
					words[j+1].type = VALUE_NIL;
				}
				--wordcount;
			}
		}
	}
	value_clear(&func_at);
	
	// Convert to an S-expression and return.
	
	value_clear(&sexp);
	size_t it = 0;
	sexp = prefix_words_to_sexp(words, &it, wordcount);
		
	assume_first_is_function = TRUE;
		
	return sexp;
}

value prefix_words_to_sexp(value words[], size_t *i, size_t length)
{
	// If the expression contains only one argument, place the argument inside a block.
	if (length == 1 && words[*i].type != VALUE_BIF && words[*i].type != VALUE_UDF && words[*i].type != VALUE_UDF_SHELL) {
		if (words[*i].type == VALUE_BLK)
			return value_set(words[*i]);
		value sexp;
		
		sexp.type = VALUE_BLK;
		value_malloc(&sexp, next_size(1));
		return_if_error(sexp);
		sexp.core.u_blk.s = NULL;
		sexp.core.u_blk.a[0] = value_set(words[*i]);
		sexp.core.u_blk.length = 1;
		return sexp;
	}
	
	// If the s-expression does not start with a function name, just put every 
	// word into a block and return it.
	if (words[*i].type != VALUE_BIF && words[*i].type != VALUE_UDF && words[*i].type != VALUE_UDF_SHELL) {
		value sexp;
		
		sexp.type = VALUE_BLK;
		value_malloc(&sexp, next_size(length));
		return_if_error(sexp);
		sexp.core.u_blk.length = length;
		sexp.core.u_blk.s = NULL;
		size_t j;
		for (j = *i; j < length; ++j)
			sexp.core.u_blk.a[j] = value_set(words[j]);
		return sexp;
	}
	
	struct value_spec spec;
	if (words[*i].type == VALUE_BIF)
		spec = words[*i].core.u_bif->spec;
	else if (words[*i].type == VALUE_UDF)
		spec = words[*i].core.u_udf->spec;
	else if (words[*i].type == VALUE_UDF_SHELL)
		spec = words[*i].core.u_udf->spec;
	
	// For a function that takes any number of arguments, set the number of arguments 
	// to the total length of the given words so that they'll all be passed in.
	int argc = spec.argc;
	if (spec.rest_p) {
		argc = length - 1;
	}
		
	value sexp;
	sexp.type = VALUE_BLK;
	value_malloc(&sexp, next_size(argc+1));	
	return_if_error(sexp);	
	sexp.core.u_blk.s = NULL;
	sexp.core.u_blk.a[0] = value_set(words[*i]);
	
	int prev_quote_p = words[*i].type == VALUE_BIF && words[*i].core.u_bif->f == &value_quote_arg;
	int prev_def_p = words[*i].type == VALUE_BIF && words[*i].core.u_bif->f == &value_def_arg;
	size_t first = *i;
	++*i;
	size_t j;
	for (j = 1; j <= argc && *i < length; ++j) {
		if (!prev_def_p && !prev_quote_p && (words[*i].type == VALUE_BIF || words[*i].type == VALUE_UDF || words[*i].type == VALUE_UDF_SHELL)) {
			value temp = prefix_words_to_sexp(words, i, length);
			if (temp.type == VALUE_ERROR) {
				value_clear(&sexp);
				return temp;
			}
			sexp.core.u_blk.a[j] = temp;
		} else {
			sexp.core.u_blk.a[j] = value_set(words[(*i)++]);
		}
	}
	
	// If this is the outermost sexp and there are too many arguments, return an error. It can tell 
	// if it's the outermost sexp if (first) is equal to 0, which means the sexp starts at the 
	// beginning of (words).
	if (first == 0 && *i < length) {
		// This should be done at runtime.
		value_error(1, "Argument Error: Too many arguments in function %s (%d expected, at least %ld found).", words[first], argc, j);
		value_clear(&sexp);
		return value_init_error();
	}
	
	// If the sexp is missing some arguments, unless the function takes any number of 
	// arguments, set all the missing arguments to nil.
//	if (!argc_changed)
//		for (; j <= argc; ++j)
//			sexp.core.u_blk.a[j] = value_init_nil();
	
	sexp.core.u_blk.length = j;
	
	return sexp;
}

value interpret_values(value *variables, value words[], size_t wordcount)
{
	if (wordcount == 0) {
		return value_init_nil();
	}
	value sexp = compile_values(words, wordcount);
	if (sexp.type == VALUE_ERROR) {
		printf("\tin statement: ");
		print_values(words, wordcount);
		return sexp;
	}
	
	value res = eval(variables, sexp);
	value_clear(&sexp);
	return res;
}

/* 
 * Determines whether (words) is infix or prefix. Looks at the first word that's 
 * not a VALUE_ID. If it's a function call, then the words are in prefix notation. 
 * If it is a value, then they are in infix notation. If it is a function call with 
 * only one argument, then it's impossible to tell yet, so go to the next word.
 */
int infix_p(value words[], size_t wordcount)
{
	int is_infix = FALSE;
	size_t i;
	for (i = 0; i < wordcount; ++i)
		if (words[i].type != VALUE_ID && words[i].type != VALUE_BIF && words[i].type != VALUE_UDF && words[i].type != VALUE_UDF_SHELL) {
			if (i + 1 != wordcount) {
				is_infix = TRUE;
				break;
			}
		} else if (words[i].type != VALUE_ID) { 
			// If arg count is 2 or greater, the expression is prefi.
			// If arg count is 1, we don't know yet if the statement is prefix or infix.
			if (arg_count(words[i]) != 1)
				break;
		}
	
	return is_infix;
}

/* 
 * Converts an infix expression to prefix based on the Shunting Yard Algorithm.
 * http://en.wikipedia.org/wiki/Shunting_yard_algorithm#The_algorithm_in_detail 
 * 
 * outwords: Destination array, (length) elements long. Holds the prefix 
 *   expression.
 * inwords: Source array, (length) elements along. Holds an infix expression.
 * length: Length of (outwords) and (inwords).
 * 
 * This is not exactly like the Shunting Yard Algorithm, as it has been modified 
 * to properly handle unary operators. In pseudo-code, the algorithm looks like: 

pstack = new stack

for i from length downto 0: 
  if inwords[i] is a value:
    outwords.prepend(j)
  else if inwords[i] is a function: 
    while pstack.top is a function: 
	  if inwords[i] has only one argument: 
	    switch associativity from left to right or vice versa
		
	  unless (inwords[i] is left-associative and inwords[i].precedence <= pstack.top.precedence)
	      OR (inwords[i] is right-associative and inwords[i].precedence < pstack.top.precedence): 
	    break
	  outwords.prepend(pstack.pop())
	pstack.push(inwords[i])

 * 
 */
int infix_to_prefix(value outwords[], value inwords[], size_t length)
{
	value pstack[length];
	
	// The index of the first empty value in (pstack).
	int pindex = 0;
		
	size_t i, j = length;
	
	
	// This loop stops when -1 == i, and not when 0 > i, because if size_t is unsigned then 0 will always be <= i.
	for (i = length-1; -1 != i; --i) {
		if (inwords[i].type != VALUE_ID && inwords[i].type != VALUE_BIF && inwords[i].type != VALUE_UDF && inwords[i].type != VALUE_UDF_SHELL) {
			outwords[--j] = inwords[i];
		} else if (inwords[i].type == VALUE_BIF || inwords[i].type == VALUE_UDF || inwords[i].type == VALUE_UDF_SHELL) {
			
			while (pindex > 0) {
				
				struct value_spec spec1;
				if (inwords[i].type == VALUE_BIF) spec1 = inwords[i].core.u_bif->spec;
				else if (inwords[i].type == VALUE_UDF || inwords[i].type == VALUE_UDF_SHELL) spec1 = inwords[i].core.u_udf->spec;
				
				struct value_spec spec2;
				if (pstack[pindex-1].type == VALUE_BIF) spec2 = pstack[pindex-1].core.u_bif->spec;
				else if (pstack[pindex-1].type == VALUE_UDF || pstack[pindex-1].type == VALUE_UDF_SHELL) spec2 = pstack[pindex-1].core.u_udf->spec;
								
				if (spec1.argc == 1 && !((spec2.associativity == 'l' && spec1.precedence <= spec2.precedence) ||
					(spec2.associativity == 'r' && spec1.precedence < spec2.precedence) ))
					break;
				
				// Determine if the function is left- or right-associative, and behave accordingly.
				if (!((spec2.associativity == 'r' && spec1.precedence <= spec2.precedence) ||
					(spec2.associativity == 'l' && spec1.precedence < spec2.precedence) ))
					break;
								
				outwords[--j] = pstack[--pindex];
			}
			
			pstack[pindex++] = inwords[i];
		} else {
			if (is_symbol(inwords[i].core.u_id))
				value_error(1, "Syntax Error: Unexpected symbol %s.", inwords[i]);
			else value_error(1, "Compiler Error: In to_postfix(), undefined id %s.", inwords[i]);
			return VALUE_ERROR;
		}
	}
	
	while (pindex > 0) {
		outwords[--j] = pstack[--pindex];
	}
	
	return 0;
}

size_t count_words(char *statement)
{
	size_t wordcount = 0;
	statement = skip_whitespace(statement);
	while (*statement != '\0') {
		statement = end_of_word(statement);
		statement = skip_whitespace(statement);
		++wordcount;

	}
	
	return wordcount;
}

size_t delete_from_words(value words[], size_t wordcount, value res, size_t i, size_t inx)
{
	value_clear(&words[inx]);
	words[inx] = res;
	
	if (i <= inx)
		return wordcount;
	size_t j;
	for (j = 1; i+j < wordcount; ++j) {
		value_clear(&words[inx+j]);
		words[inx+j] = words[i+j];
		words[i+j].type = VALUE_NIL;
	}
	
	return inx + j;
}

void var_to_shell(value *body, value name, value shell)
{
	if (body->type == VALUE_BLK) {
		size_t i;
		for (i = 0; i < body->core.u_blk.length; ++i)
			var_to_shell(&body->core.u_blk.a[i], name, shell);
		
	} else if (body->type == VALUE_UDF) {
		// When redefining recursive functions, we can't use the old definition 
		// of the function. Delete it and add in the new function shell.
		if (streq(body->core.u_udf->name, name.core.u_var)) {
			value_clear(body);
			*body = value_set(shell);
		}
		
	} else if (value_eq(*body, name)) {
		value_clear(body);
		*body = value_set(shell);
	}
}

value get_next_word(value words[], size_t length)
{
	value res = value_init_nil();
	if (length <= 0) {
		// Return nil.
		
	} else if (words[0].type == VALUE_ID && streq(words[0].core.u_id, "(")) {
		size_t i;
		int balance = 1;
		for (i = 1; i < length; ++i)
			if (words[i].type == VALUE_ID && streq(words[i].core.u_id, "("))
				++balance;
			else if (words[i].type == VALUE_ID && streq(words[i].core.u_id, ")"))
				if (--balance == 0)
					break;
		
		if (balance == 0)
			res = value_set_block(words, i+1);
		
	} else if (words[0].type == VALUE_ID && streq(words[0].core.u_id, "{")) {
		size_t i;
		int balance = 1;
		for (i = 1; i < length; ++i)
			if (words[i].type == VALUE_ID && streq(words[i].core.u_id, "{"))
				++balance;
			else if (words[i].type == VALUE_ID && streq(words[i].core.u_id, "}"))
				if (--balance == 0)
					break;
		
		if (balance == 0)
			res = value_set_block(words+1, i-1);
				
	} else {
		res = value_set_block(words, 1);
	}
	
	return res;
}

char * end_of_word(char *statement)
{
 	char orig = *statement;
	if (orig == '\0')
		return statement;
	
	// Hex numbers are stated like "0x123", so that needs to be read as legal.
	if (orig == '0' && *(statement+1) == 'x') {
		++statement;
		while (isdigit(*(++statement)) || *statement >= 'a' && *statement <= 'f')
			;
		return statement;
	}
	
	
	// A symbol starts with a ':'.
	if (orig == ':' && isalpha(*(statement+1)))
		orig = *(++statement);
	else
		// A variable can start with any number of $ symbols.
		while (orig == '$' && (*(statement+1) == '$' || isalpha(*(statement+1))))
			orig = *(++statement);
	
	// In a short function name, such as 'x!', the x will just get skipped over if 
	// we go straight to the while loop. So do this part first.
	if (isalpha(orig) && (*(statement+1) == '!' || *(statement+1) == '?'))
		return statement += 2;
	
	int contains_dot_p = FALSE;
		
	while (is_same_type(*(++statement), orig) || 
				// The word can start with a letter and contain numbers.
				((isalpha(orig) || orig == '_') && isdigit(*statement)) || 
				
				// A number can contain a single 'e' to indicate scientific notation.
				isdigit(orig) && *statement == 'e' || 
				
				// A word can contain a dot to indicate a call to a class's method or variable.
				isalpha(orig) && *statement == '.' ||
				
				// Strings only terminate in a special case -- see bottom of loop.
				orig == '"' || orig == '\''
			) {
		
		if (*statement == '.' && isalnum(orig)) {
			if (contains_dot_p) {
				--statement;
				break;
			} else contains_dot_p = TRUE;
		}
				
		if (*statement == '\0')
			break;
		
		// A word can end in an exclamation mark or a question mark.
		if (isalpha(orig) && (*(statement+1) == '!' || *(statement+1) == '?')) {
			statement += 2;
			break;
		}
		
		if (orig == '"' && *statement == '"') {
			char *back = statement;
			while (*(--back) == '\\')
				;
			++back;
			if ((statement-back & 1) == 0) {
				++statement;
				break;
			}
		} else if (*statement == '"' && orig != '\'') {
			break;
		}
		
		if (orig == '\'' && *statement == '\'') {
			char *back = statement;
			while (*(--back) == '\\')
				;
			++back;
			if ((statement-back & 1) == 0) {
				++statement;
				break;
			}
		} else if (*statement == '\'' && orig != '"') {
			break;
		}
		
	}
		
	return statement;
}

char * skip_whitespace(char *statement)
{
	while (isspace(*statement))
		++statement;
	return statement;
}

int is_same_type(char c, char orig)
{
	if (same_type_determiner == SAME_TYPE_VALUE) {
		if (isbracket(c))
			return FALSE;
		if (isalpha(orig))
			if (isalpha(c) || c == '_') return TRUE;
			else return FALSE;
		if (isdigit(orig))
			if (isdigit(c) || c == '.') return TRUE;
			else return FALSE;
		if (orig == '"')
			if (c == '"') return TRUE;
			else return FALSE;
		if (orig == '\'')
			if (c == '\'') return TRUE;
			else return FALSE;
		if (isbracket(orig))
			return FALSE;
		if (iscsymbol(orig))
			if (iscsymbol(c)) return TRUE;
			else return FALSE;
		else return FALSE; // Returns FALSE even if (c) and (orig) are the same character.
	} else if (same_type_determiner == SAME_TYPE_TREE) {
		if (isbracket(c))
			return FALSE;
		if (isalpha(orig))
			if (isalpha(c) || c == '_' || iscsymbol(c) || isdigit(c)) return TRUE;
			else return FALSE;
		if (isdigit(orig) || orig == '-')
			if (isdigit(c) || c == '.') return TRUE;
			else return FALSE;
		if (orig == '"')
			if (c == '"') return TRUE;
			else return FALSE;
		if (orig == '\'')
			if (c == '\'') return TRUE;
			else return FALSE;
		if (isbracket(orig))
			return FALSE;
		if (iscsymbol(orig))
			if (iscsymbol(c)) return TRUE;
			else return FALSE;
		else return FALSE; // Returns FALSE even if (c) and (orig) are the same character.
	}
}

int char_type(char c)
{
	return isalpha(c) ? CHARTYPE_ALPHA : isdigit(c) ? CHARTYPE_NUMBER : isspace(c) ? CHARTYPE_SPACE 
			: isbracket(c) ? CHARTYPE_BRACKET
			: iscsymbol(c) ? CHARTYPE_SYMBOL
			: CHARTYPE_OTHER;
}

/* 
 * Return Values
 * 0: incomplete because of quotes, parentheses or brackets
 * 1: complete
 * 2: incomplete because of curly brackets
 */
int is_statement_complete(char *statement)
{
	char match_stack[1024];
	size_t i = 0;

	char *ptr = statement - 1;
	int parens = 0, brackets = 0, curlies = 0, quotes = 0, regexes = 0;
	int is_prev_backslash = FALSE;
	while (*(++ptr)) {
		switch (*ptr) {
			case '(':
				if (quotes == 0 && regexes == 0) match_stack[i++] = '(';
				break;
			case ')':
				if (quotes == 0 && regexes == 0)
					if (match_stack[--i] != '(') {
						value_error(1, "Syntax error: Mismatched control characters.");
						return STATEMENT_COMPLETE;
					}
				break;
			case '[':
				if (quotes == 0 && regexes == 0) match_stack[i++] = '[';
				break;
			case  ']':
				if (quotes == 0 && regexes == 0)
					if (match_stack[--i] != '[') {
						value_error(1, "Syntax error: Mismatched control characters.");
						return STATEMENT_COMPLETE;
					}				
				break;
			case '{':
				if (quotes == 0 && regexes == 0) {
					++curlies;
					match_stack[i++] = '{';
				}
				break;
			case '}':
				if (quotes == 0 && regexes == 0) 
					if (match_stack[--i] != '{') {
						value_error(1, "Syntax error: Mismatched control characters.");
						return STATEMENT_COMPLETE;
					} else --curlies;	
				break;
			case '"':
				if (regexes == 0 && !is_prev_backslash)
					quotes ^= 1;
				break;
			case '\'':
				if (quotes == 0 && !is_prev_backslash)
					regexes ^= 1;
			case '\\':
				is_prev_backslash = !is_prev_backslash;
				break;
			default:
				break;
		}
		
		if (*ptr != '\\')
			is_prev_backslash = FALSE;
	}
	
	return i == 0 ? STATEMENT_COMPLETE : match_stack[i-1] == '{' ? STATEMENT_INCOMPLETE_CURLY : STATEMENT_INCOMPLETE_OTHER;
		
	return curlies > 0 ? STATEMENT_INCOMPLETE_CURLY : parens <= 0 && brackets <= 0 && 
			quotes == 0 && regexes == 0 ? STATEMENT_COMPLETE : STATEMENT_INCOMPLETE_OTHER;
}

void line_enqueue(value op)
{
	line_queue_back.core.u_l[0] = op;
	line_queue_back = line_queue_back.core.u_l[1] = value_init(VALUE_LST);
}

void line_enqueue_front(value op)
{
	value old = line_queue;
	line_queue = value_init(VALUE_LST);
	line_queue.core.u_l[0] = op;
	line_queue.core.u_l[1] = old;
}

value line_dequeue()
{
	value res = line_queue.core.u_l[0];
	value old = line_queue;
	line_queue = line_queue.core.u_l[1];
	value_free(old.core.u_l);
	return res;
}

/*
 *  interpreter.h
 *  Calculator
 *
 *  Created by Michael Dickens on 5/8/10.
 *
 */


#include "eval.h"

#define CHARTYPE_ALPHA 0
#define CHARTYPE_NUMBER 1
#define CHARTYPE_SYMBOL 2
#define CHARTYPE_SPACE 3
#define CHARTYPE_BRACKET 4
#define CHARTYPE_OTHER 5

#define WORD_LENGTH 64

// If the last statement was an if statement that was TRUE, this is TRUE. Otherwise, 
// it is FALSE. This is so, when reading a file, it can decide whether to evaluate 
// an else statement.
int previous_truth_value;
int previous_was_if_statement;

int assume_first_is_function;

// Call this function once before using the interpreter.
int init_interpreter();

int run_interpreter();

int stream_paren_balance, stream_bracket_balance, stream_curly_balance, stream_quote_balance, stream_regex_balance;

/* 
 * See value.h for a declaration of interpret_values(), values_to_statement(), 
 * line_enqueue_front(), line_enqueue(), line_dequeue(), get_next_word().
 */

value interpret_given_statement(value *variables, char *statement);
value compile_statement(char *statement);
int get_line(char *str, int length, FILE *stream);
int fix_up_line(char *str, int is_first);
char * get_statement();
value get_values();
void statement_to_words(char *words[], size_t wordcount, char *statement);
value statement_to_values(char *statement);

/* 
 * Compiles a list of words into an S-expression.
 */
value compile_values(value words[], size_t wordcount);
value prefix_words_to_sexp(value words[], size_t *i, size_t length);

/* 
 * Interprets a list of words. Calls compile_values(), then optimizations, then 
 * eval().
 */
value interpret_values(value *variables, value words[], size_t wordcount);
char *values_to_statement(value values[], size_t length);
int words_to_values(value values[], char *words[], size_t wordcount);
int infix_p(value words[], size_t wordcount);
int infix_to_prefix(value outwords[], value inwords[], size_t length);
void var_to_shell(value *body, value name, value shell);
size_t count_words(char *statement);

/* Deletes words (e.g. in parentheses), puts (res) in the proper index, 
 * and returns the new wordcount.
 */
size_t delete_from_words(value words[], size_t wordcount, value res, size_t i, size_t inx);

/* 
 * Reads through (statement) until the end  of the word is reached. 
 * Returns the string pointing to just after the end of the word.
 */ 
char * end_of_word(char *statement);
char * skip_whitespace(char *statement);
int is_same_type(char c, char orig);
int char_type(char c);

#define STATEMENT_INCOMPLETE_CURLY 3
#define STATEMENT_INCOMPLETE_QUOTE 2
#define STATEMENT_COMPLETE         1
#define STATEMENT_INCOMPLETE_OTHER 0
int is_statement_complete(char *statement);

/*
 *  main.m
 *  Simfpl
 *
 *  Created by Michael Dickens on 12/5/09.
 *
 */


#include "sexp_to_c.h"


value f(value op);
int test_regex();
int test_array();
int test_concat();
int test_list();
int test_hash();
int test_scope_change_speed();
int test_memory();

int consecutive_primes();

int main(int argc, const char *argv[])
{
	init_tools();
	init_values();
	init_evaluator();
	init_interpreter();
	init_tests();
	init_sexp_to_c();
	
	// TO TRY: Add an -O3 flag to Xcode's compile. Then compile and profile, and see if it runs faster.
	
//	run_tests();
//	run_benchmarks();
		
	if (argc > 1) {
		if (streq(argv[1], "test")) {
			run_tests();
		} else if (streq(argv[1], "benchmark")) {
			run_benchmarks();
		} else {
			value str = value_set_str(argv[1]);
			value_import(str);
			value_clear(&str);
		}
	} else {
		run_interpreter();
	}
	
	return 0;
}



value f(value op)
{
	return op;
}

int test_regex()
{
	regex_match("lalala happy", "([a-z]+) ([a-z]+)");
	regex_match("234between5", "[a-z]+");
	regex_match("9238ASLDKF", "[a-z]+");
	
	return 0;
}

int regex_match(char *str, char *regex)
{
	regex_t compiled;
	int r = regcomp(&compiled, regex, REG_EXTENDED);
	if (r != 0) {
		printf("Error: Regular expression did not compile.\n");
		return 1;
	}
	
	regmatch_t matches[5];
	int i, j;
	int match = regexec(&compiled, str, 5, matches, 0);
	if (match == 0)
		for (i = 0; i < 5; ++i) {
			if (matches[i].rm_so >= 0) {
				printf("match: ");
				for (j = matches[i].rm_so; j < matches[i].rm_eo; ++j)
					printf("%c", str[j]);
				printf("\n");
			}
		}
	else printf("no match\n");
	printf("\n");
	
	return 0;
}

int test_list()
{
	value list = value_init_nil();
	value num = value_set_long(10);
	long i, count;
	size_t start = usec();
	
	for (count = 0; count < 5; ++count) {
		for (i = 0; i < 10000000; ++i) {
			value_cons_now(num, &list);
		}
		value_clear(&list);
	}
	
	size_t finish = usec();
	printf("time to do %ld iterations: %ld\n", i, (long) (finish - start) / count);
	
	return 0;
}


/* 
 * For 32,000 elements
 * NIL: 0.01 sec
 * all: 0.17 sec
 * MPZ: 0.21 sec
 * MPF: 0.19 sec
 * STR: 0.24 sec
 * ID : 0.18 sec
 * LST: 0.04 sec
 * 
 * 
 */ 
int test_hash()
{
#define NUMBER ((1 << 15) + 1)
#define REPEATS 20
	
	value x = value_init_nil();
	
	value val = value_set_str("result");
	size_t i, j, k, start, finish;
	
	value keys[NUMBER];
	char *skeys[NUMBER];
	for (i = 0; i < NUMBER; ++i) {
		skeys[i] = value_malloc(NULL, 30);
		sprintf(skeys[i], "%ld", (long) i);
		
		value num = value_set_long(i);
		
		switch (i % 4) {
			case 0:
				keys[i] = value_set(num);
				break;
			case 1:
				keys[i] = value_set_double(i);
				break;
			case 2:
				keys[i] = value_cast(num, VALUE_STR);
				break;
			case 3:
				keys[i] = value_cast(num, VALUE_STR);
				keys[i].type = VALUE_ID;
				break;
			case 4:
				keys[i] = value_init(VALUE_LST);
				value_cons_now2(&num, &keys[i]);
				break;
			default:
				keys[i] = value_init_nil();
				break;
		}
		
		value_clear(&num);
		
		// This overrides the setting done above.
//		keys[i] = value_cast(value_set_long(i), VALUE_STR);
	}
	
	for (i = 1 << 4; i < NUMBER; i <<= 1) {
		long average = 0;
		long difference = 0;
		
		for (j = 0; j < REPEATS; ++j) {
			x = value_init(VALUE_HSH);
//			StrMap *map = strmap_new(HASH_DEFAULT_CAPACITY);
			
			start = usec();
			
			for (k = 0; k < i; ++k)
				value_hash_put(&x, keys[k], val);
//				strmap_put(map, skeys[k], sval);
			
			finish = usec();
			average += finish - start;
			if (labs((long) (average / (j+1)) - (finish - start)) > difference)
				difference = labs((long) (average / (j+1)) - (finish - start));

			value_clear(&x);
//			strmap_delete(map);
		}
		
		printf("time for %ld elements: %ld usec +/= %ld\n", (long) i, average / j, difference);
	}

#undef NUMBER
#undef REPEATS

	return 0;
}

int test_memory()
{
	int i, j;
	value var, ten = value_set_long(10);
	value container = value_init_nil();

	printf("testing memory\n");
	
	var.type = VALUE_VAR;
	var.core.u_var = "x";
	
	for (i = 1; i < 10000000; i *= 2) {
		container = value_init(VALUE_MPZ);
		size_t start = usec();
		for (j = 0; j < i; ++j) {
			value_add_now(&container, ten);
		}
		
		
		value_clear(&container);
		size_t finish = usec();
		printf("time to do and clear %d elements: %ld usec\n", i, (unsigned long) finish - start);
	}
	
//	size_t time = usec();
//	while (usec() - time < 5000000) ;
	
	return 0;
}

/* 
 * Find the longest sum of consecutive primes that add up to a prime number 
 * below one million.
 */
int consecutive_primes()
{
	value primes = value_init(VALUE_ARY);
	value i, million = value_set_long(1000000);
	for (i = value_set_long(0); value_lt(i, million); value_inc_now(&i))
		if (value_probab_prime_p(i))
			value_append_now(&primes, i);
	
	return 0;
}/*
 *  optimize.c
 *  Simfpl
 *
 *  Created by Michael Dickens on 8/10/10.
 *  
 *  All definitions for functions and variables in optimize.c can be found in value.h.
 *  
 */

#include "value.h"

/* 
 * Possible Optimizations
 * 
 * Trivial
 * -If there are two or more nested blocks with only one element, remove the extra blocks. 
 *  For example, ((1)) or (((1))) would become (1).
 * -Adding zero
 * -Multiplying by 1
 * -false && op, true || op, other functions with a guaranteed result.
 * -If expression with a constant condition, for example (if (true) (3)) would become 3.
 * 
 * Simple
 * -Evaluating built-in functions on constants, for example (+ 2 3) would be replaced with 5.
 * -Make small powers into repeated multiplications
 * 
 * Moderate
 * -Pull function calls out of loops.
 * 
 * Advanced 
 * -Convert tail-recursive calls to loops.
 * -Find and prevent/warn against infinite loops.
 * 
 */


#define OTHER_NUMERIC(assume_p, type) ((assume_p) && ((type) == VALUE_VAR || (type) == VALUE_BLK))

value value_optimize(value op, int flags)
{
	value res = value_set(op);
	value error = value_optimize_now(&res, flags);
	if (error.type == VALUE_ERROR) {
		value_clear(&res);
		return error;
	}
	return res;
}

value value_optimize_std(value op, value flags)
{
	int iflags = 0;
	if (flags.type == VALUE_SYM) {
		if (streq(flags.core.u_s, "assume_numeric"))
			iflags |= O_ASSUME_NUMERIC;
	} else if (flags.type == VALUE_ARY) {
		size_t i;
		for (i = 0; i < flags.core.u_a.length; ++i) {
			if (flags.core.u_a.a[i].type != VALUE_SYM) {
				value_error(1, "Type Error: In optimize(), undefined flag %ts (symbol expected).", flags.core.u_a.a[i]);
				return value_init_error();
			} else if (streq(flags.core.u_a.a[i].core.u_s, "assume_numeric"))
				iflags |= O_ASSUME_NUMERIC;
			else if (streq(flags.core.u_a.a[i].core.u_s, "o1"))
				iflags |= O_1;
			else if (streq(flags.core.u_a.a[i].core.u_s, "o2"))
				iflags |= O_2;
			else if (streq(flags.core.u_a.a[i].core.u_s, "o3"))
				iflags |= O_3;
			else if (streq(flags.core.u_a.a[i].core.u_s, "o4"))
				iflags |= O_4;
		}
	}
	
	return value_optimize(op, iflags);
}

/* 
 * Performs an optimization.
 * 
 * Flags
 * 
 * O_ASSUME_NUMERIC_P: Assume that all blocks contain a numeric value. If this is guaranteed 
 * to be true, more optimizations are possible. If you say that it's true and it's not, there 
 * will be incorrect optimizations.
 */
value value_optimize_now(value *op, int flags)
{
	value res = value_init_nil();
	
	if (flags & O_1) {
		res = value_optimize1_now(op, flags);
		return_if_error(res);
	}
	if (flags & O_2) {
		res = value_optimize2_now(op, flags);
		return_if_error(res);
	}
	if (flags & O_3) {
		res = value_optimize3_now(op, flags);
		return_if_error(res);
	}
	if (flags & O_4) {
		res = value_optimize4_now(op, flags);
		return_if_error(res);
	}
	
	return res;
}

/* 
 * Performs a level 1 optimization. This does trivial optimizations.
 */
value value_optimize1_now(value *op, int flags)
{
	if (op->type != VALUE_BLK)
		return value_init_nil();
	
	value res = value_init_nil();
	
	value *words = op->core.u_blk.a;
	size_t i, length = op->core.u_blk.length;
	
	int assume_numeric = flags && O_ASSUME_NUMERIC;
	
	// Recursively optimize all inner blocks.
	for (i = 0; i < length; ++i) {
		if (words[i].type == VALUE_BLK) {
			res = value_optimize1_now(&words[i], flags);
			if (res.type == VALUE_ERROR)
				return res;
		}
	}
	
	/* Remove rundant nested blocks, for example turn (1) into 1.
	 */
	if (length == 1 && words[0].type != VALUE_BIF && words[0].type != VALUE_UDF && words[0].type != VALUE_UDF_SHELL) {
		value saved = words[0];
		words[0].type = VALUE_NIL;
		value_clear(op);
		*op = saved;
	}
	
	/* An additon of zero can be removed.
	 */
	else if (length == 3 && words[0].type == VALUE_BIF && (words[0].core.u_bif->f == &value_add_arg || words[0].core.u_bif->f == &value_sub_arg)) {
		if (	// 0 - x cannot be optimized, only x - 0.
				words[0].core.u_bif->f != &value_sub_arg && 
				
				// If words[2] is a float, words[1] can be an integer or a float.
				((words[2].type == VALUE_MPF && value_eq(words[1], value_zero)) || 
				
				// If words[2] is an integer, words[1] has to be an integer, otherwise this optimization will change the result of the function.
				((words[2].type == VALUE_MPZ || OTHER_NUMERIC(assume_numeric, words[2].type)) && words[1].type == VALUE_MPZ && value_eq(words[1], value_zero)))) {
			
			value saved = words[2];
			words[2].type = VALUE_NIL;
			value_clear(op);
			*op = saved;
		} else if (	// If words[1] is a float, words[2] can be an integer or a float.
				((words[1].type == VALUE_MPF && value_eq(words[2], value_zero)) || 
				
				// If words[1] is an integer, words[2] has to be an integer, otherwise this optimization will change the result of the function.
				((words[1].type == VALUE_MPZ || OTHER_NUMERIC(assume_numeric, words[1].type)) && words[2].type == VALUE_MPZ && value_eq(words[2], value_zero)))) {
			
			value saved = words[1];
			words[1].type = VALUE_NIL;
			value_clear(op);
			*op = saved;
		}		
	}
		
	/* A multiplication by 1 can be removed.
	 */
	else if (length == 3 && words[0].type == VALUE_BIF && (words[0].core.u_bif->f == &value_mul_arg || words[0].core.u_bif->f == &value_div_arg)) {
		if (	// 1 / x cannot be optimized, only x / 1.
				words[0].core.u_bif->f != &value_div_arg && 
				
				// If words[2] is a float, words[1] can be an integer or a float.
				((words[2].type == VALUE_MPF && value_eq(words[1], value_one)) || 
				
				// If words[2] is an integer, words[1] has to be an integer, otherwise this optimization will change the result of the function.
				((words[2].type == VALUE_MPZ || OTHER_NUMERIC(assume_numeric, words[2].type)) && words[1].type == VALUE_MPZ && value_eq(words[1], value_one)))) {
			
			value saved = words[2];
			words[2].type = VALUE_NIL;
			value_clear(op);
			*op = saved;
		} else if (	// If words[1] is a float, words[2] can be an integer or a float.
				((words[1].type == VALUE_MPF && value_eq(words[2], value_one)) || 
				
				// If words[1] is an integer, words[2] has to be an integer, otherwise this optimization will change the result of the function.
				((words[1].type == VALUE_MPZ || OTHER_NUMERIC(assume_numeric, words[1].type)) && words[2].type == VALUE_MPZ && value_eq(words[2], value_one)))) {
			
			value saved = words[1];
			words[1].type = VALUE_NIL;
			value_clear(op);
			*op = saved;
		}
		
		/* A multiplication by 0 can become just 0.
		 */
		else if ( // 0 / x cannot be optimized because x might be 0.
				words[0].core.u_bif->f != &value_div_arg && 
				((words[2].type == VALUE_MPF && value_eq(words[1], value_zero)) || 
				((words[2].type == VALUE_MPZ || OTHER_NUMERIC(assume_numeric, words[2].type)) && words[1].type == VALUE_MPZ && value_eq(words[1], value_zero)))) {
			
			value saved = words[1];
			words[1].type = VALUE_NIL;
			value_clear(op);
			*op = saved;
		} else if ( // x / 0 cannot be optimized because it is undefined.
				words[0].core.u_bif->f != &value_div_arg && 
				((words[1].type == VALUE_MPF && value_eq(words[2], value_zero)) || 
				((words[1].type == VALUE_MPZ || OTHER_NUMERIC(assume_numeric, words[1].type)) && words[2].type == VALUE_MPZ && value_eq(words[2], value_zero)))) {
			
			value saved = words[2];
			words[2].type = VALUE_NIL;
			value_clear(op);
			*op = saved;
		}
	}
		
	/* To the 1 power can be removed.
	 */
	else if (length == 3 && words[0].type == VALUE_BIF && words[0].core.u_bif->f == &value_pow_arg && 
			((words[1].type == VALUE_MPF && value_eq(words[2], value_one)) || 
			
			// If words[1] is an integer, words[2] has to be an integer, otherwise this optimization will change the result of the function.
			((words[1].type == VALUE_MPZ || OTHER_NUMERIC(assume_numeric, words[1].type)) && words[2].type == VALUE_MPZ && value_eq(words[2], value_one)))) {
		
		value saved = words[1];
		words[1].type = VALUE_NIL;
		value_clear(op);
		*op = saved;
	}
	
	/* The negative of a negative can be turned into a positive.
	 */
	else if (assume_numeric && length == 2 && words[0].type == VALUE_BIF && words[0].core.u_bif->f == &value_uminus_arg && 
			words[1].type == VALUE_BLK && words[1].core.u_blk.length == 2 && words[1].core.u_blk.a[0].type == VALUE_BIF && 
			words[1].core.u_blk.a[0].core.u_bif->f == &value_uminus_arg) {
		
		// Remove the two outermost blocks.
		value saved = words[1].core.u_blk.a[1];
		words[1].core.u_blk.a[1].type = VALUE_NIL;
		value_clear(op);
		*op = saved;
	}
			
	return res;
	
}

value value_optimize2_now(value *op, int flags)
{
	if (op->type != VALUE_BLK)
		return value_init_nil();
	
	value res = value_init_nil();
	
	value *words = op->core.u_blk.a;
	size_t i, length = op->core.u_blk.length;
	
	int assume_numeric = flags & O_ASSUME_NUMERIC;
	
	// Recursively optimize all inner blocks.
	for (i = 0; i < length; ++i) {
		if (words[i].type == VALUE_BLK) {
			res = value_optimize2_now(&words[i], flags);
			if (res.type == VALUE_ERROR)
				return res;
		}
	}
		
	if (length > 1 && words[0].type == VALUE_BIF) {
		
		/* If the block is made up entirely of constants, evaluate it.
		 */
		int all_constants_p = TRUE;
		for (i = 1; i < length; ++i) {
			all_constants_p &= words[i].type == VALUE_NIL || words[i].type == VALUE_BOO || words[i].type == VALUE_MPZ || words[i].type == VALUE_MPF;
			if (all_constants_p == FALSE)
				break;
		}
		
		if (all_constants_p) {
			// The variables don't actually matter because there aren't any inside of the block. 
			value saved = eval(&value_nil, *op);
			value_printf("clearing %ts\n", *op);
			value_printf("putting in %ts\n", saved);
			value_clear(op);
			*op = saved;
		}
		
		optimize_put_constants_first(op, words, length, assume_numeric);
		optimize_simplify_constant_across_block(op, words, length, assume_numeric);
		
	}
	
	
	return res;
}

/* 
 * It's simpler if a compound expression like (* (+ x 3) 4) puts the constant first, such as 
 * (* 4 (+ 3 x)). This simplifies the number of cases that other optimizations have to deal 
 * with, and is also easier for people to read.
 */
int optimize_put_constants_first(value *op, value words[], size_t length, int assume_numeric)
{
	if (assume_numeric && length == 3) {
		if (value_commutative_p(words[0]) && !(words[1].type == VALUE_MPZ || words[1].type == VALUE_MPF) && 
				(words[2].type == VALUE_MPZ || words[2].type == VALUE_MPF)) {
			value temp = words[1];
			words[1] = words[2];
			words[2] = temp;
		}
	}
	
	return 0;
}

/* 
 * Simplify (* 10 (* 3 x)) to (* 30 x), and such things.
 * 
 * Assumes that optimize_put_constants_first() has already been called. If it hasn't, the result 
 * will not be fully optimized.
 */
int optimize_simplify_constant_across_block(value *op, value words[], size_t length, int assume_numeric)
{
	if (assume_numeric && length == 3 && value_commutative_p(words[0])) {
		// if words[2] is a block containing three elements: the same function as words[0], 
		// a number, and something else
		if (words[2].type == VALUE_BLK && words[2].core.u_blk.length == 3 && words[2].core.u_blk.a[1].type == VALUE_MPZ &&
				words[2].core.u_blk.a[0].type == VALUE_BIF && 
				words[2].core.u_blk.a[0].core.u_bif->f == words[0].core.u_bif->f) {
			if (words[1].type == VALUE_MPZ) {
				// Perform the operation on the number in words[2] by words[1].
				value argv[] = { words[1], words[2].core.u_blk.a[1] };
				value simplified_number = value_bifcall(words[0], 2, argv);
				value_clear(&words[2].core.u_blk.a[1]);
				words[2].core.u_blk.a[1] = simplified_number;
				
				// Clear the outer block containing words[1] and words[2].
				value saved_block = words[2];
				words[2].type = VALUE_NIL;
				value_clear(op);
				*op = saved_block;
					
			} else if (words[1].type == VALUE_BLK && words[1].core.u_blk.length == 3 && words[1].core.u_blk.a[1].type == VALUE_MPZ &&
					words[1].core.u_blk.a[0].type == VALUE_BIF && 
					words[1].core.u_blk.a[0].core.u_bif->f == words[0].core.u_bif->f) {
				// Two blocks have been found, such as (3 * x) * (5 * x). Simplify to (15 * x) * x
				
				// Perform the operation on the number in words[1] by the number in words[2].
				value argv[] = { words[1].core.u_blk.a[1], words[2].core.u_blk.a[1] };
				value simplified_number = value_bifcall(words[0], 2, argv);
				value_clear(&words[1].core.u_blk.a[1]);
				words[1].core.u_blk.a[1] = simplified_number;
				
				// Replace words[2] with just the non-number part of words[2].
				value saved_part = words[2].core.u_blk.a[2];
				words[2].core.u_blk.a[2].type = VALUE_NIL;
				value_clear(&words[2]);
				words[2] = saved_part;
			}
		}
	}
	
	return 0;
}

value value_optimize3_now(value *op, int flags)
{
	value_error(1, "Implementation Error: optimize3!() not yet implemented.");
	return value_init_error();
}

value value_optimize4_now(value *op, int flags)
{
	value_error(1, "Implementation Error: optimize3!() not yet implemented.");
	return value_init_error();
}


value value_optimize_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "optimize()") ? value_init_error() : value_optimize_std(argv[0], argv[1]);
}

/* 
   A C-program for MT19937, with initialization improved 2002/1/26.
   Coded by Takuji Nishimura and Makoto Matsumoto.

   Before using, initialize the state by using init_genrand(seed)  
   or init_by_array(init_key, key_length).

   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
   All rights reserved.                          

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.

     3. The names of its contributors may not be used to endorse or promote 
        products derived from this software without specific prior written 
        permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


   Any feedback is very welcome.
   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html
   email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)
*/

#include "random.h"

static unsigned long mt[N]; /* the array for the state vector  */
static int mti=N+1; /* mti==N+1 means mt[N] is not initialized */

/* initializes mt[N] with a seed */
void init_genrand(unsigned long s)
{
    mt[0]= s & 0xffffffffUL;
    for (mti=1; mti<N; mti++) {
        mt[mti] = 
	    (1812433253UL * (mt[mti-1] ^ (mt[mti-1] >> 30)) + mti); 
        /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
        /* In the previous versions, MSBs of the seed affect   */
        /* only MSBs of the array mt[].                        */
        /* 2002/01/09 modified by Makoto Matsumoto             */
        mt[mti] &= 0xffffffffUL;
        /* for >32 bit machines */
    }
}

/* initialize by an array with array-length */
/* init_key is the array for initializing keys */
/* key_length is its length */
/* slight change for C++, 2004/2/26 */
void init_by_array(unsigned long init_key[], int key_length)
{
    int i, j, k;
    init_genrand(19650218UL);
    i=1; j=0;
    k = (N>key_length ? N : key_length);
    for (; k; k--) {
        mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1664525UL))
          + init_key[j] + j; /* non linear */
        mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
        i++; j++;
        if (i>=N) { mt[0] = mt[N-1]; i=1; }
        if (j>=key_length) j=0;
    }
    for (k=N-1; k; k--) {
        mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1566083941UL))
          - i; /* non linear */
        mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
        i++;
        if (i>=N) { mt[0] = mt[N-1]; i=1; }
    }

    mt[0] = 0x80000000UL; /* MSB is 1; assuring non-zero initial array */ 
}

/* generates a random number on [0,0xffffffff]-interval */
unsigned long genrand_int32(void)
{
    unsigned long y;
    static unsigned long mag01[2]={0x0UL, MATRIX_A};
    /* mag01[x] = x * MATRIX_A  for x=0,1 */

    if (mti >= N) { /* generate N words at one time */
        int kk;

        if (mti == N+1)   /* if init_genrand() has not been called, */
            init_genrand(5489UL); /* a default initial seed is used */

        for (kk=0;kk<N-M;kk++) {
            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
            mt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1UL];
        }
        for (;kk<N-1;kk++) {
            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
            mt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1UL];
        }
        y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);
        mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1UL];

        mti = 0;
    }
  
    y = mt[mti++];

    /* Tempering */
    y ^= (y >> 11);
    y ^= (y << 7) & 0x9d2c5680UL;
    y ^= (y << 15) & 0xefc60000UL;
    y ^= (y >> 18);

    return y;
}

/* generates a random number on [0,0x7fffffff]-interval */
long genrand_int31(void)
{
    return (long)(genrand_int32()>>1);
}

/* generates a random number on [0,1]-real-interval */
double genrand_real1(void)
{
    return genrand_int32()*(1.0/4294967295.0); 
    /* divided by 2^32-1 */ 
}

/* generates a random number on [0,1)-real-interval */
double genrand_real2(void)
{
    return genrand_int32()*(1.0/4294967296.0); 
    /* divided by 2^32 */
}

/* generates a random number on (0,1)-real-interval */
double genrand_real3(void)
{
    return (((double)genrand_int32()) + 0.5)*(1.0/4294967296.0); 
    /* divided by 2^32 */
}

/* generates a random number on [0,1) with 53-bit resolution*/
double genrand_res53(void) 
{ 
    unsigned long a=genrand_int32()>>5, b=genrand_int32()>>6; 
    return(a*67108864.0+b)*(1.0/9007199254740992.0); 
} 
/* These real versions are due to Isaku Wada, 2002/01/09 added */




/* 
 * See random.c for documentation.
 */

/* Period parameters */
#define N 624
#define M 397
#define MATRIX_A 0x9908b0dfUL   /* constant vector a */
#define UPPER_MASK 0x80000000UL /* most significant w-r bits */
#define LOWER_MASK 0x7fffffffUL /* least significant r bits */

void init_genrand(unsigned long s);
void init_by_array(unsigned long init_key[], int key_length);
unsigned long genrand_int32(void);
long genrand_int31(void);
double genrand_real1(void);
double genrand_real2(void);
double genrand_real3(void);
double genrand_res53(void);
/*
 *  sexp_to_c.c
 *  Simfpl
 *
 *  Created by Michael Dickens on 8/22/10.
 *
 */

#include "sexp_to_c.h"

int init_sexp_to_c()
{
	return 0;
}

value create_associated_numbers(value sexp)
{
	return create_associated_numbers_recursive(sexp, value_zero);
}

value create_associated_numbers_recursive(value sexp, value start)
{
	if (sexp.type != VALUE_BLK) {
		return value_inc(start);
	}
	
	value associated = value_init(VALUE_BLK);
	size_t i;
	for (i = 0; i < sexp.core.u_blk.length; ++i) {
		value num = create_associated_numbers_recursive(sexp.core.u_blk.a[i], start);
		value_inc_now(&start);
		value_append_now2(&associated, &num);
	}
	
	return associated;
}

value get_count(value counts)
{
	if (counts.type == VALUE_MPZ) {
		return counts;
	}
	
	return get_count(counts.core.u_blk.a[0]);
}

int sexp_to_c(FILE *stream, value sexp)
{
	value counts = create_associated_numbers(sexp);
	
	int res = sexp_to_c_recursive(stream, sexp, counts);
	value_clear(&counts);
	return res;
}

/* 
 * Convert the given s-expression into C code.
 */
int sexp_to_c_recursive(FILE *stream, value sexp, value counts)
{
	if (sexp.type == VALUE_MPZ || sexp.type == VALUE_MPF) {
		value_fprintf(stream, "var%v = value_set_str_smart(\"%v\", 0);\n", counts, sexp);
	}
	
	if (sexp.type != VALUE_BLK) {
		return 0;
//		value_error(1, "Type Error: sexp_to_c() is undefined where sexp is %ts (block expected).", sexp);
//		return VALUE_ERROR;
	}
	
	int error_p = 0;
	
	size_t i;
	for (i = 0; i < sexp.core.u_blk.length; ++i) {
		if (sexp.core.u_blk.a[i].type == VALUE_BIF && sexp.core.u_blk.a[i].core.u_bif->spec.delay_eval_p)
			;
		else if (error_p = sexp_to_c_recursive(stream, sexp.core.u_blk.a[i], counts.core.u_blk.a[i]))
			return error_p;
	}
	
	char *name;
	
	if (sexp.core.u_blk.length > 0 && sexp.core.u_blk.a[0].type == VALUE_BIF) {
		value (*f)(int argc, value argv[]) = sexp.core.u_blk.a[0].core.u_bif->f;
		int type = 0;
		if (f == &value_add_arg) {
			name = "value_add";
		} else if (f == &value_sub_arg) {
			name = "value_sub";
		} else if (f == &value_mul_arg) {
			name = "value_mul";
		} else if (f == &value_div_arg) {
			name = "value_div";
		} else if (f == &value_eq_arg) {
			name = "value_eq";
		} else if (f == &value_if_arg) {
			type = S2C_IF;
		} else if (f == &value_times_arg) {
			type = S2C_TIMES;
		} else {
			name = "UNDEFINED_FUNCTION";
		}

		if (type == 0) {
			value str = value_set_str(name);
			value_fprintf(stream, "var%v = %v(var%v, var%v);\n", get_count(counts), str, get_count(counts.core.u_blk.a[1]), get_count(counts.core.u_blk.a[2]));
			value_clear(&str);
		} else if (type == S2C_IF) {
			// Do some different stuff.
			
		} else if (type == S2C_TIMES) {
			value iter;
			for (iter = value_set_long(0); value_lt(iter, sexp.core.u_blk.a[1]); value_inc_now(&iter)) {
				sexp_to_c_recursive(stream, sexp.core.u_blk.a[2], counts.core.u_blk.a[2]);
			}
		}
	}
	
	return 0;
}

int run_me()
{

return 0;
}/*
 *  sexp_to_c.h
 *  Simfpl
 *
 *  Created by Michael Dickens on 8/22/10.
 *
 */

#include "tests.h"

#define S2C_IF 1
#define S2C_TIMES 2

int init_sexp_to_c();

value create_associated_numbers(value sexp);
value create_associated_numbers_recursive(value sexp, value start);
value get_count(value counts);

int sexp_to_c(FILE *stream, value sexp);
int sexp_to_c_recursive(FILE *stream, value sexp, value counts);

/*
 *  sort.c
 *  Calculator
 *
 *  Created by Michael Dickens on 8/1/10.
 *  Copyright 2010 The Khabele School. All rights reserved.
 *
 */

#include "sort.h"

int bubble_sort(int array[], int length)
{
	int i, n = length;
	do {
		int newn = 0;
		for (i = 0; i < n-1; ++i) {
			if (array[i] > array[i+1]) {
				int temp = array[i];
				array[i] = array[i+1];
				array[i+1] = temp;
				newn = i + 1;
			}
		}
		
		n = newn;
	} while (n > 1);
	
	return 0;
}

int insertion_sort1(int array[], int length)
{
	int i;
	for (i = 0; i < length-1; ) {
		if (array[i] > array[i+1]) {
			int temp = array[i];
			array[i] = array[i+1];
			array[i+1] = temp;
			if (i > 0) --i;
			else ++i;
		} else ++i;
	}
	
	return 0;
}

int insertion_sort2(int array[], int length)
{
	int i, j;
	for (i = 1; i < length; ++i) {
		int temp = array[i];
		j = i - 1;
		while (j >= 0 && array[j] > temp) {
			array[j+1] = array[j--];
		}
		
		array[j+1] = temp;
	}
	
	return 0;
}

int merge_sort(int array[], int length)
{
	merge_sort_run(array, length);
	return 0;
}

void merge_sort_run(int array[], int length)
{
	if (length > 1) {
		int half = length >> 1, blen;
		
		int a[half];
		int b[blen = length - half];
		int i, j;
		for (i = 0; i < half; ++i)
			a[i] = array[i];
		for (j = 0; i < length; ++i, ++j)
			b[j] = array[i];
		
		merge_sort_run(a, half);
		merge_sort_run(b, blen);
				
		i = j = 0;
        while(i < half && j < blen) {
            if (a[i] < b[j]) {
                array[i + j] = a[i++];
            } else {
                array[i + j] = b[j++];
            }
        }
        for(; i < half; ++i) array[i + j] = a[i];
        for(; j < blen; ++j) array[i + j] = b[j];
	}
}

int vmerge_sort(value array[], int length)
{
	if (length > 1) {
		int half = length >> 1, blen;
		
		value a[half];
		value b[blen = length - half];
		int i, j;
		for (i = 0; i < half; ++i)
			a[i] = array[i];
		for (j = 0; i < length; ++i, ++j)
			b[j] = array[i];
		
		if (vmerge_sort(a, half) == VALUE_ERROR)
			return VALUE_ERROR;
		if (vmerge_sort(b, blen) == VALUE_ERROR)
			return VALUE_ERROR;
				
		i = j = 0;
		int cmp;
        while(i < half && j < blen) {
            if ((cmp = value_cmp_any(a[i], b[j])) == -1) {
                array[i + j] = a[i++];
			} else if (cmp == -2) {
				return VALUE_ERROR;
            } else {
                array[i + j] = b[j++];
            }
        }
        for(; i < half; ++i) array[i + j] = a[i];
        for(; j < blen; ++j) array[i + j] = b[j];
	}
	
	return 0;
}

int quicksort1(int array[], int length)
{
	quicksort1_run(array, 0, length-1);
	return 0;
}

void quicksort1_run(int array[], int left, int right)
{
	int pivot_index = (left + right) / 2;
	int pivot_val = array[pivot_index];
	array[pivot_index] = array[right];
	array[right] = pivot_val;
	
	int store_index = left;
	int i;
	for (i = left; i < right; ++i) {
		if (array[i] <= pivot_val) {
			int temp = array[i];
			array[i] = array[store_index];
			array[store_index] = temp;
			++store_index;
		}
	}
	
	int temp = array[store_index];
	array[store_index] = array[right];
	array[right] = temp;
	
	if (left < store_index - 1)
		quicksort1_run(array, left, store_index - 1);
	if (store_index + 1 < right)
		quicksort1_run(array, store_index + 1, right);
}


int quicksort2(int array[], int length)
{
	quicksort2_run(array, 0, length-1);
	return 0;
}

void quicksort2_run(int array[], int left, int right)
{
	int i = left;
	int j = right;
	int pivot = array[(left+right)/2];
	
	do {
		while (array[i] < pivot) ++i;
		while (array[j] > pivot) --j;
		if (i <= j) {
			int temp = array[i];
			array[i] = array[j];
			array[j] = temp;
			++i; --j;
		}
		
	} while (i <= j);
	
	if (left < j) quicksort2_run(array, left, j);
	if (i < right) quicksort2_run(array, i, right);
}


int custom_sort1(int array[], int length)
{
	custom_sort1_run(array, 0, length-1);
	return 0;
}

void custom_sort1_run(int array[], int left, int right)
{
	if (right - left > 10) {
		int i = left;
		int j = right;
		int pivot = array[(left+right)/2];
		
		do {
			while (array[i] < pivot) ++i;
			while (array[j] > pivot) --j;
			if (i <= j) {
				int temp = array[i];
				array[i] = array[j];
				array[j] = temp;
				++i; --j;
			}
			
		} while (i <= j);
		
		if (left < j) custom_sort1_run(array, left, j);
		if (i < right) custom_sort1_run(array, i, right);
	} else {
		int i, j;
		for (i = left; i <= right; ++i) {
			int temp = array[i];
			j = i - 1;
			while (j >= 0 && array[j] > temp) {
				array[j+1] = array[j--];
			}
			
			array[j+1] = temp;
		}
	}

}


/* 

fastest for...

   4: insertion2
   8: insertion2
  16: insertion2/quicksort2`
  32: quicksort2/custom1
  64: custom1
 128: custom1
 256: custom1
 512: custom1
1024: custom1
2048:
4096:
8192:
16394:
32768:
65536:

fastest custom cutoffs (of 8, 16, 24) for...

 128: 24/16
 256: 24/16
 512: 24


position of custom1

   4: insertion1
   8: insertion2
  16: bubble
  32: merge
  64: insertion2
 128: quicksort2
 256:
 512:
1024:
2048:
4096:
8192:
16394:
32768:
65536:



   4:
   8:
  16:
  32:
  64:
 128:
 256:
 512:
1024:
2048:
4096:
8192:
16394:
32768:
65536:

 */
int custom_sort2(int array[], int length, int cutoff)
{
	custom_sort2_run(array, 0, length-1, cutoff);
	return 0;
}

void custom_sort2_run(int array[], int left, int right, int cutoff)
{
	if (right - left > cutoff) {
		int i = left;
		int j = right;
		int pivot = array[(left+right)/2];
		
		do {
			while (array[i] < pivot) ++i;
			while (array[j] > pivot) --j;
			if (i <= j) {
				int temp = array[i];
				array[i] = array[j];
				array[j] = temp;
				++i; --j;
			}
			
		} while (i <= j);
		
		if (left < j) custom_sort2_run(array, left, j, cutoff);
		if (i < right) custom_sort2_run(array, i, right, cutoff);
	} else {
		int i, j;
		for (i = left; i <= right; ++i) {
			int temp = array[i];
			j = i - 1;
			while (j >= 0 && array[j] > temp) {
				array[j+1] = array[j--];
			}
			
			array[j+1] = temp;
		}
	}

}


int vcustom_sort2(value array[], int length, int cutoff)
{
	vcustom_sort2_run(array, 0, length-1, cutoff);
	return 0;
}

int vcustom_sort2_run(value array[], int left, int right, int cutoff)
{
	if (right - left > cutoff) {
		int i = left;
		int j = right;
		int cmp;
		
		// The pivot's index is selected randomly between the two spots 
		// closest to the center, to decrease the probability of O(n^2) 
		// runtime.
		value pivot = array[(left+right)/2 + (genrand_int31() & 1)];
		
		do {
			while ((cmp = value_cmp_any(array[i], pivot)) == -1) ++i;
			if (cmp == -2) return VALUE_ERROR;
			while ((cmp = value_cmp_any(array[j], pivot)) > 0) --j;
			if (cmp == -2) return VALUE_ERROR;
			if (i <= j) {
				value temp = array[i];
				array[i] = array[j];
				array[j] = temp;
				++i; --j;
			}
			
		} while (i <= j);
		
		if (left < j) 
			if (vcustom_sort2_run(array, left, j, cutoff) == VALUE_ERROR)
				return VALUE_ERROR;
		if (i < right) 
			if (vcustom_sort2_run(array, i, right, cutoff) == VALUE_ERROR)
				return VALUE_ERROR;

	} else {
		int i, j, cmp;
		for (i = left; i <= right; ++i) {
			value temp = array[i];
			j = i - 1;
			while (j >= 0 && (cmp = value_cmp_any(array[j], temp)) > 0) {
				array[j+1] = array[j--];
			}
			if (cmp == -2) return VALUE_ERROR;
			
			array[j+1] = temp;
		}
	}
	
	return 0;
}





int fill_array(int array[], int length)
{
	srand(time(NULL));
	
	int i;
	for (i = 0; i < length; ++i)
		array[i] = rand() % 1000;
	
	return 0;
}

int vfill_array(value array[], int length)
{
	srand(time(NULL));
	
	value max_num = value_set_long(1000);
	int i;
	for (i = 0; i < length; ++i)
		array[i] = value_rand(max_num);
	value_clear(&max_num);
	
	return 0;
}

/* 
 * Because there's a significant overhead in creating new values, 
 * this is faster than vfill_array().
 */
int vshuffle_array(value array[], int length)
{
	int i, k;
	value temp;
	for (i = length - 1; i > 0; --i) {
		k = (int) (genrand_real2() * i);
		temp = array[k];
		array[k] = array[i];
		array[i] = temp;
	}
	
	return 0;
}

int sorted_p(int array[], int length)
{
	int i;
	for (i = 0; i < length-1; ++i)
		if (array[i] > array[i+1])
			return 0;
	return 1;
}

int sort_test()
{
	int i;
	
	int length = 100;
	int array[length];
	fill_array(array, length);
	
	custom_sort1(array, length);
	printf("%d\n", sorted_p(array, length));
	for (i = 0; i < length; ++i)
		printf("%d ", array[i]);
	printf("\n");
	
	return 0;
}/*
 *  sort.h
 *  Simfpl
 *
 *  Created by Michael Dickens on 8/1/10.
 *  
 *  Contains a number of sorting algorithms that sort arrays of integers. 
 *  Designed to test sorting speeds at different sizes in order to optimize 
 *  the built-in sorting function.
 *
 */

#include "interpreter.h"

/* 
 * Worst O(n^2), Average O(n^2), Memory 1
 * 
 * Optimized implementation, from http://en.wikipedia.org/wiki/Bubble_sort#Optimizing_bubble_sort
 */
int bubble_sort(int array[], int length);

/* 
 * I designed this sorting algorithm. As far as I know it has the shortest 
 * source code of any sorting algorithm. It appears to be a version of 
 * insertion sort.
 * 
 * Worst O(n^2), Average O(n^2), Best O(n), Memory 1
 */
int insertion_sort1(int array[], int length);

/* 
 * Worst O(n^2), Average O(n^2), Memory 1
 */
int insertion_sort2(int array[], int length);

/* 
 * Worst O(n log n), Average O(n log n), Memory n
 */
int merge_sort(int array[], int length);
void merge_sort_run(int array[], int length);

int vmerge_sort(value array[], int length);

/* 
 * Worst O(n^2), Average O(n log n), Memory log n
 * 
 * Uses the implementation found on Wikipedia.
 */
int quicksort1(int array[], int length);
void quicksort1_run(int array[], int left, int right);

/* 
 * Uses the implementation from an old Java program I wrote, pulled from 
 * somewhere else but I don't know where.
 */
int quicksort2(int array[], int length);
void quicksort2_run(int array[], int left, int right);

/* 
 * Uses quicksort for larger arrays and insertion2 for smaller ones.
 */
int custom_sort1(int array[], int length);
void custom_sort1_run(int array[], int left, int right);

#define vcustom_sort1(array, length) vcustom_sort2(array, length, 16)

int custom_sort2(int array[], int length, int cutoff);
void custom_sort2_run(int array[], int left, int right, int cutoff);

int vcustom_sort2(value array[], int length, int cutoff);
int vcustom_sort2_run(value array[], int left, int right, int cutoff);

int fill_array(int array[], int length);
int vfill_array(value array[], int length);
int vshuffle_array(value array[], int length);
int sorted_p(int array[], int length);
int sort_test();

/*
 *  tests.c
 *  Calculator
 *
 *  Created by Michael Dickens on 7/6/10.
 *  Copyright 2010 The Khabele School. All rights reserved.
 *
 */

#include "tests.h"

int init_tests()
{
	test_vars = value_hash_init();
	return 0;
}

time_t usec()
{
	struct timeval tv;
	gettimeofday(&tv, NULL);
	return tv.tv_usec + 1000000 * (size_t) tv.tv_sec;
}

/* 
 * Each test requires that the previous test passed because it relies on 
 * certain utilities that are tested in previous tests.
 */
int run_tests()
{
	if (test_inputs()) {
		printf("Test suite aborted.\n\n");
		return 1;
	}
	if (test_to_prefix()) {
		printf("Test suite aborted.\n\n");
		return 1;
	}
	if (test_errors()) {
		printf("Test suite aborted.\n\n");
		return 1;
	}
	if (test_numbers()) {
		printf("Test suite aborted.\n\n");
		return 1;
	}
	if (test_strings()) {
		printf("Test suite aborted.\n\n");
		return 1;
	}
	if (test_arrays()) {
		printf("Test suite aborted.\n\n");
		return 1;
	}
	if (test_lists()) {
		printf("Test suite aborted.\n\n");
		return 1;
	}
	
	printf("Test suite succeeeded.\n\n");
	
	return 0;
}

int run_benchmarks()
{
	import_benchmark("benchmarks/array benchmark 1.simf");
	import_benchmark("benchmarks/hash benchmark 1.simf");
	import_benchmark("benchmarks/long benchmark 1.simf");
	import_benchmark("benchmarks/long benchmark 2.simf");
	import_benchmark("benchmarks/loop benchmark 1.simf");
	import_benchmark("benchmarks/math benchmark 1.simf");
	import_benchmark("benchmarks/math benchmark 2.simf");
	import_benchmark("benchmarks/misc benchmark 1.simf");
	import_benchmark("benchmarks/recursion benchmark 1.simf");
	import_benchmark("benchmarks/sort benchmark 1.simf");
	import_benchmark("benchmarks/sort benchmark 2.simf");
	
//	import_benchmark("benchmarks/math benchmark 3.simf"); // buggy

	return 0;
}


int import_benchmark(char *name)
{
	printf("\n*****\n*****\n*****\n\nRunning benchmark \"%s\".\n\n", name);
	
	value benchmark = value_set_str(name);
	value res = value_import(benchmark);
	
	value_printf("\nBenchmark returned %ts.\n\n", res);
	printf("*****\n*****\n*****\n\n");
	
	return 0;
}

/* This has a lot of memory leakage, but that's okay because it will 
 * probably only be called once. Memory leakage is necessary because if 
 * the values were cleared then the timings would be skewed.
 */
int set_benchmark1()
{
	time_t start, finish;
	size_t i;
	value op;
	
	start = usec();
	for (i = 0; i < 10000; ++i) {
		op = value_set_long(1828);
		op = value_set(op);
		op = value_set_double(2.43);
		op = value_set(op);
		op = value_set_str("hello there");
		op = value_set(op);
		op = value_init(VALUE_ARY);
		op = value_set(op);
		op = value_init(VALUE_LST);
		op = value_set(op);
		op = value_init(VALUE_BLK);
		op = value_set(op);
	}
	finish = usec();
	printf("time to set: %ld sec, %ld usec\n", (finish - start) / 1000000, (finish - start) % 1000000);
	
	return 0;
}

int test_assert(int p, char *description)
{
	if (!p) {
		value_error(1, "Assertion failed: %c", description);
		return VALUE_ERROR;
	}
	
	return 0;
}

int test_sexp(char *str, value sexp, value expected)
{
	value res = eval(&test_vars, sexp);
	int error_p = 0;
	if (value_ne(res, expected)) {
		value_error(0, "Test failed: for %c \n\t%.60ts expected, %.60ts found.\n", str, expected, res);
		error_p = VALUE_ERROR;
	}

	value_clear(&res);
	value_clear(&expected);
	
	return error_p;
}

int test_string(char *str, value expected)
{
	value sexp = compile_statement(str);
	if (sexp.type == VALUE_ERROR)
		return 0;
	
	int error_p = test_sexp(str, sexp, expected);
	if (error_p == 0) {
//		printf("succeeded: %s\n", str);
	}
	
	return error_p;
}

/* 
 * Test various inputs to make sure that they are read in properly.
 */
int test_inputs()
{
	printf("\n*****\n*****\n*****\n\nTesting inputs.\n\n");
	
	int orig_print_info_p = print_info_p;
	print_info_p = FALSE;
	
	int orig_print_errors_p = print_errors_p;
	print_errors_p = FALSE;
	
	int did_fail = FALSE;
	
	// Nils.
	did_fail |= test_string("", value_init_nil());
	did_fail |= test_string(" ", value_init_nil());
	did_fail |= test_string("()", value_init_nil());
	did_fail |= test_string("(())", value_init_nil());
	did_fail |= test_string(" (()) ", value_init_nil());
	did_fail |= test_string("( ( ) )", value_init_nil());
	did_fail |= test_string("nil", value_init_nil());
	did_fail |= test_string("((nil))", value_init_nil());
	
	// Simple errors.
	did_fail |= test_string("nil nil", value_init_error());
	did_fail |= test_string("nil ()", value_init_error());
	did_fail |= test_string("() nil", value_init_error());
	did_fail |= test_string("() ()", value_init_error());

	// Numbers.
	did_fail |= test_string("3", value_set_long(3));
	did_fail |= test_string("32", value_set_long(32));
	did_fail |= test_string("--3", value_set_long(-3));
	did_fail |= test_string("-- 3", value_set_long(-3));
	did_fail |= test_string("32.1", value_set_double(32.1));
	did_fail |= test_string("-- 3.1", value_set_double(-3.1));
	did_fail |= test_string("032", value_set_long(032));
	did_fail |= test_string("0x3", value_set_long(0x3));
	did_fail |= test_string("0xf", value_set_long(0xf));
	did_fail |= test_string("0x3f", value_set_long(0x3f));
	did_fail |= test_string("0xf3", value_set_long(0xf3));
	
	// Operations.
	did_fail |= test_string("3 * 10", value_set_long(30));
	did_fail |= test_string("3*10", value_set_long(30));
	did_fail |= test_string("3-10", value_set_long(-7));
	did_fail |= test_string("3 - 5*2", value_set_long(-7));
	did_fail |= test_string("3-5 * 2", value_set_long(-7));
	did_fail |= test_string("3 - 4 * 5 / 2", value_set_long(-7));
	
	// Prefix notation.
	did_fail |= test_string("* 3 10", value_set_long(30));
	did_fail |= test_string("+ 1 * 3 10", value_set_long(31));
	did_fail |= test_string("+ * 3 10 1", value_set_long(31));
	did_fail |= test_string("- + * 3 10 5 12", value_set_long(23));
	did_fail |= test_string("- 12 + 5 * 10 3", value_set_long(-23));
	
	// Parentheses.
	did_fail |= test_string("(3)", value_set_long(3));
	did_fail |= test_string("(3 + 2)", value_set_long(5));
	did_fail |= test_string("(3) + 2", value_set_long(5));
	did_fail |= test_string("3 + (2)", value_set_long(5));
	did_fail |= test_string("(3) + (2)", value_set_long(5));
	did_fail |= test_string("((3) + (2))", value_set_long(5));
	did_fail |= test_string("((3))", value_set_long(3));
	did_fail |= test_string("((3 + 2))", value_set_long(5));
	
	
	// Negatives with other operations.
	did_fail |= test_string("5-2", value_set_long(3));
	did_fail |= test_string("5+ --2", value_set_long(3));
	did_fail |= test_string("5+--2", value_init_error()); // It parses +-- as a single function, which is undefined.
	did_fail |= test_string("--2-5", value_set_long(-7));
	did_fail |= test_string("--2 * --3", value_set_long(6));
	did_fail |= test_string("--2* --3", value_set_long(6));
	did_fail |= test_string("--2- --3", value_set_long(1));

	// Numbers in strings.
	did_fail |= test_string("\"3\"", value_set_str("3"));
	did_fail |= test_string("\"-3\"", value_set_str("-3"));
	did_fail |= test_string("\"3.1\"", value_set_str("3.1"));
	did_fail |= test_string("\"-3.1\"", value_set_str("-3.1"));
	did_fail |= test_string("\"03\"", value_set_str("03"));
	did_fail |= test_string("\"0x3\"", value_set_str("0x3"));
	did_fail |= test_string("\"0xf\"", value_set_str("0xf"));
	
	// Array and list inputs.
	long long_arr[] = { 1, 2, 3 };
	did_fail |= test_string("array 1 2 3", value_set_ary_long(long_arr, 3));
	
	// Statements.
	did_fail |= test_string("i = 0; i = i + 1", value_set_long(1));
	did_fail |= test_string("i = 0; i = i + 1; i = 5", value_set_long(5));

	if (did_fail) {
		printf("Test of inputs failed.\n\n");
	} else {
		printf("Test of inputs succeeded.\n\n");
	}
	
	printf("*****\n*****\n*****\n\n");
	
	print_info_p = orig_print_info_p;
	print_errors_p = orig_print_errors_p;
	return did_fail;
}

/* 
 * Tests whether statements are being properly converted to prefix notation.
 * Primarily focuses on ternary operators, because those can be the most confusing and 
 * difficult to deal with.
 */
int test_to_prefix()
{
	printf("\n*****\n*****\n*****\n\nTesting to prefix.\n\n");
	
	int orig_print_info_p = print_info_p;
	print_info_p = FALSE;
	
	int did_fail = FALSE;
	
	did_fail |= test_string("` (3 * 2 + 1 / 5)", compile_statement("+ * 3 2 / 1 5"));
	did_fail |= test_string("` (3 + 2 * 1 - 5)", compile_statement("- + 3 * 2 1 5"));
//	did_fail |= test_string("` (= a[0] b[1])", compile_statement("at_equals a (0) (at b (1))")); // This fails.
	did_fail |= test_string("` (a[0] = b[1])", compile_statement("at_equals a (0) (at b (1))"));
	did_fail |= test_string("` (a 0 at_equals b at 1)", compile_statement("at_equals a 0 (at b 1)"));
	did_fail |= test_string("` ((array 1 2 3) insert 3 4 append 5)", compile_statement("append (insert (array 1 2 3) 3 4) 5"));
	did_fail |= test_string("` ((array 1 2 3) append 4 insert 4 5)", compile_statement("insert (append (array 1 2 3) 4) 4 5"));

	if (did_fail) {
		printf("Test of to prefix failed.\n\n");
	} else {
		printf("Test of to prefix succeeded.\n\n");
	}
	
	printf("*****\n*****\n*****\n\n");
	
	print_info_p = orig_print_info_p;
	return did_fail;
}

/* 
 * Tests most primitives, but only once. Does not check to see how they handle 
 * illegal inputs.
 * 
 * I have added some new functions, so I know that this does not include every 
 * primitive. Also, it only includes functions for numbers, strings and arrays.
 */
int test_primitives()
{
	printf("\n*****\n*****\n*****\n\nTesting primitives.\n\n");
	
	int orig_print_info_p = print_info_p;
	print_info_p = FALSE;
	
	int did_fail = FALSE;

	did_fail |= test_string("3 + 4 * 2 - 5 % 2", value_set_long(10));
	did_fail |= test_string("3 == 4 && 2 < 3", value_set_bool(FALSE));
	did_fail |= test_string("3 != 4 || 2 > 3", value_set_bool(TRUE));
	did_fail |= test_string("! (3 <= 4 && 2 <= 3)", value_set_bool(FALSE));
	did_fail |= test_string("(1 << 10) >> 6", value_set_long(16));
	did_fail |= test_string("15 & 7 & 12", value_set_long(4));
	did_fail |= test_string("7 | 12", value_set_long(15));
	did_fail |= test_string("7 ^ 12", value_set_long(11));
	did_fail |= test_string("~7", value_set_long(-8));
	did_fail |= test_string("2**5", value_set_long(32));
	did_fail |= test_string("4**0.5", value_set_double(2.0));
	did_fail |= test_string("2**(--1)", value_set_double(0.5));
	did_fail |= test_string("exp 2", value_set_double(exp(2)));
	did_fail |= test_string("log 5", value_set_double(log(5)));
	did_fail |= test_string("log10 5", value_set_double(log10(5)));
	did_fail |= test_string("sqrt 25", value_set_double(5.0));
	did_fail |= test_string("8 factorial", value_set_long(40320));
	did_fail |= test_string("sin 2", value_set_double(sin(2)));
	did_fail |= test_string("cos 2", value_set_double(cos(2)));
	did_fail |= test_string("tan 2", value_set_double(tan(2)));
	did_fail |= test_string("csc 2", value_set_double(1.0 / sin(2)));
	did_fail |= test_string("sec 2", value_set_double(1.0 / cos(2)));
	did_fail |= test_string("cot 2", value_set_double(1.0 / tan(2)));
	did_fail |= test_string("asin 0.5", value_set_str_smart("0.5235987755982989266811955531011335551738739013671875", 10)); // This is necessary because of MPFR's precision.
	did_fail |= test_string("acos 0.5", value_set_str_smart("1.047197551196597853362391106202267110347747802734375", 10));
	did_fail |= test_string("atan 0.5", value_set_str_smart("0.463647609000806093515478778499527834355831146240234375", 10));
	did_fail |= test_string("\"heLlO\" capitalize", value_set_str("Hello"));
	did_fail |= test_string("\"hello\" chop", value_set_str("hell"));
	did_fail |= test_string("\"hello\" contains? \"el\"", value_set_bool(TRUE));
	did_fail |= test_string("\"hello\" ends_with? \"llo\"", value_set_bool(TRUE));
	did_fail |= test_string("\"hello\" index \"el\"", value_set_long(1));
	did_fail |= test_string("insert \"ho\" 1 \"ell\"", value_set_str("hello"));
	did_fail |= test_string("alpha? \"hello1\"", value_set_bool(FALSE));
	did_fail |= test_string("alnum? \"hello1\"", value_set_bool(TRUE));
	did_fail |= test_string("num? \"hello1\"", value_set_bool(FALSE));
	did_fail |= test_string("\"hello\" length", value_set_long(5));
	did_fail |= test_string("\"  hello  \" lstrip", value_set_str("hello  "));
	did_fail |= test_string("range \"hello\" 2 4", value_set_str("ll"));
//	did_fail |= test_string("replace \"hello\" \"ell\" \"ey h\"", value_set_str("hey ho"));
	did_fail |= test_string("\"  hello  \" rstrip", value_set_str("  hello"));
	
	char *strarr[] = { "one", "two", "three" };
	// This one is crashing the program.
	did_fail |= test_string("\"one two three\" split \" \"", value_set_ary_str(strarr, 3));
	did_fail |= test_string("\"hello\" starts_with? \"ello\"", value_set_bool(FALSE));
	did_fail |= test_string("\"  hello  \" strip", value_set_str("hello"));
	did_fail |= test_string("\"heLLO\" to_lower", value_set_str("hello"));
	did_fail |= test_string("\"heLLO\" to_upper", value_set_str("HELLO"));
	
	long andres[] = { 2, 4 };
	long orres[] = { 2, 4, 8, 3, 5 };
	long xorres[] = { 8, 3, 5 };
	long mulres[] = { 2, 4, 2, 4, 2, 4 };
	long appendres[] = { 2, 4, 8, 2, 4, 5 };
	long concatres[] = { 2, 4, 8, 2, 4, 5, 7, 7 };
	long deleteres[] = { 2, 8, 2, 4 };
	long deleteallres[] = { 2, 8, 2 };
	long deleteatres[] = { 2, 4, 2, 4 };
	long insertres[] = { 2, 4, 1000, 8, 2, 4 };
	long sortres[] = { 2, 2, 4, 4, 8 };
	long uniqres[] = { 2, 4, 8 };
	
	long consres[] = { 1, 2, 4, 8, 2 };
	long dropres[] = { 8, 2 };
	long tailres[] = { 4, 8, 2 };
	long takeres[] = { 2, 4 };
	did_fail |= test_string("(array 2 4 8 2 4) & (array 2 3 4 5)", value_set_ary_long(andres, 2));
	did_fail |= test_string("(array 2 4 8 2 4) | (array 2 3 4 5)", value_set_ary_long(orres, 5));
	did_fail |= test_string("(array 2 4 8 2 4) ^ (array 2 3 4 5)", value_set_ary_long(xorres, 3));
	did_fail |= test_string("(array 2 4) * 3", value_set_ary_long(mulres, 6));
	did_fail |= test_string("(array 2 4 8 2 4) append 5", value_set_ary_long(appendres, 6));
	did_fail |= test_string("(array 2 4 8 2 4) + 5", value_set_ary_long(appendres, 6));
	did_fail |= test_string("(array 2 4 8 2 4) at 2", value_set_long(8));
	did_fail |= test_string("(array 2 4 8 2 4) concat (array 5 7 7)", value_set_ary_long(concatres, 8));
	did_fail |= test_string("(array 2 4 8 2 4) + (array 5 7 7)", value_set_ary_long(concatres, 8));
	did_fail |= test_string("(array 2 4 8 2 4) delete 4", value_set_ary_long(deleteres, 4));
	did_fail |= test_string("(array 2 4 8 2 4) delete_all 4", value_set_ary_long(deleteallres, 3));
	did_fail |= test_string("(array 2 4 8 2 4) delete_at 2", value_set_ary_long(deleteatres, 4));
	did_fail |= test_string("insert (array 2 4 8 2 4) 2 1000", value_set_ary_long(insertres, 6));	
	did_fail |= test_string("(array 2 4 8 2 4) empty?", value_set_bool(FALSE));
//	did_fail |= test_string("(array (array 2 4) (array 8 2) 4) flatten", value_set_ary_long(numarr, 5));
	did_fail |= test_string("(array 2 4 8 2 4) join \"!\"", value_set_str("2!4!8!2!4"));
	did_fail |= test_string("(array 2 4 8 2 4) last", value_set_long(4));
	did_fail |= test_string("(array 2 4 8 2 4) sort", value_set_ary_long(sortres, 5));
	did_fail |= test_string("(array 2 4 8 2 4) uniq", value_set_ary_long(uniqres, 3));
	
	did_fail |= test_string("1 cons (array 2 4 8 2)", value_set_ary_long(consres, 5));
	did_fail |= test_string("(array 2 4 8 2) drop 2", value_set_ary_long(dropres, 2));
	did_fail |= test_string("(array 2 4 8 2) head", value_set_long(2));
	did_fail |= test_string("(array 2 4 8 2) tail", value_set_ary_long(tailres, 3));
	did_fail |= test_string("(array 2 4 8 2) take 2", value_set_ary_long(takeres, 2));

	if (did_fail) {
		printf("Test of primitives failed.\n\n");
	} else {
		printf("Test of primitives succeeded.\n\n");
	}
	
	printf("*****\n*****\n*****\n\n");
	
	print_info_p = orig_print_info_p;
	return did_fail;
}

/*
 * Extensively tests that numbers are working.
 */
int test_numbers()
{
	printf("\n*****\n*****\n*****\n\nTesting numbers.\n\n");
	
	int orig_print_info_p = print_info_p, orig_print_errors_p = print_errors_p;
	print_info_p = FALSE;
	print_errors_p = FALSE;
		
	int did_fail = FALSE;
	did_fail |= test_string("1", value_set_long(1));
	did_fail |= test_string("2", value_set_long(2));
	did_fail |= test_string("3", value_set_long(3));
	did_fail |= test_string("10", value_set_long(10));
	did_fail |= test_string("999", value_set_long(999));
	did_fail |= test_string("3.0", value_set_double(3.0));
	did_fail |= test_string("999.0", value_set_double(999.0));
	did_fail |= test_string("3.5", value_set_double(3.5));
	did_fail |= test_string("0.1", value_set_double(0.1));
	did_fail |= test_string("0.0", value_set_double(0.0));
	did_fail |= test_string("2.", value_set_double(2.0));
	did_fail |= test_string(".0", value_init_error());
	
	did_fail |= test_string("x = 3", value_set_long(3));
	did_fail |= test_string("x", value_set_long(3));
	did_fail |= test_string("x += 0.5", value_set_double(3.5));
	did_fail |= test_string("x", value_set_double(3.5));
	did_fail |= test_string("x -= 3", value_set_double(0.5));
	did_fail |= test_string("x", value_set_double(0.5));
	did_fail |= test_string("x *= 2", value_set_double(1.0));
	did_fail |= test_string("x", value_set_double(1.0));
	did_fail |= test_string("x /= 2", value_set_double(0.5));
	did_fail |= test_string("x", value_set_double(0.5));
	did_fail |= test_string("x /= 0.25", value_set_double(2.0));
	did_fail |= test_string("x", value_set_double(2.0));
	did_fail |= test_string("x = 11", value_set_long(11));
	did_fail |= test_string("x %= 4", value_set_long(3));
	did_fail |= test_string("x", value_set_long(3));
	did_fail |= test_string("x %= 2.5", value_init_error());
	did_fail |= test_string("x = 2.5", value_set_double(2.5));
	did_fail |= test_string("x %= 4", value_init_error());
	did_fail |= test_string("x = 15", value_set_long(15));
	did_fail |= test_string("x &= 30", value_set_long(14));
	did_fail |= test_string("x", value_set_long(14));
	did_fail |= test_string("x |= 3", value_set_long(15));
	did_fail |= test_string("x", value_set_long(15));
	did_fail |= test_string("x ^= 37", value_set_long(42));
	did_fail |= test_string("x", value_set_long(42));
	did_fail |= test_string("x <<= 3", value_set_long(336));
	did_fail |= test_string("x", value_set_long(336));
	did_fail |= test_string("x >>= 5", value_set_long(10));
	did_fail |= test_string("x", value_set_long(10));
	
	did_fail |= test_string("1**0", value_set_long(1));
	did_fail |= test_string("1**1", value_set_long(1));
	did_fail |= test_string("1**5", value_set_long(1));
	did_fail |= test_string("2**0", value_set_long(1));
	did_fail |= test_string("2**1", value_set_long(2));
	did_fail |= test_string("2**2", value_set_long(4));
	did_fail |= test_string("2**8", value_set_long(256));
	did_fail |= test_string("2**2**2", value_set_long(16));
	did_fail |= test_string("2**2**2**2", value_set_long(65536));
	did_fail |= test_string("(--1)**0", value_set_long(1));
	did_fail |= test_string("(--1)**1", value_set_long(-1));
	did_fail |= test_string("(--1)**2", value_set_long(1));
	did_fail |= test_string("(--1)**3", value_set_long(-1));
	did_fail |= test_string("10**3", value_set_long(1000));
	did_fail |= test_string("2**10", value_set_long(1024));
	did_fail |= test_string("2**(--1)", value_set_double(0.5));
	did_fail |= test_string("4**0.5", value_set_double(2.0));
	did_fail |= test_string("4.0**0.5", value_set_double(2.0));
	did_fail |= test_string("2**0.5", value_set_double(sqrt(2)));
	did_fail |= test_string("2.0**0.5", value_set_double(sqrt(2)));

	did_fail |= test_string("!1", value_set_bool(FALSE));
	did_fail |= test_string("! 1", value_set_bool(FALSE));
	did_fail |= test_string("! 0", value_set_bool(TRUE));
	did_fail |= test_string("! 3", value_set_bool(FALSE));
	did_fail |= test_string("!(1)", value_set_bool(FALSE));
	did_fail |= test_string("!1.5", value_set_bool(FALSE));
	did_fail |= test_string("! 1.75", value_set_bool(FALSE));
	did_fail |= test_string("! 0.2", value_set_bool(FALSE));
	did_fail |= test_string("! 3.99", value_set_bool(FALSE));
	did_fail |= test_string("!(1.75)", value_set_bool(FALSE));
	did_fail |= test_string("~1", value_set_long(-2));
	did_fail |= test_string("~ 1", value_set_long(-2));
	did_fail |= test_string("~ 0", value_set_long(-1));
	did_fail |= test_string("~ 3", value_set_long(-4));
	did_fail |= test_string("~(1)", value_set_long(-2));
	did_fail |= test_string("~ 3.5", value_init_error());
	did_fail |= test_string("~ 0.0", value_init_error());

	did_fail |= test_string("++ 1", value_set_long(1));
	did_fail |= test_string("-- 1", value_set_long(-1));
	did_fail |= test_string("--2", value_set_long(-2));
	did_fail |= test_string("-- 1.5", value_set_double(-1.5));
	did_fail |= test_string("++ -- 1", value_set_long(-1));
	did_fail |= test_string("-- ++ 1", value_set_long(-1));
	did_fail |= test_string("-- -- 1", value_set_long(1));
	did_fail |= test_string("-- -- -- 1", value_set_long(-1));
	did_fail |= test_string("++ -- -- 1", value_set_long(1));
	did_fail |= test_string("-- ++ -- 1", value_set_long(1));
	did_fail |= test_string("-- -- ++ 1", value_set_long(1));
	did_fail |= test_string("-- ++ ++ 1", value_set_long(-1));
	did_fail |= test_string("++ -- ++ 1", value_set_long(-1));
	did_fail |= test_string("++ ++ -- 1", value_set_long(-1));
	did_fail |= test_string("++ ++ 1", value_set_long(1));
	did_fail |= test_string("++ ++ ++ 1", value_set_long(1));
	did_fail |= test_string("1 abs --", value_set_long(-1));
	did_fail |= test_string("abs -- 1", value_set_long(1));
	did_fail |= test_string("1 -- abs", value_set_long(1));
	did_fail |= test_string("-- abs 1", value_set_long(-1));
	did_fail |= test_string("abs -- 1.5", value_set_double(1.5));
	did_fail |= test_string("abs 1", value_set_long(1));
	did_fail |= test_string("abs 1.5", value_set_double(1.5));
	did_fail |= test_string("--++ 1", value_init_error());
	did_fail |= test_string("++-- 1", value_init_error());
	did_fail |= test_string("---- 1", value_init_error());
	did_fail |= test_string("++++ 1", value_init_error());

	did_fail |= test_string("exp 0", value_set_double(1.0));
	did_fail |= test_string("exp 0.0", value_set_double(1.0));
	did_fail |= test_string("exp 1", value_set_double(exp(1.0)));
	did_fail |= test_string("exp 1.0", value_set_double(exp(1.0)));
	did_fail |= test_string("exp 2.5", value_set_double(exp(2.5)));
	did_fail |= test_string("exp -- 1", value_set_double(exp(-1)));
	did_fail |= test_string("exp -- 3", value_set_double(exp(-3)));
	did_fail |= test_string("exp -- 3.5", value_set_double(exp(-3.5)));
	did_fail |= test_string("log 0", value_init(VALUE_NAN));
	did_fail |= test_string("log 0.0", value_init(VALUE_NAN));
	did_fail |= test_string("log 1", value_set_double(log(1.0)));
	did_fail |= test_string("log 1.0", value_set_double(log(1.0)));
	did_fail |= test_string("log 2.5", value_set_double(log(2.5)));
	did_fail |= test_string("log -- 1", value_init(VALUE_NAN));
	did_fail |= test_string("log2 0", value_init(VALUE_NAN));
	did_fail |= test_string("log2 0.0", value_init(VALUE_NAN));
	did_fail |= test_string("log2 1", value_set_double(log2(1.0)));
	did_fail |= test_string("log2 1.0", value_set_double(log2(1.0)));
	did_fail |= test_string("log2 2.5", value_set_double(log2(2.5)));
	did_fail |= test_string("log2 -- 1", value_init(VALUE_NAN));
	did_fail |= test_string("log10 0", value_init(VALUE_NAN));
	did_fail |= test_string("log10 0.0", value_init(VALUE_NAN));
	did_fail |= test_string("log10 1", value_set_double(log10(1.0)));
	did_fail |= test_string("log10 1.0", value_set_double(log10(1.0)));
	did_fail |= test_string("log10 2.5", value_set_double(log10(2.5)));
	did_fail |= test_string("log10 -- 1", value_init(VALUE_NAN));
	did_fail |= test_string("sqrt 1", value_set_double(1.0));
	did_fail |= test_string("sqrt 1.0", value_set_double(1.0));
	did_fail |= test_string("sqrt 4", value_set_double(2.0));
	did_fail |= test_string("sqrt 2", value_set_double(sqrt(2)));
	did_fail |= test_string("sqrt 49", value_set_double(7.0));
	did_fail |= test_string("sqrt 99", value_set_double(sqrt(99)));
	did_fail |= test_string("sqrt -- 1", value_init(VALUE_NAN));
	did_fail |= test_string("sqrt -- 0.5", value_init(VALUE_NAN));
	did_fail |= test_string("sqrt 0.5", value_set_double(sqrt(0.5)));
	did_fail |= test_string("sqrt 2.5", value_set_double(sqrt(2.5)));

	did_fail |= test_string("factorial 0", value_set_long(1));
	did_fail |= test_string("0 factorial", value_set_long(1));
	did_fail |= test_string("factorial 1", value_set_long(1));
	did_fail |= test_string("factorial 3", value_set_long(6));
	did_fail |= test_string("factorial 5", value_set_long(120));
	did_fail |= test_string("2.5 factorial", value_init_error());
	did_fail |= test_string("3 choose 2", value_set_long(3));
	did_fail |= test_string("5 choose 2", value_set_long(10));
	did_fail |= test_string("20 choose 8", value_set_long(125970));
	did_fail |= test_string("2 choose 4", value_set_long(0));
	did_fail |= test_string("100 choose 100", value_set_long(1));
	did_fail |= test_string("0 choose 1", value_set_long(0));
	did_fail |= test_string("1.6 choose 4", value_init_error());
	did_fail |= test_string("5 choose 4.2", value_init_error());
	did_fail |= test_string("1.6 choose 0.5", value_init_error());
	
	// These will break if you change the precision.
	did_fail |= test_string("sin 1", value_set_str_smart("0.8414709848078965048756572286947630345821380615234375", 10));
	did_fail |= test_string("sin 1.0", value_set_str_smart("0.8414709848078965048756572286947630345821380615234375", 10));
	did_fail |= test_string("sin 10.0", value_set_str_smart("-0.5440211108893697744548489936278201639652252197265625", 10));
	did_fail |= test_string("cos 1", value_set_str_smart("0.540302305868139765010482733487151563167572021484375", 10));
	did_fail |= test_string("cos 1.0", value_set_str_smart("0.540302305868139765010482733487151563167572021484375", 10));
	did_fail |= test_string("cos 10.0", value_set_str_smart("-0.83907152907645243811174395887064747512340545654296875", 10));
	did_fail |= test_string("tan 1", value_set_str_smart("1.557407724654902292371616567834280431270599365234375", 10));
	did_fail |= test_string("tan 1.0", value_set_str_smart("1.557407724654902292371616567834280431270599365234375", 10));
	did_fail |= test_string("tan 10.0", value_set_str_smart("0.6483608274590866304976088940748013556003570556640625", 10));
	did_fail |= test_string("csc 1", value_set_str_smart("1.18839510577812124125784976058639585971832275390625", 10));
	did_fail |= test_string("csc 1.0", value_set_str_smart("1.18839510577812124125784976058639585971832275390625", 10));
	did_fail |= test_string("csc 10.0", value_set_str_smart("-1.8381639608896656046255202454631216824054718017578125", 10));
	did_fail |= test_string("sec 1", value_set_str_smart("1.850815717680925676091874265694059431552886962890625", 10));
	did_fail |= test_string("sec 1.0", value_set_str_smart("1.850815717680925676091874265694059431552886962890625", 10));
	did_fail |= test_string("sec 10.0", value_set_str_smart("-1.1917935066878957428571084165014326572418212890625", 10));
	did_fail |= test_string("cot 1", value_set_str_smart("0.6420926159343307570992465116432867944240570068359375", 10));
	did_fail |= test_string("cot 1.0", value_set_str_smart("0.6420926159343307570992465116432867944240570068359375", 10));
	did_fail |= test_string("cot 10.0", value_set_str_smart("1.542351045356920025142244412563741207122802734375", 10));
	
	if (did_fail) {
		printf("\nTest of numbers failed.\n\n");
	} else {
		printf("\nTest of numbers succeeded.\n\n");
	}
	
	printf("*****\n*****\n*****\n\n");
	
	print_info_p = orig_print_info_p;
	print_errors_p = orig_print_errors_p;
	return did_fail;
}

/* 
 * Extensively tests that strings are working. Does NOT test the following functions: 
 *   scan(), split()
 * 
 * Also does not test functions with regular expressions as arguments; exclusively uses 
 * strings and numbers.
 */
int test_strings()
{
	printf("\n*****\n*****\n*****\n\nTesting strings.\n\n");
	
	int orig_print_info_p = print_info_p;
	print_info_p = FALSE;
		
	int did_fail = FALSE;
	did_fail |= test_string("\"hello\"", value_set_str("hello"));
	did_fail |= test_string("\"hello \"", value_set_str("hello "));
	
	did_fail |= test_string("\"hello\" + \"world\"", value_set_str("helloworld"));
	did_fail |= test_string("\"hello\" + \" \" + \"world\"", value_set_str("hello world"));
	did_fail |= test_string("\"hello\" + 32 chr + \"world\"", value_set_str("hello world"));
	
	did_fail |= test_string("\"blah\" * 3", value_set_str("blahblahblah"));
	
	did_fail |= test_string("\"hello\" capitalize", value_set_str("Hello"));
	did_fail |= test_string("\"hELLO\" capitalize", value_set_str("Hello"));
	did_fail |= test_string("\"HELLO\" capitalize", value_set_str("Hello"));
	did_fail |= test_string("\"hello World\" capitalize", value_set_str("Hello world"));
	
	did_fail |= test_string("\"h\" asc", value_set_long((long) 'h'));
	
	did_fail |= test_string("\"hello\" chop", value_set_str("hell"));
	did_fail |= test_string("\"h\" chop", value_set_str(""));
	did_fail |= test_string("\"\" chop", value_set_str(""));
	
	did_fail |= test_string("97 chr", value_set_str("a"));
	did_fail |= test_string("10 chr", value_set_str("\n"));
	
	did_fail |= test_string("\"hello\" contains? \"h\"", value_set_bool(TRUE));
	did_fail |= test_string("\"hello\" contains? \"llo\"", value_set_bool(TRUE));
	did_fail |= test_string("\"hello\" contains? \"lo \"", value_set_bool(FALSE));
	did_fail |= test_string("\"hello\" contains? \"hello\"", value_set_bool(TRUE));
	did_fail |= test_string("\"hello\" contains? \"hello.\"", value_set_bool(FALSE));
	did_fail |= test_string("\"hello\" contains? \"hx\"", value_set_bool(FALSE));
	
	did_fail |= test_string("\"hello\" ends_with? \"h\"", value_set_bool(FALSE));
	did_fail |= test_string("\"hello\" ends_with? \"llo\"", value_set_bool(TRUE));
	did_fail |= test_string("\"hello\" ends_with? \"lo \"", value_set_bool(FALSE));
	did_fail |= test_string("\"hello\" ends_with? \"hello\"", value_set_bool(TRUE));
	did_fail |= test_string("\"hello\" ends_with? \"hello.\"", value_set_bool(FALSE));
	did_fail |= test_string("\"hello\" ends_with? \"o\"", value_set_bool(TRUE));
	
	did_fail |= test_string("\"hello\" index \"h\"", value_set_long(0));
	did_fail |= test_string("\"hello\" index \"llo\"", value_set_long(2));
	did_fail |= test_string("\"hello\" index \"lo \"", value_init_nil());
	did_fail |= test_string("\"hello\" index \"hello\"", value_set_long(0));
	did_fail |= test_string("\"hello\" index \"hello.\"", value_init_nil());
	did_fail |= test_string("\"hello\" index \"hx\"", value_init_nil());
	did_fail |= test_string("\"hello\" index \"o\"", value_set_long(4));
	
	did_fail |= test_string("\"hello\" insert 2 \"XX\"", value_set_str("heXXllo"));
	did_fail |= test_string("\"hello\" insert 3 \"XX\"", value_set_str("helXXlo"));
	did_fail |= test_string("\"hello\" insert 0 \"XX\"", value_set_str("XXhello"));
	did_fail |= test_string("\"hello\" insert 5 \"XX\"", value_set_str("helloXX"));
	
	did_fail |= test_string("\"hello\" alpha?", value_set_bool(TRUE));
	did_fail |= test_string("\"hel30lo\" alpha?", value_set_bool(FALSE));
	did_fail |= test_string("\"30hello\" alpha?", value_set_bool(FALSE));
	did_fail |= test_string("\"350\" alpha?", value_set_bool(FALSE));
	did_fail |= test_string("\"35.0\" alpha?", value_set_bool(FALSE));
	
	did_fail |= test_string("\"hello\" alnum?", value_set_bool(TRUE));
	did_fail |= test_string("\"hel30lo\" alnum?", value_set_bool(TRUE));
	did_fail |= test_string("\"30hello\" alnum?", value_set_bool(TRUE));
	did_fail |= test_string("\"350\" alnum?", value_set_bool(TRUE));
	did_fail |= test_string("\"35.0\" alnum?", value_set_bool(FALSE));
	
	did_fail |= test_string("\"hello\" num?", value_set_bool(FALSE));
	did_fail |= test_string("\"hel30lo\" num?", value_set_bool(FALSE));
	did_fail |= test_string("\"30hello\" num?", value_set_bool(FALSE));
	did_fail |= test_string("\"350\" num?", value_set_bool(TRUE));
	did_fail |= test_string("\"35.0\" num?", value_set_bool(FALSE));
	
	did_fail |= test_string("\"hello\" length", value_set_long(5));
	did_fail |= test_string("\"hello world\" length", value_set_long(11));
	did_fail |= test_string("\"3 \" length", value_set_long(2));
	did_fail |= test_string("\"xxx\" length", value_set_long(3));
	did_fail |= test_string("\"x x x\" length", value_set_long(5));
	
	did_fail |= test_string("\"hello\" lstrip", value_set_str("hello"));
	did_fail |= test_string("\" hello\" lstrip", value_set_str("hello"));
	did_fail |= test_string("\"  hello\" lstrip", value_set_str("hello"));
	did_fail |= test_string("\"hello \" lstrip", value_set_str("hello "));
	did_fail |= test_string("\"hello  \" lstrip", value_set_str("hello  "));
	did_fail |= test_string("\" hello \" lstrip", value_set_str("hello "));
	did_fail |= test_string("\"  hello  \" lstrip", value_set_str("hello  "));
	
	did_fail |= test_string("\"long string for range\" range 0 4", value_set_str("long"));
	did_fail |= test_string("\"long string for range\" range 0 11", value_set_str("long string"));
	did_fail |= test_string("\"long string for range\" range 12 22", value_set_str("for range"));
	did_fail |= test_string("\"long string for range\" range 0 22", value_set_str("long string for range"));
	did_fail |= test_string("\"long string for range\"[0...4]", value_set_str("long"));
	did_fail |= test_string("\"long string for range\"[0...11]", value_set_str("long string"));
	did_fail |= test_string("\"long string for range\"[12...22]", value_set_str("for range"));
	did_fail |= test_string("\"long string for range\"[0...22]", value_set_str("long string for range"));
	
	did_fail |= test_string("\"reppettitions\" replace \"p\" \"NEW\"", value_set_str("reNEWNEWettitions"));
	did_fail |= test_string("\"reppettitions\" replace \"t\" \"NEW\"", value_set_str("reppeNEWNEWiNEWions"));
	did_fail |= test_string("\"reppettitions\" replace \"repp\" \"BEGINNING\"", value_set_str("BEGINNINGettitions"));
	did_fail |= test_string("\"reppettitions\" replace \"reppettitions\" \"WHOLE NEW WORD\"", value_set_str("WHOLE NEW WORD"));
	
	did_fail |= test_string("\"hello\" reverse", value_set_str("olleh"));
	did_fail |= test_string("\"hello world\" reverse", value_set_str("dlrow olleh"));
	did_fail |= test_string("\"\" reverse", value_set_str(""));
	did_fail |= test_string("\"h\" reverse", value_set_str("h"));
	
	did_fail |= test_string("\"hello\" rstrip", value_set_str("hello"));
	did_fail |= test_string("\" hello\" rstrip", value_set_str(" hello"));
	did_fail |= test_string("\"  hello\" rstrip", value_set_str("  hello"));
	did_fail |= test_string("\"hello \" rstrip", value_set_str("hello"));
	did_fail |= test_string("\"hello  \" rstrip", value_set_str("hello"));
	did_fail |= test_string("\" hello \" rstrip", value_set_str(" hello"));
	did_fail |= test_string("\"  hello  \" rstrip", value_set_str("  hello"));
	
	// scan() and split() are not tested because they return arrays, which are more difficult to 
	// quickly create.
		
	did_fail |= test_string("\"hello\" starts_with? \"h\"", value_set_bool(TRUE));
	did_fail |= test_string("\"hello\" starts_with? \"hel\"", value_set_bool(TRUE));
	did_fail |= test_string("\"hello\" starts_with? \"heo\"", value_set_bool(FALSE));
	did_fail |= test_string("\"hello\" starts_with? \"hello\"", value_set_bool(TRUE));
	did_fail |= test_string("\"hello\" starts_with? \"hello.\"", value_set_bool(FALSE));
	did_fail |= test_string("\"hello\" starts_with? \"ello\"", value_set_bool(FALSE));
	
	did_fail |= test_string("\"hello\" strip", value_set_str("hello"));
	did_fail |= test_string("\" hello\" strip", value_set_str("hello"));
	did_fail |= test_string("\"  hello\" strip", value_set_str("hello"));
	did_fail |= test_string("\"hello \" strip", value_set_str("hello"));
	did_fail |= test_string("\"hello  \" strip", value_set_str("hello"));
	did_fail |= test_string("\" hello \" strip", value_set_str("hello"));
	did_fail |= test_string("\"  hello  \" strip", value_set_str("hello"));
	
	did_fail |= test_string("\"hello\" to_upper", value_set_str("HELLO"));
	did_fail |= test_string("\"hELLO\" to_upper", value_set_str("HELLO"));
	did_fail |= test_string("\"HELLO\" to_upper", value_set_str("HELLO"));
	did_fail |= test_string("\"hello World\" to_upper", value_set_str("HELLO WORLD"));
	
	did_fail |= test_string("\"hello\" to_lower", value_set_str("hello"));
	did_fail |= test_string("\"hELLO\" to_lower", value_set_str("hello"));
	did_fail |= test_string("\"HELLO\" to_lower", value_set_str("hello"));
	did_fail |= test_string("\"hello World\" to_lower", value_set_str("hello world"));
	
	if (did_fail) {
		printf("\nTest of strings failed.\n\n");
	} else {
		printf("\nTest of strings succeeded.\n\n");
	}
	
	printf("*****\n*****\n*****\n\n");
	
	print_info_p = orig_print_info_p;
	return did_fail;
}

/* 
 * Extensively tests arrays. Currently does NOT test: 
 * - some arithmetic functions such as * and &
 * - iterators
 * - shuffle()
 */
int test_arrays()
{
	printf("\n*****\n*****\n*****\n\nTesting arrays.\n\n");
	
	int orig_print_info_p = print_info_p;
	print_info_p = FALSE;
	
	long internal_arr[] = { 2, 4, 5, 8 };
	value arr = value_set_ary_long(internal_arr, 4);
	
	int did_fail = FALSE;
	did_fail |= test_string("array 2 4 5 8", value_set(arr));
	did_fail |= test_string("(array 2 4 5 8)", value_set(arr));
	did_fail |= test_string("array", value_init(VALUE_ARY));
	did_fail |= test_string("(array)", value_init(VALUE_ARY));
	
	did_fail |= test_string("(array 2 4 5) append 8", value_set(arr));
	did_fail |= test_string("(array 2 4) append 5 append 8", value_set(arr));
	did_fail |= test_string("(array) append 2 append 4 append 5 append 8", value_set(arr));
	
	did_fail |= test_string("(array 2 4 5 8)[0]", value_set_long(2));
	did_fail |= test_string("(array 2 4 5 8)[1]", value_set_long(4));
	did_fail |= test_string("(array 2 4 5 8)[2]", value_set_long(5));
	did_fail |= test_string("(array 2 4 5 8)[3]", value_set_long(8));
	did_fail |= test_string("(array 2 4 5 8)[4]", value_init_error());
	did_fail |= test_string("(array 2 4 5 8)[--1]", value_init_error());
	
	did_fail |= test_string("(array 2 4) concat (array 5 8)", value_set(arr));
	did_fail |= test_string("(array 2) concat (array 4 5 8)", value_set(arr));
	did_fail |= test_string("(array 2) concat (array 4) concat (array 5) concat (array 8)", value_set(arr));
	
	did_fail |= test_string("(array) concat (array 2 4 5 8) concat (array)", value_set(arr));
	did_fail |= test_string("(array 2 4 5) + 8", value_set(arr));
	did_fail |= test_string("(array 2 4) + 5 + 8", value_set(arr));
	did_fail |= test_string("(array) + 2 + 4 + 5 + 8", value_set(arr));
	did_fail |= test_string("(array 2 4) + (array 5 8)", value_set(arr));
	did_fail |= test_string("(array 2) + (array 4 5 8)", value_set(arr));

	did_fail |= test_string("(array 2 4 5 0 8) delete 0", value_set(arr));
	did_fail |= test_string("(array 4 2 4 5 8) delete 4", value_set(arr));
	
	did_fail |= test_string("(array 0 2 0 4 5 0 8) delete_all 0", value_set(arr));
	did_fail |= test_string("(array 2 0 0 4 5 8 0) delete_all 0", value_set(arr));
	
	did_fail |= test_string("(array 2 4 10 5 8) delete_at 2", value_set(arr));
	did_fail |= test_string("(array 2 4 5 8 10) delete_at 4", value_set(arr));
	did_fail |= test_string("(array 2 2 4 5 8) delete_at 1", value_set(arr));
	
	did_fail |= test_string("(array 1 2 3 4) empty?", value_set_bool(FALSE));
	did_fail |= test_string("(array 99) empty?", value_set_bool(FALSE));
	did_fail |= test_string("(array) empty?", value_set_bool(TRUE));

	did_fail |= test_string("(array (array 2 4) 5 8) flatten", value_set(arr));
	did_fail |= test_string("(array (array 2) (array 4 5) 8) flatten", value_set(arr));
	did_fail |= test_string("(array (array 2 4) (array 5 8)) flatten", value_set(arr));

	did_fail |= test_string("(array 2 4 5 8) join \"+\"", value_set_str("2+4+5+8"));
	
	did_fail |= test_string("(array 2 4 5 8) last", value_set_long(8));
	did_fail |= test_string("(array 2 4) last", value_set_long(4));
	did_fail |= test_string("(array) last", value_init_nil());

	did_fail |= test_string("(array 2 4 5 8 10) pop", value_set(arr));
	did_fail |= test_string("(array 7) pop", value_init(VALUE_ARY));
	
	did_fail |= test_string("(array 2 4 5 8) size", value_set_long(4));
	did_fail |= test_string("(array) size", value_set_long(0));
	
	did_fail |= test_string("(array 8 5 4 2) sort", value_set(arr));
	did_fail |= test_string("(array 5 4 8 2) sort", value_set(arr));
	
	did_fail |= test_string("(array 2 4 2 5 8) uniq", value_set(arr));
	did_fail |= test_string("(array 2 4 5 4 2 8) uniq", value_set(arr));
	did_fail |= test_string("(array 2 4 2 5 5 8 2 8) uniq", value_set(arr));
	
	did_fail |= test_string("(array 2 4 2 5 8) uniq_sort", value_set(arr));
	did_fail |= test_string("(array 4 2 5 4 2 8) uniq_sort", value_set(arr));
	did_fail |= test_string("(array 4 2 8 5 5 8 2 8) uniq_sort", value_set(arr));
	
	did_fail |= test_string("(array 2 4 5 8) contains? 5", value_set_bool(TRUE));
	did_fail |= test_string("(array 2 4 5 8) contains? 2", value_set_bool(TRUE));
	did_fail |= test_string("(array 2 4 5 8) contains? 8", value_set_bool(TRUE));
	did_fail |= test_string("(array 2 4 5 8) contains? 10", value_set_bool(FALSE));
	did_fail |= test_string("(array 2 4 5 8) contains? \"hello\"", value_set_bool(FALSE));

	did_fail |= test_string("(array 2 4 5 8) index 2", value_set_long(0));
	did_fail |= test_string("(array 2 4 5 8) index 4", value_set_long(1));
	did_fail |= test_string("(array 2 4 5 8) index 5", value_set_long(2));
	did_fail |= test_string("(array 2 4 5 8) index 8", value_set_long(3));
	did_fail |= test_string("(array 2 4 5 8) index 10", value_init_nil());

	did_fail |= test_string("(array 4 5 8) insert 0 2", value_set(arr));
	did_fail |= test_string("(array 2 5 8) insert 1 4", value_set(arr));
	did_fail |= test_string("(array 2 4 5) insert 3 8", value_set(arr));

	did_fail |= test_string("(array 2 4 5 8) length", value_set_long(4));
	did_fail |= test_string("(array) length", value_set_long(0));
	did_fail |= test_string("(array 2 4) length", value_set_long(2));
	did_fail |= test_string("(array 1 2 3 4 5 6 7 8 9) length", value_set_long(9));
	
	did_fail |= test_string("(array 8 5 4 2) reverse", value_set(arr));
	did_fail |= test_string("(array) reverse", value_init(VALUE_ARY));

	did_fail |= test_string("2 cons (array 4 5 8)", value_set(arr));
	did_fail |= test_string("2 cons 4 cons (array 5 8)", value_set(arr));

	did_fail |= test_string("(array 0 1 2 4 5 8) drop 2", value_set(arr));
	did_fail |= test_string("(array 2 4 5 8) drop 0", value_set(arr));
	did_fail |= test_string("(array 1 2 3 4) drop 4", value_init_nil());

	did_fail |= test_string("(array 2 4 5 8) head", value_set_long(2));
	
	did_fail |= test_string("(array 1 2 4 5 8) tail", value_set(arr));
	did_fail |= test_string("(array 8) tail", value_init(VALUE_ARY));

	did_fail |= test_string("(array 2 4 5 8 9 10 11) take 4", value_set(arr));
	did_fail |= test_string("(array 1 2 3) take 0", value_init_nil());


	did_fail |= test_string("(array 2 4 5 8)", value_set(arr));

	if (did_fail) {
		printf("\nTest of arrays failed.\n\n");
	} else {
		printf("\nTest of arrays succeeded.\n\n");
	}
	
	printf("*****\n*****\n*****\n\n");
	
	print_info_p = orig_print_info_p;
	return did_fail;
}

/* 
 * See test_arrays()
 */
int test_lists()
{
	printf("\n*****\n*****\n*****\n\nTesting lists.\n\n");
	
	int orig_print_info_p = print_info_p;
	print_info_p = FALSE;
	
	value x, arr = value_init_nil();
	x = value_set_long(8);
	value_cons_now2(&x, &arr);
	x = value_set_long(5);
	value_cons_now2(&x, &arr);
	x = value_set_long(4);
	value_cons_now2(&x, &arr);
	x = value_set_long(2);
	value_cons_now2(&x, &arr);
		
	int did_fail = FALSE;
	did_fail |= test_string("list 2 4 5 8", value_set(arr));
	did_fail |= test_string("(list 2 4 5 8)", value_set(arr));
	did_fail |= test_string("list", value_init_nil());
	did_fail |= test_string("(list)", value_init_nil());
	
	did_fail |= test_string("2 cons (list 4 5 8)", value_set(arr));
	did_fail |= test_string("2 cons 4 cons (list 5 8)", value_set(arr));

	did_fail |= test_string("(list 0 1 2 4 5 8) drop 2", value_set(arr));
	did_fail |= test_string("(list 2 4 5 8) drop 0", value_set(arr));
	did_fail |= test_string("(list 1 2 3 4) drop 4", value_init_nil());

	did_fail |= test_string("(list 2 4 5 8) head", value_set_long(2));
	
	did_fail |= test_string("(list 1 2 4 5 8) tail", value_set(arr));
	did_fail |= test_string("(list 8) tail", value_init_nil());

	did_fail |= test_string("(list 2 4 5 8 9 10 11) take 4", value_set(arr));
	did_fail |= test_string("(list 1 2 3) take 0", value_init_nil());

	did_fail |= test_string("(list 2 4 5) append 8", value_set(arr));
	did_fail |= test_string("(list 2 4) append 5 append 8", value_set(arr));
//	did_fail |= test_string("(list) append 2 append 4 append 5 append 8", value_set(arr));
	
	did_fail |= test_string("(list 2 4 5 8)[0]", value_set_long(2));
	did_fail |= test_string("(list 2 4 5 8)[1]", value_set_long(4));
	did_fail |= test_string("(list 2 4 5 8)[2]", value_set_long(5));
	did_fail |= test_string("(list 2 4 5 8)[3]", value_set_long(8));
	did_fail |= test_string("(list 2 4 5 8)[4]", value_init_error());
	did_fail |= test_string("(list 2 4 5 8)[--1]", value_init_error());
	
	did_fail |= test_string("(list 2 4) concat (list 5 8)", value_set(arr));
	did_fail |= test_string("(list 2) concat (list 4 5 8)", value_set(arr));
	did_fail |= test_string("(list 2) concat (list 4) concat (list 5) concat (list 8)", value_set(arr));
	
	did_fail |= test_string("(list) concat (list 2 4 5 8) concat (list)", value_set(arr));
	did_fail |= test_string("(list 2 4 5) + 8", value_set(arr));
	did_fail |= test_string("(list 2 4) + 5 + 8", value_set(arr));
//	did_fail |= test_string("2 + 4 + 5 + 8 + (list)", value_set(arr));
	did_fail |= test_string("(list 2 4) + (list 5 8)", value_set(arr));
	did_fail |= test_string("(list 2) + (list 4 5 8)", value_set(arr));

	did_fail |= test_string("(list 2 4 5 0 8) delete 0", value_set(arr));
	did_fail |= test_string("(list 4 2 4 5 8) delete 4", value_set(arr));
	
	did_fail |= test_string("(list 0 2 0 4 5 0 8) delete_all 0", value_set(arr));
	did_fail |= test_string("(list 2 0 0 4 5 8 0) delete_all 0", value_set(arr));
	
//	did_fail |= test_string("(list 2 4 10 5 8) delete_at 2", value_set(arr));
//	did_fail |= test_string("(list 2 4 5 8 10) delete_at 4", value_set(arr));
//	did_fail |= test_string("(list 2 2 4 5 8) delete_at 1", value_set(arr));
	
	did_fail |= test_string("(list 1 2 3 4) empty?", value_set_bool(FALSE));
	did_fail |= test_string("(list 99) empty?", value_set_bool(FALSE));
	did_fail |= test_string("(list) empty?", value_set_bool(TRUE));

	did_fail |= test_string("(list (list 2 4) 5 8) flatten", value_set(arr));
	did_fail |= test_string("(list (list 2) (list 4 5) 8) flatten", value_set(arr));
	did_fail |= test_string("(list (list 2 4) (list 5 8)) flatten", value_set(arr));

	did_fail |= test_string("(list 2 4 5 8) join \"+\"", value_set_str("2+4+5+8"));
	
	did_fail |= test_string("(list 2 4 5 8) last", value_set_long(8));
	did_fail |= test_string("(list 2 4) last", value_set_long(4));
	did_fail |= test_string("(list) last", value_init_nil());

	did_fail |= test_string("(list 2 4 5 8 10) pop", value_set(arr));
	did_fail |= test_string("(list 7) pop", value_init_nil());
	
	did_fail |= test_string("(list 2 4 5 8) size", value_set_long(4));
//	did_fail |= test_string("(list) size", value_set_long(0));
	
	did_fail |= test_string("(list 8 5 4 2) sort", value_set(arr));
	did_fail |= test_string("(list 5 4 8 2) sort", value_set(arr));
	
//	did_fail |= test_string("(list 2 4 2 5 8) uniq", value_set(arr));
//	did_fail |= test_string("(list 2 4 5 4 2 8) uniq", value_set(arr));
//	did_fail |= test_string("(list 2 4 2 5 5 8 2 8) uniq", value_set(arr));
	
	did_fail |= test_string("(list 2 4 2 5 8) uniq_sort", value_set(arr));
	did_fail |= test_string("(list 4 2 5 4 2 8) uniq_sort", value_set(arr));
	did_fail |= test_string("(list 4 2 8 5 5 8 2 8) uniq_sort", value_set(arr));
	
	did_fail |= test_string("(list 2 4 5 8) contains? 5", value_set_bool(TRUE));
	did_fail |= test_string("(list 2 4 5 8) contains? 2", value_set_bool(TRUE));
	did_fail |= test_string("(list 2 4 5 8) contains? 8", value_set_bool(TRUE));
	did_fail |= test_string("(list 2 4 5 8) contains? 10", value_set_bool(FALSE));
	did_fail |= test_string("(list 2 4 5 8) contains? \"hello\"", value_set_bool(FALSE));

	did_fail |= test_string("(list 2 4 5 8) index 2", value_set_long(0));
	did_fail |= test_string("(list 2 4 5 8) index 4", value_set_long(1));
	did_fail |= test_string("(list 2 4 5 8) index 5", value_set_long(2));
	did_fail |= test_string("(list 2 4 5 8) index 8", value_set_long(3));
	did_fail |= test_string("(list 2 4 5 8) index 10", value_init_nil());

	did_fail |= test_string("(list 4 5 8) insert 0 2", value_set(arr));
	did_fail |= test_string("(list 2 5 8) insert 1 4", value_set(arr));
	did_fail |= test_string("(list 2 4 5) insert 3 8", value_set(arr));

	did_fail |= test_string("(list 2 4 5 8) length", value_set_long(4));
	did_fail |= test_string("(list) length", value_set_long(0));
	did_fail |= test_string("(list 2 4) length", value_set_long(2));
	did_fail |= test_string("(list 1 2 3 4 5 6 7 8 9) length", value_set_long(9));
	
	did_fail |= test_string("(list 8 5 4 2) reverse", value_set(arr));
	did_fail |= test_string("(list) reverse", value_init_nil());

	did_fail |= test_string("(list 2 4 5 8)", value_set(arr));

	if (did_fail) {
		printf("\nTest of lists failed.\n\n");
	} else {
		printf("\nTest of lists succeeded.\n\n");
	}
	
	printf("*****\n*****\n*****\n\n");
	
	print_info_p = orig_print_info_p;
	return did_fail;

}

/* 
 * Test various errors to make sure they are giving the right message, and not breaking.
 */
int test_errors()
{
	printf("\n*****\n*****\n*****\n\nTesting errors.\n\n");
	
	int orig_print_info_p = print_info_p;
	print_info_p = FALSE;
	
	value err = value_init_error();
	
	int did_fail = FALSE;
	did_fail |= test_string("( 3", err); // closing parenthesis not found
	did_fail |= test_string("3 )", err); // opening parenthesis not found
	did_fail |= test_string("3 + ", err); // missing argument in binary operator
	did_fail |= test_string("+ 3", err); // missing argument in binary operator
	did_fail |= test_string("^&# 3", err); // unrecognized function or value ^&#
	
	if (did_fail) {
		printf("\nTest of errors failed.\n\n");
	} else {
		printf("\nTest of errors succeeded.\n\n");
	}
	
	printf("*****\n*****\n*****\n\n");
	
	print_info_p = orig_print_info_p;
	return did_fail;
}

/* 
 * Tests various control structures.
 */
int test_controls()
{
	printf("\n*****\n*****\n*****\n\nTesting control structures.\n\n");
	
	int orig_print_info_p = print_info_p;
	int orig_print_errors_p = print_errors_p;
	print_info_p = TRUE;
			
	int did_fail = FALSE;
	
	// If statements.
	did_fail |= test_string("if true 3", value_set_long(3));
	did_fail |= test_string("if false 3", value_init_nil());
	did_fail |= test_string("if true 3 else 5", value_set_long(3));
	did_fail |= test_string("if false 3 else 5", value_set_long(5));

	did_fail |= test_string("if true { 3 }", value_set_long(3));
	did_fail |= test_string("if false { 3 }", value_init_nil());
	did_fail |= test_string("if true { 3 } { 5 }", value_set_long(3));
	did_fail |= test_string("if false { 3 } { 5 }", value_set_long(5));

	did_fail |= test_string("if true { 3 } 5", value_set_long(3));
	did_fail |= test_string("if false { 3 } 5", value_set_long(5));
	did_fail |= test_string("if true then 3 { 5 }", value_set_long(3));
	did_fail |= test_string("if false then 3 { 5 }", value_set_long(5));

	print_errors_p = orig_print_errors_p;

	if (did_fail) {
		printf("\nTest of control structures failed.\n\n");
	} else {
		printf("\nTest of control structures succeeded.\n\n");
	}
	
	printf("*****\n*****\n*****\n\n");
	
	print_info_p = orig_print_info_p;
	return did_fail;
}


int print_time(time_t time)
{
	printf("%ld sec, %ld msec\n", time / 1000000, time % 1000);
}

/* 
 * Calculates how fast different sorting algorithms are for arrays of different lengths.
 * 
 * Pure Sorting Algorithm Speed
 * 
 * insertion_sort1() wins for an array of 4 elements. bubble_sort() wins from 8 to 2048, and 
 * quicksort() wins for every value 4096 and up.
 * 
 * 
 */
int sort_speeds(int min_length, int max_length, int max_repeats)
{
	time_t start, finish, time;
	int i, length;
	for (length = min_length; length <= max_length; length *= 2) {
		int array[length];
		
		start = usec();
		for (i = 0; i < max_repeats / length; ++i)
			fill_array(array, length);
		finish = usec();
		time = finish - start;
		
		// The O(n^2) can't handle an array any longer than this. The time an O(n^2) algorithm takes is 
		// directly proportional to (max_repeats) and proportional to the square of (length).
		if ((length/(double) (1 << 5)) * (length/(double) (1 << 5)) * (max_repeats/(double) (1 << 22)) <= 1) {
			start = usec();
			for (i = 0; i < max_repeats / length; ++i) {
				fill_array(array, length);
				bubble_sort(array, length);
			}
			finish = usec();
			printf("time to sort %d items using bubble: ", length);
			print_time(finish - start - time);

			start = usec();
			for (i = 0; i < max_repeats / length; ++i) {
				fill_array(array, length);
				insertion_sort1(array, length);
			}
			finish = usec();
			printf("time to sort %d items using insertion1: ", length);
			print_time(finish - start - time);

			start = usec();
			for (i = 0; i < max_repeats / length; ++i) {
				fill_array(array, length);
				insertion_sort2(array, length);
			}
			finish = usec();
			printf("time to sort %d items using insertion2: ", length);
			print_time(finish - start - time);
		}

		start = usec();
		for (i = 0; i < max_repeats / length; ++i) {
			fill_array(array, length);
			merge_sort(array, length);
		}
		finish = usec();
		printf("time to sort %d items using merge: ", length);
		print_time(finish - start - time);

		start = usec();
		for (i = 0; i < max_repeats / length; ++i) {
			fill_array(array, length);
			quicksort2(array, length);
		}
		finish = usec();
		printf("time to sort %d items using quicksort2: ", length);
		print_time(finish - start - time);
		
		start = usec();
		for (i = 0; i < max_repeats / length; ++i) {
			fill_array(array, length);
			custom_sort1(array, length);
		}
		finish = usec();
		printf("time to sort %d items using custom1: ", length);
		print_time(finish - start - time);		
		
		printf("\n");
	}
	
	return 0;
}

int value_sort_speeds(int min_length, int max_length, int max_repeats)
{
	time_t start, finish, time;
	int i, length;
	for (length = min_length; length <= max_length; length *= 2) {
		value array[length];
		vfill_array(array, length);
		
		start = usec();
		for (i = 0; i < max_repeats / length; ++i)
			vshuffle_array(array, length);
		finish = usec();
		time = finish - start;
		
//		start = usec();
//		for (i = 0; i < max_repeats / length; ++i) {
//			vshuffle_array(array, length);
//			vmerge_sort(array, length);
//		}
//		finish = usec();
//		printf("time to sort %d items using vmerge: ", length);
//		print_time(finish - start - time);
		
		start = usec();
		for (i = 0; i < max_repeats / length; ++i) {
			vshuffle_array(array, length);
			vcustom_sort2(array, length, 8);
		}
		finish = usec();
		printf("time to sort %d items using cutoff 8: ", length);
		print_time(finish - start - time);
		
		start = usec();
		for (i = 0; i < max_repeats / length; ++i) {
			vshuffle_array(array, length);
			vcustom_sort2(array, length, 16);
		}
		finish = usec();
		printf("time to sort %d items using cutoff 16: ", length);
		print_time(finish - start - time);
		
		start = usec();
		for (i = 0; i < max_repeats / length; ++i) {
			vshuffle_array(array, length);
			vcustom_sort2(array, length, 24);
		}
		finish = usec();
		printf("time to sort %d items using cutoff 24: ", length);
		print_time(finish - start - time);
		
		printf("\n");
	}
	
	return 0;
}

int small_sort_speeds()
{
	return value_sort_speeds(1 << 10, 1 << 15, 1 << 25);
}/*
 *  tests.h
 *  Simfpl
 *
 *  Created by Michael Dickens on 7/6/10.
 *  Copyright 2010 The Khabele School. All rights reserved.
 *
 */
 
#include <sys/time.h>
#include "sort.h"

value test_vars;

int init_tests();

time_t usec();

/* 
 * Runs several tests in order. Each test assumes that the previous one 
 * succeeds.
 */
int run_tests();

/*
 * Run several benchmarks to determine how fast the program is running.
 */
int run_benchmarks();


int import_benchmark(char *name);
int set_benchmark1();

int test_assert(int p, char *description);
int test_sexp(char *str, value sexp, value expected);
int test_string(char *str, value expected);

int test_inputs();
int test_to_prefix();
int test_primitives();
int test_numbers();
int test_strings();
int test_arrays();
int test_lists();
int test_errors();
int test_inputs();
int test_controls();


int sort_speeds(int min_length, int max_length, int max_repeats);
int value_sort_speeds(int min_length, int max_length, int max_repeats);
int small_sort_speeds();
/*
 *  tools.c
 *  Calculator
 *
 *  Created by Michael Dickens on 1/9/10.
 *
 */

#include "tools.h"

int init_tools()
{
	print_errors_p = TRUE;
	error_count = 0;
	linenum = 0;
		
	// Initialize the random number generator.
	init_genrand((unsigned long) time(NULL));

	return 0;
}

/* 
 * Not a symbol: 
 * 
 * ( ) [ ] { } $ ;
 */
int iscsymbol(char c)
{
	switch (c) {
		case '!': case '#': case '%': case '&': 
		case '*': case '+': case '-': case '.': case '/': 
		case ':': case '<': case '=': case '>': case '?': 
		case '@': case '\\': case '^': case '_': case '`': 
		case '|': case '~': 
			return TRUE;
		default:
			return FALSE;
	}
}

int streq2(char *s, char *t)
{
	--s; --t;
	while (*(++s))
		if (*s != *(++t))
			return FALSE;
	return TRUE;
}

int strne2(char *s, char *t)
{
	--s; --t;
	while (*(++s) && *(++t))
		if (*s == *t)
			return FALSE;
	return TRUE;
}

int print_words(char *words[], int length)
{
	int i;
	for (i = 0; i < length; ++i) {
		printf("%s ", words[i]);
	} printf("\n");
	return 0;
}

/*
 * Takes minus signs into account.
 */
int minus_isnumeric(char *str)
{
	if (str == NULL) {
		value_error(0, "Compiler warning: Null string passed to isnumeric().");
		return FALSE;
	}
		
	int pointcount = 0; // There can only be one decimal point in a number, so keep track.
	int xcount = 0; // Same deal as pointcount.
	int is_hex = FALSE;
	int isbeforedigits = TRUE;
	
	while (isspace(*str))
		++str;
	
	if (*str == '-' && *(str+1) == '\0')
		return FALSE;
	
	if (*str == '-' || isdigit(*str)) {
		if (*str == '-')
			++str;
		
		if (isdigit(*str))
			isbeforedigits = FALSE;
		while (*(++str) != '\0') {
			if (!isdigit(*str))
				if (is_hex && *str >= 'a' && *str <= 'f')
					;
				else if (xcount == 0 && isbeforedigits == FALSE && *str == 'x') {
					++xcount;
					is_hex = TRUE;
				} else if (pointcount == 0 && isbeforedigits == FALSE && *str == '.')
					++pointcount;
				else return FALSE;
			else isbeforedigits = FALSE;
		}
		if (*str == '.')
			return FALSE; // the point cannot be the last character
		return pointcount + 1; // 1 for integer, 2 for float
	} else return FALSE;
}

/*
 * Does not consider minus signs to be a part of the number.
 */
int isnumeric(char *str)
{
	if (str == NULL) {
		value_error(0, "Compiler warning: Null string passed to isnumeric().");
		return -1;
	}
		
	int pointcount = 0; // There can only be one decimal point in a number, so keep track.
	int xcount = 0; // Same deal as pointcount.
	int is_hex = FALSE;
		
	while (isspace(*str))
		++str;
	
	int scientific_p = FALSE;
	
	if (*str == '-')
		++str;
	
	if (isdigit(*str)) {
		
		while (*(++str)) {
			if (!isdigit(*str))
				if (is_hex && *str >= 'a' && *str <= 'f')
					;
				else if (*str == 'e') {
					if (scientific_p) {
						value_error(1, "Syntax Error: Illegal number syntax %c; numbers in scientific notation may not have more than one 'e'.", str);
						return -1;
					} else {
						scientific_p = TRUE;
						if (pointcount == 0) pointcount = 1;
					}
				} else if (xcount == 0 && *str == 'x') {
					++xcount;
					is_hex = TRUE;
				} else if (pointcount == 0 && *str == '.')
					++pointcount;
				else return FALSE;
		}
		if (*str == '.')
			return FALSE; // the point cannot be the last character
		return pointcount + 1; // 1 for integer, 2 for float
	} else return FALSE;
}

int isword(char *str)
{
	if (str == NULL) {
		value_error(0, "Compiler warning: Null string passed to isnumeric().");
		return FALSE;
	}
	
	if (!isalpha(*str))
		return FALSE;
	while (*(++str))
		if (!isalnum(*str))
			return FALSE;
	return TRUE;
}

int is_string_literal(char *str)
{
	if (*str != '"')
		return FALSE;
	int is_prev_backslash = FALSE;
	int is_end = FALSE;
	while (*(++str)) {
		if (is_end && !isspace(*str)) {
			// We are off the end of the string.
			return FALSE;
		}
		
		
		if (*str == '\\')
			is_prev_backslash = !is_prev_backslash;
		else {
			if (*str == '"' && !is_prev_backslash)
				is_end = TRUE;
			is_prev_backslash = FALSE;
		}
	}
	
	return is_end;
}

int is_regex_literal(char *str)
{
	if (*str != '\'')
		return FALSE;
	int is_prev_backslash = FALSE;
	int is_end = FALSE;
	while (*(++str)) {
		if (is_end && !isspace(*str)) {
			// We are off the end of the string.
			return FALSE;
		}
		
		
		if (*str == '\\')
			is_prev_backslash = !is_prev_backslash;
		else {
			if (*str == '\'' && !is_prev_backslash)
				is_end = TRUE;
			is_prev_backslash = FALSE;
		}
	}
	
	return is_end;
}

/* Since GNU POSIX does not support shorthand character classes, this creates them.
 * Supports \w, \d, \s and the corresponding uppercase versions.
 */
char * convert_regex_to_literal(char *str)
{
	size_t len = strlen(str);
	char tmp[len * 3];
	char *ptr = tmp;
	while (*str) {
		if (*str == '\\') {
			++str;
			if (*str == 'w') {
				strcpy(ptr, "[A-Za-z0-9_]");
				ptr += strlen(ptr);
			} else if (*str == 'd') {
				strcpy(ptr, "[0-9]");
				ptr += strlen(ptr);
			} else if (*str == 's') {
				strcpy(ptr, "[ \t\n\f\r]");
				ptr += strlen(ptr);
			} else if (*str == 'W') {
				strcpy(ptr, "[^A-Za-z0-9_]");
				ptr += strlen(ptr);
			} else if (*str == 'D') {
				strcpy(ptr, "[^0-9]");
				ptr += strlen(ptr);
			} else if (*str == 'S') {
				strcpy(ptr, "[^ \t\n\f\r]");
				ptr += strlen(ptr);
			} else if (*str != '\'') {
				*(ptr++) = '\\';
				*(ptr++) = *str;
			}
		} else {
			*ptr = *str;
			++ptr;
		}
		++str;
	}
	
	*ptr = '\0';
	
	char *res = value_malloc(NULL, sizeof(char) * (strlen(tmp) + 1));
	if (res) strcpy(res, tmp);
	return res;
}

/* Converts "\n" into a newline, "\\" into a backslash, etc.
 */
char * convert_to_literal(char *str)
{
	char *res = value_malloc(NULL, strlen(str) + 1);
	if (res == NULL) return NULL;
	char *ptr = res;
	while (*str) {
		if (*str == '\\') {
			++str;
			switch (*str) {
				case '\\':
					*ptr = '\\';
					break;
				case '"':
					*ptr = '"';
					break;
				case 'a':
					*ptr = '\a';
					break;
				case 'b':
					*ptr = '\b';
					break;
				case 'f':
					*ptr = '\f';
					break;
				case 'n':
					*ptr = '\n';
					break;
				case 'r':
					*ptr = '\r';
					break;
				case 't': 
					*ptr = '\t';
					break;
				case 'v':
					*ptr = '\v';
					break;
				default:
					*ptr = *str; // Just skip the backslash.
					break;
			}
		} else *ptr = *str;
		++ptr; ++str;
	}
	
	*ptr = '\0';
	res = realloc(res, strlen(res) + 1);
	return res;
}

int array_index(char *words[], int length, char *word)
{
	int i;
	for (i = 0; i < length; ++i) {
		if (strcmp(words[i], word) == 0)
			return i;
	}
	
	return -1;
}


int array_last_index(char *words[], int length, char *word)
{
	int i;
	for (i = length-1; 0 <= i; --i) {
		if (strcmp(words[i], word) == 0)
			return i;
	}
	
	return -1;
}

int array_copy(char *target[], char *source[], int size)
{
	int i;
	for (i = 0; i < size; ++i) {
		target[i] = value_malloc(NULL, strlen(source[i])+1);
		if (target[i] == NULL) return -1;
		strcpy(target[i], source[i]);
	}
	return 0;
}

int fatal_error()
{
	if (error_count == 1) {
		fprintf(stderr, "Build failed. At least 1 error found.\n");
		exit(1);
	} else if (error_count > 1) {
		fprintf(stderr, "Build failed. At least %d errors found.\n", error_count);
		exit(1);
	}
	
	return 0;
}

int handle_errors()
{
	if (error_count == 1) {
		fprintf(stderr, "Build failed. 1 error found.\n");
		exit(1);
	} else if (error_count > 1) {
		fprintf(stderr, "Build failed. %d errors found.\n", error_count);
		exit(1);
	} else fprintf(stderr, "Build succeeded.\n");
	
	return 0;
}

/* Returns the next power of 2. In the case in which x is already a power of 2, 
 * it will return x << 1. 0 returns 0.
 */
size_t next_power_of_2(size_t x)
{
	// This ORs x with every possible 1 bit up to its length, so every bit will 
	// be filled. Then it adds 1 which for instance turns 111 into 1000.
	x |= x >> 1;
	x |= x >> 2;
	x |= x >> 4;
	x |= x >> 8;
	x |= x >> 16;
	x |= x >> 32;
	return x;
}

size_t next_size(size_t x)
{
	return x < RESIZE_MIN ? RESIZE_MIN : next_power_of_2(x);
}

int is_power_of_2(size_t x)
{
	// Iff x is a power of 2, then x and (x-1) will share no digits. For instance, 
	// 1000 & 111 = 0.
	return !(x & (x - 1));	
}

int resize_p(size_t x)
{
	// Iff x is a power of 2, then x and (x-1) will share no digits. For instance, 
	// 1000 & 111 = 0. Do not resize unless x is greater than a certain minimum.
	return x == 0 || x >= RESIZE_MIN && !(x & (x - 1));	
}
/*
 *  tools.h
 *  Simfpl
 *
 *  Created by Michael Dickens on 1/9/10.
 *  
 *  Contains miscellaneous tools, such as an error function and some functions for 
 *  manipulating arrays of words. Also contains variables and functions that need 
 *  to be included into every file.
 */

#include "strmap.h"
#include "random.h"

#include "gmp-4.3.2/gmp.h"
#include "mpfr-3.0.0/mpfr.h"
//#include <gmp.h>
//#include <mpfr.h>

#ifndef CTYPE_H
#include <ctype.h>
#endif
#ifndef FLOAT_H
#include <float.h>
#endif
#ifndef LIMITS_H
#include <limits.h>
#endif
#ifndef MATH_H
#include <math.h>
#endif
#ifndef REGEX_H
#include <regex.h>
#endif
#ifndef STDARG_H
#include <stdarg.h>
#endif
#ifndef STDINT_H
#include <stdint.h>
#endif
#ifndef STDIO_H
#include <stdio.h>
#endif
#ifndef STDLIB_H
#include <stdlib.h>
#endif
#ifndef TIME_H
#include <time.h>
#endif


#define E_TYPE unsigned int


#define SMALLBUFSIZE 32
#define BUFSIZE 256
#define BIGBUFSIZE 1048576

#define FALSE 0
#define TRUE 1

#define streq(str1, str2) (strcmp((str1), (str2)) == 0)
#define strne(str1, str2) (strcmp((str1), (str2)) != 0)


#define string_to_number(string) value_set_str(string, 0)

struct value_array {
	struct value_struct *a;
	size_t length;
};

struct value_hash {
	struct value_struct *a;
	size_t length, occupied, size;
};

struct value_block {
	struct value_struct *a;
	size_t length;
	char *s;
};

struct value_stop {
	int type : 8;
	struct value_struct *core;
};

#define STOP_BREAK 0
#define STOP_CONTINUE 1
#define STOP_YIELD 2
#define STOP_RETURN 3
#define STOP_EXIT 4

/* 
 * Function specification.
 */
struct value_spec {
	int change_scope_p : 2;
	int needs_variables_p : 2;
	int keep_arg_p : 2;
	int delay_eval_p : 2;
	int argc;
	int optional; // Every argument after this one is optional.
	int rest_p : 2;
	char associativity;
	int precedence : 8;
	int not_stop_p : 2; // Internal. Used by iterators only.
};

#define NEEDS_UD_FUNCTIONS -1

struct value_bif {
	struct value_spec spec;
	struct value_struct (*f)(int argc, struct value_struct *argv);
};

typedef struct value_exception {
	struct value_exception *parent;
	char *name;
	char *description;
	struct value_struct *stack_trace; // Pointer to an array containing the stack trace.
} exception;

/* 
 * The definition for the value struct.
 */
typedef struct value_struct {
	int type : 8;
	union {
		int u_b;
		int u_nil;
		long u_z;
		double u_f;
		mpz_t u_mz;
		mpfr_t u_mf;
		char *u_s;
		char *u_x; // Regex.
		struct value_array u_a;
		struct value_struct *u_l;
		struct value_pair *u_p;
		struct value_hash u_h;
		struct value_struct *u_ptr;
		struct tree_struct *u_t;
		struct value_range *u_r;
		struct value_block u_blk;
		char *u_id;
		char *u_var;
		struct value_stop u_stop;
		struct value_spec u_spec;
		int u_type;
//		struct value_struct (*u_bif)(int argc, struct value_struct *argv);
		struct value_bif *u_bif;
		struct value_function *u_udf; // Contains a pointer to an ID with the name.
		struct value_exception u_exc;
	} core;
} value;

// These have to be defined after value_struct because they contain a value_struct.
struct value_range {
	int inclusive_p;
	struct value_struct min;
	struct value_struct max;
};

struct value_pair {
	struct value_struct head;
	struct value_struct tail;
};

struct value_function {
	char *name;
	struct value_spec spec;
	struct value_struct vars; // A block containing the variable names.
	struct value_struct body;
};

FILE *input_stream;
int print_interpreter_stuff;

// Is the file stream being read at the end of the file yet?
int is_eof;

int print_errors_p;
int error_count;
int linenum;

#define SAME_TYPE_VALUE 0
#define SAME_TYPE_TREE  1
int same_type_determiner;

/* 
 * Allocates (op) to be (size) blocks of memory. value_malloc() simply 
 * initializes the memory to NULL and makes a call to value_realloc(). 
 * value_realloc() uses op->type to determine how many bytes to allocate. 
 * (size) should be however many blocks of memory you want. If op->type 
 * is VALUE_STR and size is 10, enough memory will be allocated for a 
 * 10-character string (9 text and 1 null terminator).
 * 
 * Defined in value.c.
 */
void * value_malloc(value *op, size_t size);
void * value_realloc(value *op, size_t size);

/* 
 * Return Codes
 * 0: Success.
 * -1: ptr could not be freed.
 */
//int value_value_free(void *ptr);
#define value_free(ptr) free(ptr)

/* 
 * This function must be called for the other functions in tools.c to work.
 */
int init_tools();

int iscsymbol(char c);
#define isbracket(c) ((c) == '(' || (c) == ')' || (c) == '[' || (c) == ']' || (c) == '{' || (c) == '}')

int print_words(char *words[], int length);

int streq2(char *s, char *t);
int strne2(char *s, char *t);

/* 
 * Determines whether (str) is a string representation of a number. Returns 0 if not, 
 * returns 1 if (str) represents an integer, and returns 2 if (str) represents a 
 * float.
 */
int minus_isnumeric(char *str);
int isnumeric(char *str);

/* 
 * Determines whether (str) is a word -- that is, a letter followed by a series of 
 * letters or numbers.
 */
int isword(char *str);

int is_string_literal(char *str);
int is_regex_literal(char *str);

char * convert_to_literal(char *str);
char * convert_regex_to_literal(char *str);

/* 
 * Returns the first index of (word) in (words). If not found, returns -1.
 */
int array_index(char *words[], int length, char *word);

/* 
 * Returns the last index of (word) in (words). If not found, returns -1.
 */
int array_last_index(char *words[], int length, char *word);

/* 
 * Copies (source) into (target).
 */
int array_copy(char *target[], char *source[], int size);

/* 
 * Reports the number of errors found. If the error count is greater than 0, the program 
 * will exit.
 */ 
int fatal_error();
int handle_errors();

#define RESIZE_MIN 16

size_t next_power_of_2(size_t x);
size_t next_size(size_t x);
int is_power_of_2(size_t x);
int resize_p(size_t x);

/*
 *  value_dataset.c
 *  Simfpl
 *
 *  Created by Michael Dickens on 2/13/10.
 *
 */

#include "value.h"

/* 
 * Contains functions for manipulating arrays. Notice that all of 
 * these functions work on lists as well.
 */

/* 
 * Array Implementation
 * 
 * At any given time, the amount of memory allocated for the array is 
 * always a power of 2. This keeps insertion relatively efficient 
 * while also not using too much extra memory. Technically, it's 
 * always a power of 2 plus one, because of the extra element that 
 * represents the length. This implementation has not been tested 
 * very thoroughly, so there may be bugs.
 */

value block_array_cast(value op)
{
	if (op.type == VALUE_BLK) {
		value old_op = op;
		op.type = VALUE_ARY;
		op.core.u_a.length = old_op.core.u_blk.length;
		op.core.u_a.a = old_op.core.u_blk.a;
	}
	
	return op;
}

value value_set_ary(value array[], size_t length)
{
	if (length < 0)
		length = 0;
	value res;
	
	res.type = VALUE_ARY;
	value_malloc(&res, next_size(length));
	return_if_error(res);
	res.core.u_a.length = length;
	
	unsigned long i;
	for (i = 0; i < length; ++i)
		res.core.u_a.a[i] = value_set(array[i]);
	
	return res;
}

value value_set_ary_ref(value array[], size_t length)
{
	value res;
	
	res.type = VALUE_ARY;
	value_malloc(&res, next_size(length));
	return_if_error(res);
	res.core.u_a.length = length;
	
	memcpy(res.core.u_a.a, array, sizeof(value) * length);
	
	return res;
}

value value_set_ary_bool(int array[], size_t length)
{
	value res;
	
	res.type = VALUE_ARY;
	value_malloc(&res, next_size(length));
	return_if_error(res);
	res.core.u_a.length = length;
	
	unsigned long i;
	for (i = 0; i < length; ++i)
		res.core.u_a.a[i] = value_set_bool(array[i]);
	
	return res;
}

value value_set_ary_long(long array[], size_t length)
{
	value res;
	
	res.type = VALUE_ARY;
	value_malloc(&res, next_size(length));
	return_if_error(res);
	res.core.u_a.length = length;
	
	unsigned long i;
	for (i = 0; i < length; ++i)
		res.core.u_a.a[i] = value_set_long(array[i]);
	
	return res;
}

value value_set_ary_ulong(unsigned long array[], size_t length)
{
	value res;
	
	res.type = VALUE_ARY;
	value_malloc(&res, next_size(length));
	return_if_error(res);
	res.core.u_a.length = length;
	
	unsigned long i;
	for (i = 0; i < length; ++i)
		res.core.u_a.a[i] = value_set_ulong(array[i]);
	
	return res;
}

value value_set_ary_double(double array[], size_t length)
{
	value res;
	
	res.type = VALUE_ARY;
	value_malloc(&res, next_size(length));
	return_if_error(res);
	res.core.u_a.length = length;
	
	unsigned long i;
	for (i = 0; i < length; ++i)
		res.core.u_a.a[i] = value_set_double(array[i]);
	
	return res;
}

value value_set_ary_str(char *array[], size_t length)
{
	value res;
	
	res.type = VALUE_ARY;
	value_malloc(&res, next_size(length));
	return_if_error(res);
	res.core.u_a.length = length;
		
	unsigned long i;
	for (i = 0; i < length; ++i)
		res.core.u_a.a[i] = value_set_str(array[i]);
	
	return res;
}

value value_append(value op1, value op2)
{
	if (op1.type == VALUE_ARY) {
		size_t length = value_length(op1);
		
		value res;
		res.type = VALUE_ARY;
		value_malloc(&res, next_size(length+1) + 1);
		return_if_error(res);
		int i;
		for (i = 0; i < length; ++i)
			res.core.u_a.a[i] = value_set(op1.core.u_a.a[i]);
		res.core.u_a.length = op1.core.u_a.length + 1;
		res.core.u_a.a[length] = value_set(op2);
		
		return res;
	} else if (op1.type == VALUE_LST) {
		value res = value_init(VALUE_LST);
		value ptr = res;
		while (op1.type == VALUE_LST) {
			ptr.core.u_l[0] = value_set(op1.core.u_l[0]);
			op1 = op1.core.u_l[1];
			ptr = ptr.core.u_l[1] = value_init(VALUE_LST);
		}
		
		ptr.core.u_l[0] = value_set(op2);
		return res;
	} else if (op1.type == VALUE_PAR) {
		value res = value_init(VALUE_PAR);
		value ptr = res;
		while (op1.type == VALUE_PAR) {
			ptr.core.u_p->head = value_set(op1.core.u_p->head);
			op1 = op1.core.u_p->tail;
			ptr = ptr.core.u_p->tail = value_init(VALUE_PAR);
		}
		
		ptr.core.u_p->head = value_set(op2);
		return res;		
	}
	
	value_error(1, "Type Error: append() is undefined where op1 is %ts (array or list expected).", op1);
	return value_init_error();	
}

value value_append_now(value *op1, value op2)
{
	value set = value_set(op2);
	if (set.type == VALUE_ERROR)
		return set;
	return value_append_now2(op1, &set);
}

value value_append_now2(value *op1, value *op2)
{
	if (op1->type == VALUE_ARY) {
		size_t length = op1->core.u_a.length;
		if (resize_p(length)) {
			value_realloc(op1, next_size(length));
			return_if_error(*op1);
		}
		
		op1->core.u_a.a[length] = *op2;
		++op1->core.u_a.length;
		
	} else if (op1->type == VALUE_LST) {
		value ptr = *op1;
		while (!value_empty_p(ptr))
			ptr = ptr.core.u_l[1];
		ptr = value_init(VALUE_LST);
		ptr.core.u_l[0] = *op2;

	} else if (op1->type == VALUE_PAR) {
		value ptr = *op1;
		while (ptr.type == VALUE_PAR)
			ptr = ptr.core.u_p->tail;
		value_clear(&ptr);
		ptr = value_init(VALUE_PAR);
		ptr.core.u_l[0] = *op2;

	} else if (op1->type == VALUE_BLK) {
		size_t length = value_length(*op1);
		if (resize_p(length)) {
			value_realloc(op1, next_size(length));
			if (op1->type == VALUE_ERROR)
				return value_init_error();
		}
		
		op1->core.u_blk.a[length] = *op2;
		++op1->core.u_blk.length;
		
	} else {
		value_error(1, "Type Error: append() is undefined where op1 is %ts (array, list or block expected).", *op1);
		return value_init_error();
	}
	
	return value_init_nil();
}

value value_array_with_length(value op)
{
	value res = value_init_nil();
	
	if (op.type == VALUE_MPZ) {
		if (value_lt(op, value_zero)) {
			value_error(1, "Domain Error: array_with_length() is undefined where op is %s (greater than or equal to 0 expected).", op);
			return value_init_error();
		} else if (value_gt(op, value_int_max)) {
			value_error(1, "Domain error: array_with_length() is undefined where op is %s (less than %s expected).", op, value_int_max);
			return value_init_error();
		}
		
		res.type = VALUE_ARY;
		res.core.u_a.length = value_get_long(op);
		value_malloc(&res, next_size(res.core.u_a.length));
		return_if_error(res);
		memset(res.core.u_a.a, 0, sizeof(value) * res.core.u_a.length); // A value set to 0 will have type 0, which is VALUE_NIL.
		
	} else {
		value_error(1, "Type Error: array_with_length() is undefined where op is %ts (integer expected).", op);
		res = value_init_error();
	}
	
	return res;
}

value value_at(value op, value index, value more[], size_t length)
{
	value res = value_init_nil();
	
	if (index.type == VALUE_NIL)
		if (length)
			return value_at(op, more[0], more+1, length-1);
		else return value_set(op);
	
	if (op.type == VALUE_STR) {
		if (index.type == VALUE_MPZ) {
			value len = value_set_long(strlen(op.core.u_s));
			if (value_ge(index, len) || value_lt(index, value_zero)) {
				value_error(1, "Domain Error: in at(), index %s is beyond the bounds of string %s.", index, op);
				return value_init_error();
			}
			value_clear(&len);
			
			char str[2];
			str[0] = op.core.u_s[value_get_ulong(index)];
			str[1] = '\0';
			res = value_set_str(str);
			
		} else if (index.type == VALUE_RNG) {
			size_t i, start = (size_t) value_get_long(index.core.u_r->min);
			size_t finish = (size_t) value_get_long(index.core.u_r->max);
			
			char *str = value_malloc(NULL, finish - start + 1);
			return_if_null(str);
			if (index.core.u_r->inclusive_p)
				++finish;
			for (i = 0; start < finish; ++start, ++i)
				str[i] = op.core.u_s[start];
			str[i] = '\0';
			res.type = VALUE_STR;
			res.core.u_s = str;
		} else {
			value_error(1, "Type Error: at() is undefined where op is %ts and index is %ts (integer or range expected).", op, index);
			return value_init_error();
		}
				
	} else if (op.type == VALUE_ARY || op.type == VALUE_BLK) {
		value *ptr = op.type == VALUE_ARY ? op.core.u_a.a : op.core.u_blk.a;
		
		if (index.type == VALUE_MPZ) {
			long lindex = value_get_long(index);
			if (lindex >= value_length(op) || value_lt(index, value_zero) || value_gt(index, value_int_max)) {
				value_error(1, "Domain Error: in at(), index %s is beyond the bounds of array %s.", index, op);
				return value_init_error();
			}
			
			res = value_set(ptr[lindex]);
		
		} else if (index.type == VALUE_ARY) {
			size_t i, length = value_length(index);
			value ary[length];
			
			for (i = 0; i < length; ++i) {
				ary[i] = value_at(op, index.core.u_a.a[i], NULL, 0);
				if (ary[i].type == VALUE_ERROR)
					return ary[i];
			}
			
			res = value_set_ary_ref(ary, length);
		
		} else if (index.type == VALUE_RNG) {
			if (value_gt(index.core.u_r->min, index.core.u_r->max)) {
				value_error(1, "Domain Error: at() is undefined for range %ts where min is greater than max.", index);
				return value_init_error();
			}
			value diff = value_sub(index.core.u_r->max, index.core.u_r->min);
			size_t i, length = (size_t) value_get_long(diff), start = (size_t) value_get_long(index.core.u_r->min);
			value_clear(&diff);
			if (index.core.u_r->inclusive_p)
				++length;
			
			value ary[length];
			for (i = 0; i < length; ++i, ++start)
				ary[i] = value_set(ptr[start]);
			
			res = value_set_ary_ref(ary, length);
			
		} else {
			value_error(1, "Type Error: at() is undefined where op is %ts and index is %ts (integer, array, or range expected).", op, index);
			return value_init_error();
		}
		
		
	} else if (op.type == VALUE_LST) {
		if (index.type != VALUE_MPZ) {
			value_error(1, "Type Error: at() is undefined where op is %ts and index is %ts (integer expected).", op, index);
			return value_init_error();
		}
		
		if (value_gt(index, value_int_max) || value_lt(index, value_zero)) {
			value_error(1, "Domain Error: in at(), index %s is beyond the bounds of list %s.", index, op);
			return value_init_error();
		}
		
		long inx = value_get_long(index);
		
		value ptr = op;
		while (ptr.type != VALUE_NIL) {
			if (inx == 0) {
				res = value_set(ptr.core.u_l[0]);
				break;
			}
			ptr = ptr.core.u_l[1];
			--inx;
		}
		
		// res is nil because its value was never found, i.e. the given index was beyond the bounds of the list.
		if (res.type == VALUE_NIL) {
			value_error(1, "Domain Error: in at(), index %s is beyond the bounds of list %s.", index, op);
			return value_init_error();
		}
		
	} else if (op.type == VALUE_PAR) {
		if (index.type != VALUE_MPZ) {
			value_error(1, "Type Error: at() is undefined where op is a %ts and index is %ts (integer expected).", op, index);
			return value_init_error();
		}
		
		if (value_gt(index, value_int_max) || value_lt(index, value_zero)) {
			value_error(1, "Domain Error: in at(), index %s is beyond the bounds of list %s.", index, op);
			return value_init_error();
		}
		
		long inx = value_get_long(index);
		
		value ptr = op;
		while (ptr.type == VALUE_PAR) {
			if (inx == 0) {
				res = value_set(ptr.core.u_p->head);
				break;
			}
			ptr = ptr.core.u_p->tail;
			--inx;
		}
		
		// res is nil because its value was never found, i.e. the given index was beyond the bounds of the list.
		if (res.type == VALUE_NIL) {
			value_error(1, "Domain Error: in at(), index %s is beyond the bounds of list %s.", index, op);
			return value_init_error();
		}
		
	} else if (op.type == VALUE_HSH) {
		res = value_hash_get(op, index);
	
	} else {
		value_error(1, "Type Error: at() is undefined where op is %ts (string or container expected).", op);
		return value_init_error();
	}
	
	if (res.type == VALUE_ERROR)
		return res;
	
	if (length) {
		// (more) contains elements. Recursively call value_at() until there are no more elements.
		value real_res = value_at(res, more[0], more+1, length-1);
		value_clear(&res);
		return real_res;
	}
	
	return res;
}

value * value_at_ref(value op, value index, value more[], size_t length)
{
	if (index.type == VALUE_NIL)
		if (length)
			return value_at_ref(op, more[0], more+1, length-1);
		else return &op;
	
	if (op.type == VALUE_ARY) {
		if (index.type == VALUE_MPZ) {
			long lindex = value_get_long(index);
			if (lindex >= op.core.u_a.length || value_lt(index, value_zero) || value_gt(index, value_int_max)) {
				value_error(1, "Domain Error: in at_ref(), index %s is beyond the bounds of array %s.", index, op);
				return NULL;
			}
			
			if (length)
				return value_at_ref(op.core.u_a.a[lindex], more[0], more+1, length-1);
			else return &op.core.u_a.a[lindex];
					
		} else {
			value_error(1, "Type Error: at_ref() is undefined where op is %ts and index is %ts (integer expected).", op, index);
			return NULL;
		}
		
		
	} else if (op.type == VALUE_LST) {
		if (index.type != VALUE_MPZ) {
			value_error(1, "Type Error: at_ref() is undefined where op is %ts and index is %ts (integer expected).", op, index);
			return NULL;
		}
		
		if (value_gt(index, value_int_max) || value_lt(index, value_zero)) {
			value_error(1, "Domain Error: in at_ref(), index %s is beyond the bounds of list %s.", index, op);
			return NULL;
		}
		
		long inx = value_get_long(index);
		
		value ptr = op;
		while (ptr.type != VALUE_NIL) {
			if (inx == 0)
				if (length)
					return value_at_ref(ptr.core.u_l[0], more[0], more+1, length-1);
				else return &ptr.core.u_l[0];
			ptr = ptr.core.u_l[1];
			--inx;
		}
		
		value_error(1, "Domain Error: in at_ref(), index %s is beyond the bounds of list %s.", index, op);
		return NULL;
		
	} else if (op.type == VALUE_PAR) {
		if (index.type != VALUE_MPZ) {
			value_error(1, "Type Error: at_ref() is undefined where op is a list and index is %ts (integer expected).", index);
			return NULL;
		}
		
		if (value_gt(index, value_int_max) || value_lt(index, value_zero)) {
			value_error(1, "Domain Error: in at_ref(), index %s is beyond the bounds of list %s.", index, op);
			return NULL;
		}
		
		long inx = value_get_long(index);
		
		value ptr = op;
		while (ptr.type == VALUE_PAR) {
				if (length)
					return value_at_ref(ptr.core.u_p->head, more[0], more+1, length-1);
				else return &ptr.core.u_p->head;
			--inx;
		}
		
		value_error(1, "Domain Error: in at_ref(), the index %s is beyond the bounds of list %s.", index, op);
		return NULL;
		
	} else if (op.type == VALUE_HSH) {
		return value_hash_get_ref(op, index);
	} else {
		value_error(1, "Type Error: at_ref() is undefined where op is %ts (container expected).", op);
		return NULL;
	}
}

value value_at_assign_do(value *variables, value *op1, value index, value more[], size_t length, value func, value op2)
{
	value *modify;
	if (op1->type == VALUE_VAR) {
		value *data = value_hash_get_ref(*variables, *op1);
		if (data == NULL) {
			value_error(1, "Error: In at=(), undefined variable %s.", *op1);
			return value_init_error();
		}
		modify = value_at_ref(*data, index, more, length);
	} else {
		modify = value_at_ref(*op1, index, more, length);
	}

	if (modify && modify->type == VALUE_ERROR)
		return value_set(*modify);
	
	if (func.type != VALUE_NIL) {
		// Do at=, at+=, etc.
		
		if (modify == NULL) {
			value_error(1, "Error: In atf=(), value at index %s not found.", index);
			return value_init_error();
		}
		value ary[] = { *modify, op2 };
		value temp = value_call(variables, func, 2, ary);
		value_clear(modify);
		*modify = temp;
	} else {
		// Don't calculate a function, just find the value in op1. 
		
		if (modify == NULL) {
			modify = &op2;
			value_hash_put(op1, index, op2);
		} else {
			value_clear(modify);
			*modify = value_set(op2);
		}
	}
	
	if (modify->type == VALUE_ERROR) {
		return value_init_error();
	}

	return value_set(*modify);
}

value value_concat(value op1, value op2)
{
	value set1 = value_set(op1);
	value set2 = value_set(op2);
	value_concat_now2(&set1, &set2);
	return set1;
}

value value_concat_now(value *op1, value op2)
{
	value set = value_set(op2);
	if (set.type == VALUE_ERROR)
		return set;
	return value_concat_now2(op1, &set);
}

value value_concat_now2(value *op1, value *op2)
{
	value res = value_init_nil();
	
	if (op1->type == VALUE_NIL && op2->type == VALUE_LST) {
		*op1 = *op2;
		
	} else if (op1->type == VALUE_ARY) {

		if (op2->type == VALUE_ARY) {
			size_t len1 = value_length(*op1), 
				   len2 = value_length(*op2), 
				   length = len1 + len2;
			
			if (len2 == 0)
				return res;
			if (len1 == 0) {
				*op1 = *op2;
				return res;
			}
			
			value_realloc(op1, next_size(length));
			if (op1->type == VALUE_ERROR)
				return value_init_error();
				
			size_t i;
			for (i = 0; i < len2; ++i)
				op1->core.u_a.a[i+len1] = op2->core.u_a.a[i];
			
			op1->core.u_a.length = length;
		} else {
			size_t length = value_length(*op1);
			if (resize_p(length+1)) {
				value_realloc(op1, next_size(length+1));
				if (op1->type == VALUE_ERROR)
					return value_init_error();
			}
			op1->core.u_a.a[length] = *op2;
			++op1->core.u_a.length;
		}

		
	} else if (op1->type == VALUE_LST) {
		if (op2->type == VALUE_NIL || op2->type == VALUE_LST) {
			value ptr = *op1;
			
			while (ptr.core.u_l[1].type == VALUE_LST)
				ptr = ptr.core.u_l[1];
			ptr.core.u_l[1] = *op2;
		} else {
			value_cons_now2(op1, op2);
			*op1 = *op2;
		}

	} else if (op1->type == VALUE_PAR) {
		value *ptr = op1;
		
		while (ptr->type == VALUE_PAR)
			ptr = &ptr->core.u_p->tail;
		*ptr = *op2;
	
	} else {
		value_error(1, "Type Error: concat() is undefined where op1 is %ts (array or list expected).", *op1);
		res = value_init_error();
	}	

	return res;
}

value value_delete(value op1, value op2)
{
	if (op1.type == VALUE_ARY) {
		size_t length = value_length(op1);
		value arr[length];
		
		size_t i, j;
		int are_none_deleted = TRUE;
		for (i = 0, j = 0; i < length; ++i)
			if (are_none_deleted && value_eq(op1.core.u_a.a[i], op2))
				are_none_deleted = FALSE;
			else
				arr[j++] = value_set(op1.core.u_a.a[i]);
		
		return value_set_ary_ref(arr, j);
	} else if (op1.type == VALUE_LST) {
		value ptr = op1;
		value res = value_init(VALUE_LST);
		value resptr = res;
		value *clrptr = &res;
		int are_none_deleted = TRUE;
		while (ptr.type == VALUE_LST) {
			if (are_none_deleted && value_eq(ptr.core.u_l[0], op2))
				are_none_deleted = FALSE;
			else {
				resptr.core.u_l[0] = value_set(ptr.core.u_l[0]);
				resptr.core.u_l[1] = value_init(VALUE_LST);
				clrptr = &resptr.core.u_l[1];
				resptr = resptr.core.u_l[1];
			}
			ptr = ptr.core.u_l[1];
		}
		
		value_clear(clrptr);
				
		return res;
	} else {
		value_error(1, "Type Error: delete() is undefined where op1 is %ts (array or list expected).", op1);
		return value_init_error();
	}
}

value value_delete_now(value *op1, value op2)
{
	if (op1->type == VALUE_ARY) {
		size_t length = value_length(*op1);
		size_t i;
		for (i = 0; i < length; ++i)
			if (value_eq(op1->core.u_a.a[i], op2)) {
				value vi = value_set_long(i-1);
				value clr = value_delete_at_now(op1, vi);
				value_clear(&vi);
				value_clear(&clr);
				return value_set_bool(TRUE);
			}

		return value_set_bool(FALSE);
	} else if (op1->type == VALUE_LST) {
		value *ptr = op1;
		while (!value_empty_p(*ptr)) {
			if (value_eq(ptr->core.u_l[0], op2)) {
				value_clear(&ptr->core.u_l[0]);
				*ptr = ptr->core.u_l[1];
				break;
			}
			
			ptr = &ptr->core.u_l[1];
		}
		
		return value_set_bool(FALSE);
	}
	
	value_error(1, "Type Error: delete() is undefined where op1 is %ts (array or list expected).", *op1);
	return value_init_error();
}

value value_delete_all(value op1, value op2)
{
	if (op1.type == VALUE_ARY) {
		size_t length = value_length(op1);
		value arr[length];
		
		size_t i, j;
		for (i = 0, j = 0; i < length; ++i)
			if (value_eq(op1.core.u_a.a[i], op2))
				;
			else
				// Because this is a direct assignment, arr does not need 
				// to be cleared later on.
				arr[j++] = op1.core.u_a.a[i];
		
		return value_set_ary(arr, j);
	} else if (op1.type == VALUE_LST) {
		value ptr = op1;
		value res = value_init(VALUE_LST);
		value resptr = res;
		value *clrptr = &res;
		while (!value_empty_p(ptr)) {
			if (value_eq(ptr.core.u_l[0], op2))
				;
			else {
				resptr.core.u_l[0] = value_set(ptr.core.u_l[0]);
				resptr.core.u_l[1] = value_init(VALUE_LST);
				clrptr = &resptr.core.u_l[1];
				resptr = resptr.core.u_l[1];
			}
			ptr = ptr.core.u_l[1];
		}
		
		value_clear(clrptr);

		return res;
	} else {
		value_error(1, "Type Error: delete_all() is undefined where op1 is %ts (array or list expected).", op1);
		return value_init_error();
	}
}

/* 
 * Could use two different methods. First, it could delete each element individually; 
 * this is fast for only deleting a small number of elements, but is O(n^2) to delete 
 * every element. The second method is to move each element into a new array; this is 
 * linearly slower, but is still O(n). This is the method that is used.
 */
value value_delete_all_now(value *op1, value op2)
{
	if (op1->type == VALUE_ARY) {
		int count = 0;
		
		size_t length = value_length(*op1);
		
		size_t i, j;
		for (i = 0, j = 0; i < length; ++i) {
			value temp = value_set(op1->core.u_a.a[i]);
			if (temp.type == VALUE_ERROR)
				return temp;
			value_clear(&(op1->core.u_a.a[j]));
			op1->core.u_a.a[j] = value_set(temp);
			if (op1->core.u_a.a[j].type == VALUE_ERROR)
				return value_init_error();
			value_clear(&temp);
		
			if (value_ne(op1->core.u_a.a[i], op2))
				++j;
		}
		
		op1->core.u_a.length = j - 1;
		
		while (j < i)
			value_clear(&(op1->core.u_a.a[j++]));
		
	} else if (op1->type == VALUE_LST) {
		value *ptr = op1;
		while (!value_empty_p(*ptr)) {
			if (value_eq(ptr->core.u_l[0], op2)) {
				value_clear(&ptr->core.u_l[0]);
				*ptr = ptr->core.u_l[1];
			} else ptr = &ptr->core.u_l[1];
		}
			
	} else {
		value_error(1, "Type Error: delete_all() is undefined where op1 is %ts (array expected).", *op1);
		return value_init_error();
	}
	
	return value_init_nil();
}

value value_delete_at(value op, value index)
{
	if (op.type == VALUE_ARY) {
		if (index.type != VALUE_MPZ) {
			value_error(1, "Type Error: delete_at() is undefined where index is %ts (integer expected).", index);
			return value_init_error();
		}
		
		long lindex = value_get_long(index);
		if (lindex >= op.core.u_a.length || value_lt(index, value_zero) || value_ge(index, value_int_max)) {
			value_error(1, "Argument Error: in delete_at(), index %s is out of bounds of the array.", index);
			return value_init_error();
		}
				
		size_t length = value_length(op);
		value arr[length];
		
		size_t i;
		for (i = 0; i < lindex; ++i)
			arr[i] = value_set(op.core.u_a.a[i]);
		for (i = lindex+1; i < length; ++i)
			arr[i-1] = value_set(op.core.u_a.a[i]);
				
		return value_set_ary_ref(arr, length-1);
	} else {
		value res = value_set(op);
		value clr = value_delete_at_now(&res, index);
		value_clear(&clr);
		return res;
	}
}

value value_delete_at_now(value *op, value index)
{	
	if (op->type == VALUE_ARY) {
		if (index.type != VALUE_MPZ) {
			value_error(1, "Type Error: delete_at() is undefined where index is %ts (integer expected).", index);
			return value_init_error();
		}
		
		long lindex = value_get_long(index);
		
		if (lindex >= op->core.u_a.length || value_lt(index, value_zero) || value_gt(index, value_int_max)) {
			value_error(1, "Argument Error: in delete_at(), index %s is out of bounds of the array.", index);
			return value_init_error();
		}
		
		value res = op->core.u_a.a[lindex];
		
		size_t length = op->core.u_a.length - 1;
		
		// Remove (res) from the array by taking it out of the block of memory. This memmove() call might be 
		// a little obscure, but the speed makes it worth it, especially when you're deleting an element from 
		// near the beginning of a very long array.
		memmove((void *) (op->core.u_a.a + lindex), (void *) (op->core.u_a.a + lindex + 1), sizeof(value) * (length - lindex + 1));
		
		if (resize_p(length))
			value_realloc(op, next_size(length));
		
		--op->core.u_a.length;
				
		return res;
	
	} else if (op->type == VALUE_HSH) {
		
		return value_hash_delete_at(op, index);
		
	} else {
		value_error(1, "Type Error: delete_at() is undefined where op is %ts (array or hash expected).", *op);
	}
	
	return value_init_error();
}

value value_each(value *variables, value op, value func)
{
	value res = value_init_nil();
	if (op.type == VALUE_ARY) {
		size_t i;
		for (i = 0; i < op.core.u_a.length; ++i) {
			value tmp = value_call(variables, func, 1, op.core.u_a.a + i);
			if (tmp.type == VALUE_STOP && tmp.core.u_stop.type == STOP_BREAK) {
				break;
			} else if (tmp.type == VALUE_STOP && tmp.core.u_stop.type == STOP_YIELD) {
				if (res.type == VALUE_NIL) res = value_init(VALUE_ARY);
				value_append_now(&res, *tmp.core.u_stop.core);
			} else if (tmp.type == VALUE_ERROR || tmp.type == VALUE_STOP && (tmp.core.u_stop.type == STOP_RETURN || tmp.core.u_stop.type == STOP_EXIT)) {
				value_clear(&res);
				res = tmp;
				break;
			}
			value_clear(&tmp);
		}
		
	} else if (op.type == VALUE_LST) {	
		value optr = op;
		while (optr.type == VALUE_LST) {
			value tmp = value_call(variables, func, 1, optr.core.u_l + 0);
			if (tmp.type == VALUE_STOP && tmp.core.u_stop.type == STOP_BREAK) {
				break;
			} else if (tmp.type == VALUE_STOP && tmp.core.u_stop.type == STOP_YIELD) {
				if (res.type == VALUE_NIL) res = value_init(VALUE_ARY);
				value_append_now(&res, *tmp.core.u_stop.core);
			} else if (tmp.type == VALUE_ERROR || tmp.type == VALUE_STOP && (tmp.core.u_stop.type == STOP_RETURN || tmp.core.u_stop.type == STOP_EXIT)) {
				value_clear(&res);
				res = tmp;
				break;
			}
			value_clear(&tmp);
			
			optr = optr.core.u_l[1];
		}
	
	} else if (op.type == VALUE_HSH) {
		size_t i, j;
		for (i = 0; i < op.core.u_h.length; ++i) {
			if (op.core.u_h.a[i].type == VALUE_ARY) {
				value bucket = op.core.u_h.a[i];
				for (j = 0; j < bucket.core.u_a.length; ++j) {
					if (bucket.core.u_a.a[j].type != VALUE_ARY || bucket.core.u_a.a[j].core.u_a.length != 2)
						continue;
					value tmp = value_call(variables, func, 2, bucket.core.u_a.a[j].core.u_a.a + 0);
					if (tmp.type == VALUE_STOP && tmp.core.u_stop.type == STOP_BREAK) {
						break;
					} else if (tmp.type == VALUE_STOP && tmp.core.u_stop.type == STOP_YIELD) {
						if (res.type == VALUE_NIL) res = value_init(VALUE_ARY);
						value_append_now(&res, *tmp.core.u_stop.core);
					} else if (tmp.type == VALUE_ERROR || tmp.type == VALUE_STOP && (tmp.core.u_stop.type == STOP_RETURN || tmp.core.u_stop.type == STOP_EXIT)) {
						value_clear(&res);
						res = tmp;
						break;
					}
					value_clear(&tmp);
				}
			}
		}
		
	} else if (op.type == VALUE_RNG) {
		if (value_eq(op.core.u_r->min, op.core.u_r->max))
			return res;
		value min = value_set(op.core.u_r->min);
		value max = value_set(op.core.u_r->max);
		int reversed_p = value_gt(min, max);
		if (op.core.u_r->inclusive_p)
			if (reversed_p)
				value_dec_now(&max);
			else value_inc_now(&max);
		
		for (; reversed_p ? value_gt(min, max) : value_lt(min, max); reversed_p ? value_dec_now(&min) : value_inc_now(&min)) {
			value tmp = value_call(variables, func, 1, &min);
			
			if (tmp.type == VALUE_STOP && tmp.core.u_stop.type == STOP_BREAK) {
				break;
			} else if (tmp.type == VALUE_STOP && tmp.core.u_stop.type == STOP_YIELD) {
				if (res.type == VALUE_NIL) res = value_init(VALUE_ARY);
				value_append_now(&res, *tmp.core.u_stop.core);
			} else if (tmp.type == VALUE_ERROR || tmp.type == VALUE_STOP && (tmp.core.u_stop.type == STOP_RETURN || tmp.core.u_stop.type == STOP_EXIT)) {
				value_clear(&res);
				res = tmp;
				break;
			}
			value_clear(&tmp);
		}
		
		value_clear(&min);
		value_clear(&max);
		
	} else {
		value_error(1, "Type Error: each() is undefined where op is %ts (iterable expected).", op);
		res = value_init_error();
	}
		
	return res;
}

value value_each_index(value *variables, value op, value func)
{
	value res = value_init_nil();
	if (op.type == VALUE_ARY || op.type == VALUE_LST) {
		value ei_length = value_length_std(op);
		if (ei_length.type == VALUE_ERROR) return ei_length;
		value range = value_range_until(value_zero, ei_length);
		value_clear(&ei_length);
		if (range.type == VALUE_ERROR) return range;
		
		res = value_each(variables, range, func);
		value_clear(&range);
		
	} else {
		value_error(1, "Type Error: each_index() is undefined where op is %ts (linear container expected).", op);
		res = value_init_error();
	}
	
	return res;
}

int value_empty_p(value op)
{
	if (op.type == VALUE_NIL) {
		return TRUE;
	} else if (op.type == VALUE_STR) {
		return *op.core.u_s == '\0';
	} else if (op.type == VALUE_ARY) {
		return value_length(op) == 0;
	} else if (op.type == VALUE_LST) {
		return FALSE;
	} else if (op.type == VALUE_HSH) {
		return value_hash_size(op) == 0;
	} else {
		value_error(1, "Type Error: empty?() is undefined where op is %ts (string, array, list or hash expected).", op);
		return VALUE_ERROR;
	}
}

value value_empty_p_std(value op)
{
	int b = value_empty_p(op);
	if (b == VALUE_ERROR)
		return value_init_error();
	return value_set_bool(b);
}

value value_filter(value *variables, value op, value func)
{
	value res = value_init_nil();
	if (op.type == VALUE_ARY) {
		res = value_init(VALUE_ARY);
		size_t i;
		for (i = 0; i < op.core.u_a.length; ++i) {
			value cond = value_call(variables, func, 1, op.core.u_a.a + i);
			if (cond.type == VALUE_ERROR || cond.type == VALUE_STOP && (cond.core.u_stop.type == STOP_RETURN || cond.core.u_stop.type == STOP_EXIT)) {
				value_clear(&res);
				return cond;
			}
			if (value_true_p(cond))
				value_append_now(&res, op.core.u_a.a[i]);
			value_clear(&cond);
		}
	
	} else if (op.type == VALUE_LST) {
		res = value_init(VALUE_LST);
		value rptr = res;
		value optr = op;
		
		while (TRUE) {
			value cond = value_call(variables, func, 1, optr.core.u_l + 0);
			if (cond.type == VALUE_ERROR || cond.type == VALUE_STOP && (cond.core.u_stop.type == STOP_RETURN || cond.core.u_stop.type == STOP_EXIT)) {
				value_clear(&res);
				return cond;
			}
			int make_new_p = FALSE;
			if (value_true_p(cond)) {
				rptr.core.u_l[0] = value_set(optr.core.u_l[0]);
				make_new_p = TRUE;
			}
			
			optr = optr.core.u_l[1];
			if (optr.type != VALUE_LST) break;
			if (make_new_p) rptr = rptr.core.u_l[1] = value_init(VALUE_LST);
		}
		
	} else if (op.type == VALUE_RNG) {
		value temp = value_cast(op, VALUE_ARY);
		res = value_filter(variables, temp, func);
		value_clear(&temp);
		
	} else {
		value_error(1, "Type Error: filter() is undefined where op is %ts (linear container expected).", op);
		res = value_init_error();
	}
	
	return res;
}

value value_filter_f(value op, int (*f)(value))
{
	if (op.type == VALUE_ARY) {
		size_t oplen = value_length(op);
		value res[oplen];
		size_t i, length = 0;
		for (i = 0; i < oplen; ++i)
			if ((*f)(op.core.u_a.a[i]))
				// These will both point to the same value, but that's okay 
				// because all the values are copied at the end of filter().
				res[length++] = op.core.u_a.a[i];
		
		return value_set_ary(res, length);
	} else if (op.type == VALUE_LST) {
		value res = value_init(VALUE_LST);
		value ptr = res;
		value temp;
		while (op.type != VALUE_NIL) {
			temp = value_set(op.core.u_l[0]);
			if ((*f)(temp)) {
				ptr = value_init(VALUE_LST);
				ptr.core.u_l[0] = value_set(op.core.u_l[0]);
				ptr = ptr.core.u_l[1] = value_init_nil();
			}
			value_clear(&temp);
			op = op.core.u_l[1];
		}
		
		return res;
		
	}
	
	value_error(1, "Type Error: filter() is undefined where op is %ts (array or list expected).", op);
	return value_init_error();
}

value value_find(value *variables, value op, value func)
{
	value res = value_init_nil();
	if (op.type == VALUE_ARY) {
		size_t i;
		for (i = 0; i < op.core.u_a.length; ++i) {
			value tmp = value_call(variables, func, 1, op.core.u_a.a + i);
			if (tmp.type == VALUE_ERROR || tmp.type == VALUE_STOP && (tmp.core.u_stop.type == STOP_RETURN || tmp.core.u_stop.type == STOP_EXIT)) {
				value_clear(&res);
				res = tmp;
				break;
			} else if (value_true_p(tmp)) {
				value_clear(&tmp);
				return value_set(op.core.u_a.a[i]);
			}
			value_clear(&tmp);
		}
		
	} else if (op.type == VALUE_LST) {	
		value optr = op;
		while (optr.type == VALUE_LST) {
			value tmp = value_call(variables, func, 1, optr.core.u_l + 0);
			if (tmp.type == VALUE_ERROR || tmp.type == VALUE_STOP && (tmp.core.u_stop.type == STOP_RETURN || tmp.core.u_stop.type == STOP_EXIT)) {
				value_clear(&res);
				res = tmp;
				break;
			} else if (value_true_p(tmp)) {
				value_clear(&tmp);
				return value_set(optr.core.u_l[0]);
			}
			value_clear(&tmp);
			
			optr = optr.core.u_l[1];
		}
	
	} else if (op.type == VALUE_HSH) {
		size_t i, j;
		for (i = 0; i < op.core.u_h.length; ++i) {
			if (op.core.u_h.a[i].type == VALUE_ARY) {
				value bucket = op.core.u_h.a[i];
				for (j = 0; j < bucket.core.u_a.length; ++j) {
					if (bucket.core.u_a.a[j].type != VALUE_ARY || bucket.core.u_a.a[j].core.u_a.length != 2)
						continue;
					value tmp = value_call(variables, func, 2, bucket.core.u_a.a[j].core.u_a.a + 0);
					if (tmp.type == VALUE_ERROR || tmp.type == VALUE_STOP && (tmp.core.u_stop.type == STOP_RETURN || tmp.core.u_stop.type == STOP_EXIT)) {
						value_clear(&res);
						res = tmp;
						break;
					} else if (value_true_p(tmp)) {
						value_clear(&tmp);
						return value_set(bucket.core.u_a.a[j]);
					}
					value_clear(&tmp);
				}
			}
		}
		
	} else if (op.type == VALUE_RNG) {
		if (value_eq(op.core.u_r->min, op.core.u_r->max))
			return res;
		value min = value_set(op.core.u_r->min);
		value max = value_set(op.core.u_r->max);
		int reversed_p = value_gt(min, max);
		if (op.core.u_r->inclusive_p)
			if (reversed_p)
				value_dec_now(&max);
			else value_inc_now(&max);
		
		for (; reversed_p ? value_gt(min, max) : value_lt(min, max); reversed_p ? value_dec_now(&min) : value_inc_now(&min)) {
			value tmp = value_call(variables, func, 1, &min);
			if (tmp.type == VALUE_ERROR || tmp.type == VALUE_STOP && (tmp.core.u_stop.type == STOP_RETURN || tmp.core.u_stop.type == STOP_EXIT)) {
				value_clear(&res);
				res = tmp;
				break;
			} else if (value_true_p(tmp)) {
				value_clear(&tmp);
				value_clear(&max);
				return min;
			}
			value_clear(&tmp);
		}
		
		value_clear(&min);
		value_clear(&max);
		
	} else {
		value_error(1, "Type Error: filter() is undefined where op is %ts (iterable expected).", op);
		res = value_init_error();
	}
		
	return res;
}

value value_flatten(value op)
{
	if (op.type == VALUE_ARY) {
		value res = value_set(op);
		size_t total_length = value_private_total_length(res);
		value array[total_length];
		value_private_flatten_recursive(array, res, 0);
		value_clear(&res);
		res = value_set_ary(array, total_length);
		size_t i;
		for (i = 0; i < total_length; ++i)
			value_clear(&array[i]);
		return res;
	} else if (op.type == VALUE_LST) {
		if (value_empty_p(op))
			return op;
		if (op.core.u_l[0].type == VALUE_LST) {
			value res = value_flatten(op.core.u_l[0]);
			value tmp = value_flatten(op.core.u_l[1]);
			value_concat_now(&res, tmp);
			value_clear(&tmp);
			return res;
		} else {
			value res = value_flatten(op.core.u_l[1]);
			value_cons_now(op.core.u_l[0], &res);
			return res;
		}
	}
	
	// This is used for a list's recursive definition. 
	return value_set(op);
}

value value_flatten_now(value *op)
{
	value res = value_flatten(*op);
	if (res.type == VALUE_ERROR)
		return res;
	value_clear(op);
	*op = res;
	return value_init_nil();
}

/* WARNING: This function will MODIFY the contents of (op). If you do not want 
 * its contents to be modified, be sure to make a copy.
 */
size_t value_private_flatten_recursive(value array[], value op, size_t index)
{
	if (op.type == VALUE_ARY) {
		size_t length = value_length(op);
		size_t i;
		for (i = 0; i < length; ++i)
			index = value_private_flatten_recursive(array, op.core.u_a.a[i], index);
		
	} else {
		array[index++] = value_set(op);
	}
	
	return index;
}

size_t value_private_total_length(value op)
{
	if (op.type == VALUE_ARY) {
		size_t tlen = value_length(op);
		size_t i, length = 0;
		for (i = 0; i < tlen; ++i) {
			if (op.core.u_a.a[i].type == VALUE_ARY)
				length += value_private_total_length(op.core.u_a.a[i]);
			else ++length;
		}
		return length;
	} else return 1;
}

value value_fold(value *variables, value op, value initial, value func)
{
	value ary[] = { initial, value_init_nil() };
	
	if (op.type == VALUE_ARY) {
		size_t i;
		for (i = 0; i < op.core.u_a.length; ++i) {
			ary[1] = op.core.u_a.a[i];
			ary[0] = value_call(variables, func, 2, ary);
			if (ary[0].type == VALUE_ERROR || ary[0].type == VALUE_STOP && (ary[0].core.u_stop.type == STOP_RETURN || ary[0].core.u_stop.type == STOP_EXIT))
				break;
		}
		
	} else if (op.type == VALUE_LST) {	
		value optr = op;
		while (optr.type == VALUE_LST) {
			ary[1] = optr.core.u_l[0];
			ary[0] = value_call(variables, func, 2, ary);			
			if (ary[0].type == VALUE_ERROR || ary[0].type == VALUE_STOP && (ary[0].core.u_stop.type == STOP_RETURN || ary[0].core.u_stop.type == STOP_EXIT))
				break;
			optr = optr.core.u_l[1];
		}
	
	} else if (op.type == VALUE_HSH) {
		size_t i, j;
		for (i = 0; i < op.core.u_h.length; ++i) {
			if (op.core.u_h.a[i].type == VALUE_ARY) {
				value bucket = op.core.u_h.a[i];
				for (j = 0; j < bucket.core.u_a.length; ++j) {
					if (bucket.core.u_a.a[j].type != VALUE_ARY || bucket.core.u_a.a[j].core.u_a.length != 2)
						continue;
					ary[1] = bucket.core.u_a.a[j].core.u_a.a[0];
					ary[0] = value_call(variables, func, 2, ary);
					if (ary[0].type == VALUE_ERROR || ary[0].type == VALUE_STOP && (ary[0].core.u_stop.type == STOP_RETURN || ary[0].core.u_stop.type == STOP_EXIT))
						break;
				}
			}
			if (ary[0].type == VALUE_ERROR || ary[0].type == VALUE_STOP && (ary[0].core.u_stop.type == STOP_RETURN || ary[0].core.u_stop.type == STOP_EXIT))
				break;
		}
				
	} else if (op.type == VALUE_RNG) {
		if (value_eq(op.core.u_r->min, op.core.u_r->max))
			return ary[0];
		ary[1] = value_set(op.core.u_r->min);
		value max = value_set(op.core.u_r->max);
		int reversed_p = value_gt(ary[1], max);
		if (op.core.u_r->inclusive_p)
			if (reversed_p)
				value_dec_now(&max);
			else value_inc_now(&max);
		
		for (; reversed_p ? value_gt(ary[1], max) : value_lt(ary[1], max); reversed_p ? value_dec_now(&ary[1]) : value_inc_now(&ary[1])) {
			ary[0] = value_call(variables, func, 2, ary);		
			if (ary[0].type == VALUE_ERROR || ary[0].type == VALUE_STOP && (ary[0].core.u_stop.type == STOP_RETURN || ary[0].core.u_stop.type == STOP_EXIT))
				break;
		}
		
		value_clear(&ary[1]);
		value_clear(&max);
		
	} else {
		value_error(1, "Type Error: fold() is undefined where op is %ts (iterable expected).", op);
		ary[0] = value_init_error();
	}
		
	return ary[0];
}

value value_join(value op1, value op2)
{
	if (op1.type == VALUE_ARY) {
		if (op2.type != VALUE_STR) {
			value_error(1, "Type Error: join() is undefined where op2 is %ts (string expected).", op2);
			return value_init_error();
		}
		
		size_t length = value_length(op1);
		if (length == 0)
			return value_set_str("");
		
		value res = value_cast(op1.core.u_a.a[0], VALUE_STR);
		size_t i;
		for (i = 1; i < length; ++i) {
			value_add_now(&res, op2);
			value cast = value_cast(op1.core.u_a.a[i], VALUE_STR);
			value_add_now(&res, cast);
			value_clear(&cast);
		}
		
		return res;
	} else if (op1.type == VALUE_LST) {
		if (op2.type != VALUE_STR) {
			value_error(1, "Type Error: join() is undefined where op2 is %ts (string expected).", op2);
			return value_init_error();
		}
		
		if (value_empty_p(op1))
			return value_set_str("");
		
		value res = value_cast(op1.core.u_l[0], VALUE_STR);
		op1 = op1.core.u_l[1];
		while (!value_empty_p(op1)) {
			value_add_now(&res, op2);
			value cast = value_cast(op1.core.u_l[0], VALUE_STR);
			value_add_now(&res, cast);
			value_clear(&cast);
			op1 = op1.core.u_l[1];
		}
		
		return res;
	} else if (op1.type == VALUE_RNG) {
		value ary = value_cast(op1, VALUE_ARY);
		value res = value_join(ary, op2);
		value_clear(&ary);
		return res;
	}
	
	value_error(1, "Type Error: join() is undefined where op1 is %ts (iterable expected).", op1);
	
	if (op2.type != VALUE_STR)
		value_error(1, "Type Error: join() is undefined where op2 is %ts (string expected).", op2);
	
	return value_init_error();
}

value value_last(value op)
{
	if (op.type == VALUE_NIL) {
		return value_init_nil();
	} else if (op.type == VALUE_ARY) {
		size_t length = value_length(op);
		
		if (length > 0)
			return value_set(op.core.u_a.a[length-1]);
		else return value_init_nil();
	} else if (op.type == VALUE_LST) {
		value ptr = op;
		while (ptr.core.u_l[1].type == VALUE_LST)
			ptr = ptr.core.u_l[1];
		return value_set(ptr.core.u_l[0]);
	} else {
		value_error(1, "Type Error: last() is undefined where op is %ts (array or list expected).", op);
		return value_init_error();
	}

}

value value_map(value *variables, value op, value func)
{
	value res = value_init_nil();
	if (op.type == VALUE_ARY) {
		res.type = VALUE_ARY;
		value_malloc(&res, op.core.u_a.length);
		return_if_error(res);
		res.core.u_a.length = op.core.u_a.length;
		
		size_t i;
		for (i = 0; i < op.core.u_a.length; ++i) {
			res.core.u_a.a[i] = value_call(variables, func, 1, op.core.u_a.a + i);
			if (res.core.u_a.a[i].type == VALUE_STOP && res.core.u_a.a[0].core.u_stop.type == STOP_BREAK) {
				value_clear(&res.core.u_a.a[i]);
				res.core.u_a.length = i;
				value_realloc(&res, next_size(res.core.u_a.length));
				return_if_error(res);
				break;
			} else if (res.core.u_a.a[i].type == VALUE_ERROR || res.core.u_a.a[i].type == VALUE_STOP && 
					(res.core.u_a.a[i].core.u_stop.type == STOP_RETURN || res.core.u_a.a[i].core.u_stop.type == STOP_EXIT))
				return res.core.u_a.a[i];
		}
				
	} else if (op.type == VALUE_LST) {
		res = value_init(VALUE_LST);
		value optr = op;
		value rptr = res;
		while (TRUE) {
			rptr.core.u_l[0] = value_call(variables, func, 1, optr.core.u_l + 0);
			if (rptr.core.u_l[0].type == VALUE_STOP && rptr.core.u_l[0].core.u_stop.type == STOP_BREAK) {
				value_clear(&rptr);
				break;
			} else if (rptr.core.u_l[0].type == VALUE_ERROR || rptr.core.u_l[0].type == VALUE_STOP && 
				(rptr.core.u_l[0].core.u_stop.type == STOP_RETURN || rptr.core.u_l[0].core.u_stop.type == STOP_EXIT))
				return rptr.core.u_l[0];
			optr = optr.core.u_l[1];
			if (optr.type != VALUE_LST) break;
			rptr = rptr.core.u_l[1] = value_init(VALUE_LST);
		}
	
	} else if (op.type == VALUE_HSH) {
		res = value_init(VALUE_HSH);
		
		size_t i, j;
		for (i = 0; i < op.core.u_h.length; ++i) {
			if (op.core.u_h.a[i].type == VALUE_ARY) {
				value bucket = op.core.u_h.a[i];
				for (j = 0; j < bucket.core.u_a.length; ++j) {
					if (bucket.core.u_a.a[j].type != VALUE_ARY || bucket.core.u_a.a[j].core.u_a.length != 2)
						continue;
					value pair = value_call(variables, func, 2, bucket.core.u_a.a[j].core.u_a.a + 0);
					if (pair.type == VALUE_STOP && pair.core.u_stop.type == STOP_BREAK) {
						value_clear(&pair);
						break;
					} else if (pair.type == VALUE_ERROR) {
						value_clear(&res);
						return pair;
					}
					if (pair.type != VALUE_ARY || pair.core.u_a.length != 2) {
						value_error(1, "Error: For hashes, each iteration of map() must return a two-element array (%ts returned instead).", pair);
						value_clear(&res);
						return value_init_error();
					}
					
					value_hash_put(&res, pair.core.u_a.a[0], pair.core.u_a.a[1]);
					value_clear(&pair);
				}
			}
		}
		
	} else if (op.type == VALUE_RNG) {
		value ary = value_cast(op, VALUE_ARY);
		if (ary.type == VALUE_ERROR) return ary;
		res = value_map(variables, ary, func);
		value_clear(&ary);
		
	} else {
		value_error(1, "Type Error: map() is undefined where op is %ts (iterable expected).", op);
		res = value_init_error();
	}
	
	return res;
}

/* 
 * This is a slow implementation, because it requires copying the container. It 
 * would be better to perform a map in place.
 */
value value_map_now(value *variables, value *op, value func)
{
	value res = value_map(variables, *op, func);
	if (res.type == VALUE_ERROR)
		return res;
	value_clear(op);
	*op = res;
	return value_init_nil();
}

value value_map_drop(value *variables, value op, value block, value drop)
{	
	return value_init_error();
}

value value_pop(value op)
{
	value res = value_init_nil();
	
	if (op.type == VALUE_NIL) {
		return value_init_nil();
		
	} else if (op.type == VALUE_ARY) {
	
		size_t length = op.core.u_a.length;
		
		if (length == 0)
			return value_init_nil();
		
		--length;
		
		value array[length];
		size_t i;
		for (i = 0; i < length; ++i)
			array[i] = op.core.u_a.a[i];
		
		res = value_set_ary(array, length);
		
	} else if (op.type == VALUE_LST) {
		if (op.core.u_l[1].type != VALUE_LST) {
			res = value_init_nil();
		} else {
			res = value_pop(op.core.u_l[1]);
			value_cons_now(op.core.u_l[0], &res);
		}

		
	} else {
		value_error(1, "Type Error: pop() is undefined where op is %ts (array expected).", op);
		res = value_init_error();
	}

	return res;
}

value value_pop_now(value *op)
{
	if (op->type != VALUE_ARY) {
		value_error(1, "Type Error: pop!() is undefined where op is %ts (array expected).", *op);
		value_clear(op);
		*op = value_init_error();
		return value_init_error();
	}
	
	size_t length = op->core.u_a.length;
	
	if (length == 0)
		return value_init_nil();
		
	value res = value_set(op->core.u_a.a[length-1]);
	
	value_clear(&(op->core.u_a.a[length-1]));
	--op->core.u_a.length;
	if (resize_p(length))
		value_realloc(op, next_size(length));
	
	return res;
}

value value_shuffle(value op)
{
	value res = value_set(op);
	value error = value_shuffle_now(&res);
	if (error.type == VALUE_ERROR)
		return error;
	return res;
}

value value_shuffle_now(value *op)
{
	if (op->type == VALUE_ARY) {
		// Use the Fischer-Yates shuffling algorithm
		value temp;
		size_t i, k;
		for (i = value_length(*op) - 1; i > 0; --i) {
			k = (size_t) (genrand_real2() * i);
			temp = op->core.u_a.a[k];
			op->core.u_a.a[k] = op->core.u_a.a[i];
			op->core.u_a.a[i] = temp;
		}
	} else if (op->type == VALUE_LST) {
		if (value_empty_p(*op) || value_empty_p(op->core.u_l[1])) {
			// do nothing, it cannot be shuffled
		} else {
			// Use something like a reverse quicksort
			value left = value_init_nil();
			value right = value_init_nil();
			value ptr = *op;
			while (!value_empty_p(ptr)) {
				if (genrand_real2() < 0.5)
					value_cons_now2(&ptr.core.u_l[0], &left);
				else
					value_cons_now2(&ptr.core.u_l[0], &right);
				ptr = ptr.core.u_l[1];
			}
			
			value_shuffle_now(&left);
			value_shuffle_now(&right);
			value_concat_now2(&left, &right);
			*op = left;
		}

	} else {
		value_error(1, "Type Error: shuffle() is undefined where op is %ts (array or list expected).", *op);
		return value_init_error();
	}
	
	return value_init_nil();
}

size_t value_size(value op)
{
	if (op.type == VALUE_ARY || op.type == VALUE_LST || op.type == VALUE_BLK)
		return value_length(op);
	else if (op.type == VALUE_HSH)
		return value_hash_size(op);
	else return 1;
}

value value_size_std(value op)
{
	return value_set_long((long) value_size(op));
}

value value_sort(value op)
{
	if (op.type == VALUE_ARY) {
		value res = value_set(op);
	
		if (value_private_sort_recursive(res.core.u_a.a, 0, value_length(res) - 1) == VALUE_ERROR) {
			value_error(1, "Error: sort() is undefined where the types of the elements of op do not match.");
			return value_init_error();
		}
		return res;
	} else if (op.type == VALUE_LST) {
		value res = value_set(op);
		value err = value_sort_now(&res);
		if (err.type == VALUE_ERROR) {
			value_clear(&res);
			return err;
		}
		return res;
	}
	
	value_error(1, "Type Error: sort() is undefined where op is %ts (array or list expected).", op);
	return value_init_error();	
}

value value_sort_now(value *op)
{
	if (op->type == VALUE_NIL) {
		;
	} else if (op->type == VALUE_ARY) {
		if (value_private_sort_recursive(op->core.u_a.a, 0, value_length(*op) - 1) == VALUE_ERROR) {
			value_error(1, "Error: sort() is undefined where the types of the elements of op do not match.");
			return value_init_error();
		}
	} else if (op->type == VALUE_LST) {
		// Uses merge sort to quickly sort a linked list. Better than quicksort because the 
		// only easy way to find a pivot is to take the head of the list, in which case a 
		// sorted or reverse-sorted list will take O(n^2).
		
		if (value_private_sort_list(op))
			return value_init_error();
		
	} else {
		value res = value_sort(*op);
		if (res.type == VALUE_ERROR)
			return res;
		value_clear(op);
		*op = res;
	}
	
	return value_init_nil();
}

int value_private_sort_lt(value op)
{
	return value_lt(op, value_private_sort_pivot);
}

int value_private_sort_eq(value op)
{
	return value_eq(op, value_private_sort_pivot);
}

int value_private_sort_gt(value op)
{
	return value_gt(op, value_private_sort_pivot);
}

int value_private_sort_recursive(value array[], int left, int right)
{
	if (right - left > 12) {
		int i = left;
		int j = right;
		int cmp;
		
		// The pivot's index is selected randomly between the two spots 
		// closest to the center, to decrease the probability of O(n^2) 
		// runtime.
		value pivot = array[(left+right)/2 + (genrand_int31() & 1)];
		
		do {
			while ((cmp = value_cmp_any(array[i], pivot)) == -1) ++i;
			if (cmp == -2) return VALUE_ERROR;
			while ((cmp = value_cmp_any(array[j], pivot)) > 0) --j;
			if (cmp == -2) return VALUE_ERROR;
			if (i <= j) {
				value temp = array[i];
				array[i] = array[j];
				array[j] = temp;
				++i; --j;
			}
			
		} while (i <= j);
		
		if (left < j) 
			if (value_private_sort_recursive(array, left, j) == VALUE_ERROR)
				return VALUE_ERROR;
		if (i < right) 
			if (value_private_sort_recursive(array, i, right) == VALUE_ERROR)
				return VALUE_ERROR;

	} else {
		int i, j, cmp;
		for (i = left; i <= right; ++i) {
			value temp = array[i];
			j = i - 1;
			while (j >= 0 && (cmp = value_cmp_any(array[j], temp)) > 0) {
				array[j+1] = array[j--];
			}
			if (cmp == -2) return VALUE_ERROR;
			
			array[j+1] = temp;
		}
	}
	
	return 0;
}

/* 
 * Implements merge sort for linked lists. Because it is intended to be able to 
 * deal with very long lists, the code is highly optimized. Function calls are 
 * minimized, and it is not checked whether (op) is a list. If (op) is not nil 
 * or a list, this will crash the program.
 * 
 * Crashes if the list has more than about 2000 elements.
 */
int value_private_sort_list(value *op)
{
	if (op->type == VALUE_NIL || op->core.u_l[1].type == VALUE_NIL) {
		return 0;
	}
	
	value left = value_nil;
	value right = value_nil;
	value ptr = *op;
	value temp;
	size_t i;
	
	// Partition (op) into left and right halves.
	for (i = 0; ptr.type == VALUE_LST; ++i) {
		if (i & 1) {
			temp = left;
			left.type = VALUE_LST;
			left.core.u_l = value_malloc(NULL, sizeof(value) * 2);
			if (left.core.u_l == NULL) return 1;
			left.core.u_l[0] = ptr.core.u_l[0];
			left.core.u_l[1] = temp;
		} else {
			temp = right;
			right.type = VALUE_LST;
			right.core.u_l = value_malloc(NULL, sizeof(value) * 2);
			if (right.core.u_l == NULL) return 1;
			right.core.u_l[0] = ptr.core.u_l[0];
			right.core.u_l[1] = temp;			
		}
		
		ptr = ptr.core.u_l[1];
	}
	
	int code = value_private_sort_list(&left);

#define clear_allocated_bits(list) ptr = (list); \
		while (ptr.type == VALUE_LST) { \
			value temp = ptr.core.u_l[1]; \
			value_free(ptr.core.u_l); \
			ptr = temp; \
		}
	
	// If (res) has an error code, clear the allocated bits in (left) and (right) 
	// but don't clear the contents, because those were copied directly from (op).
	if (code) {
		clear_allocated_bits(left);
		clear_allocated_bits(right);
		return code;
	}
	
	code = value_private_sort_list(&right);
	if (code) {
		clear_allocated_bits(left);
		clear_allocated_bits(right);
		return code;
	}
	
	// Merge the left and right halves.
	value lptr = left;
	value rptr = right;
	ptr = *op;
	
	// The contents of (left) and (right) are put directly back into (op) instead of 
	// creating a new list.
	while (TRUE) {
		if (value_cmp_any(lptr.core.u_l[0], rptr.core.u_l[0]) <= 0) {
			ptr.core.u_l[0] = lptr.core.u_l[0];
			temp = lptr;
			lptr = lptr.core.u_l[1];
			value_free(temp.core.u_l);
			if (lptr.type != VALUE_LST) {
				// (lptr) is empty. Stick (rptr) onto the end of the result list.
				ptr.core.u_l[1] = rptr;
				break;
			}
		} else {
			ptr.core.u_l[0] = rptr.core.u_l[0];
			temp = rptr;
			rptr = rptr.core.u_l[1];
			value_free(temp.core.u_l);
			if (rptr.type != VALUE_LST) {
				ptr.core.u_l[1] = lptr;
				break;
			}
		}
		
		ptr = ptr.core.u_l[1];
	}
	
	return 0;
}

/* 
 * Uses one of two different algorithms, depending on how long the array is. The 
 * first algorithm is better for shorter arrays, but becomes very slow for longer 
 * ones.
 */
value value_uniq(value op)
{
	if (op.type == VALUE_ARY) {
		value res = value_init(VALUE_ARY);
		size_t i, length = value_length(op);
		if (length < 150) {
			for (i = 0; i < length; ++i)
				if (!value_contains_p(res, op.core.u_a.a[i]))
					value_append_now(&res, op.core.u_a.a[i]);
		} else {
			value hash = value_hash_init_capacity(length * 2);
			for (i = 0; i < length; ++i)
				if (FALSE == value_hash_exists(hash, op.core.u_a.a[i])) {
					value_hash_put(&hash, op.core.u_a.a[i], value_init_nil());
					value_append_now(&res, op.core.u_a.a[i]);
				}
			value_clear(&hash);
		}

		
		return res;
	} else {
		value_error(1, "Type Error: uniq() is undefined where op is %ts (array expected).", op);
		return value_init_error();
	}
	
}

value value_uniq_now(value *op)
{
	value res = value_uniq(*op);
	if (res.type == VALUE_ERROR)
		return res;
	value_clear(op);
	*op = res;
	return value_init_nil();
}

value value_uniq_sort(value op)
{
	value res = value_init_nil();
	if (op.type == VALUE_ARY) {
		value copy = value_set(op);
		size_t old_length = value_length(copy);
		value_private_sort_recursive(copy.core.u_a.a, 0, old_length - 1);
		
		value array[old_length];
		size_t i, new_length;
		for (i = 0, new_length = 0; i < old_length; ++i) {
			if (i == 0 || value_cmp_any(copy.core.u_a.a[i-1], copy.core.u_a.a[i]) != 0)
				array[new_length++] = copy.core.u_a.a[i];
		}
				
		res = value_set_ary(array, new_length);
		value_clear(&copy);
	
	} else if (op.type == VALUE_LST) {
		value copy = value_sort(op);
		res = value_init_nil();
		value *rptr = &res;
		
		value ptr = copy;
		value *prev = NULL;
		while (ptr.type == VALUE_LST) {
			if (prev == NULL || value_cmp_any(*prev, ptr.core.u_l[0]) != 0) {
				*rptr = value_init(VALUE_LST);
				rptr->core.u_l[0] = value_set(ptr.core.u_l[0]);
				rptr = &rptr->core.u_l[1];
			}
			
			prev = &ptr.core.u_l[0];
			ptr = ptr.core.u_l[1];
		}
		
		value_clear(&copy);
		
	} else {
		value_error(1, "Type Error: uniq_sort() is undefined where op is %ts (array expected).", op);
		res = value_init_error();
	}
	
	return res;
}

value value_uniq_sort_now(value *op)
{
	value res = value_uniq_sort(*op);
	if (res.type == VALUE_ERROR)
		return res;
	value_clear(op);
	*op = res;
	return value_init_nil();
}

value value_append_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "append()") ? value_init_error() : value_append(argv[0], argv[1]);
}

value value_append_now_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "append!()") ? value_init_error() : value_append_now(&argv[0], argv[1]);
}

value value_array_with_length_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "array_with_length()") ? value_init_error() : value_array_with_length(argv[0]);
}

value value_at_arg(int argc, value argv[])
{
	if (argc == 1)
		return missing_arguments(argc, argv, "at()") ? value_init_error() : value_at(argv[0], value_init_nil(), argv+1, argc-1);
	else
		return missing_arguments(argc, argv, "at()") ? value_init_error() : value_at(argv[0], argv[1], argv+2, argc-2);
}

value value_at_assign_arg(int argc, value argv[])
{
	value *tmp = value_deref(argv[0]);
	return missing_arguments(argc-1, argv+1, "at=()") ? value_init_error() : value_at_assign_do(tmp, &argv[1], argv[2], argv+3, argc-4, value_init_nil(), argv[argc-1]);
}

value value_at_assign_add_arg(int argc, value argv[])
{
	value *tmp = value_deref(argv[0]);
	if (missing_arguments(argc-1, argv+1, "at+=()"))
		return value_init_error();
	
	value func = value_set_fun(&value_add_arg);
	return_if_error(func);
	value res = value_at_assign_do(tmp, &argv[1], argv[2], argv+3, argc-4, func, argv[argc-1]);
	value_clear(&func);
	return res;
}

value value_at_assign_sub_arg(int argc, value argv[])
{
	value *tmp = value_deref(argv[0]);
	if (missing_arguments(argc-1, argv+1, "at-=()"))
		return value_init_error();
	
	value func = value_set_fun(&value_sub_arg);
	return_if_error(func);
	value res = value_at_assign_do(tmp, &argv[1], argv[2], argv+3, argc-4, func, argv[argc-1]);
	value_clear(&func);
	return res;
}

value value_at_assign_mul_arg(int argc, value argv[])
{
	value *tmp = value_deref(argv[0]);
	if (missing_arguments(argc-1, argv+1, "at*=()"))
		return value_init_error();
	
	value func = value_set_fun(&value_mul_arg);
	return_if_error(func);
	value res = value_at_assign_do(tmp, &argv[1], argv[2], argv+3, argc-4, func, argv[argc-1]);
	value_clear(&func);
	return res;
}

value value_at_assign_div_arg(int argc, value argv[])
{
	value *tmp = value_deref(argv[0]);
	if (missing_arguments(argc-1, argv+1, "at/=()"))
		return value_init_error();
	
	value func = value_set_fun(&value_div_arg);
	return_if_error(func);
	value res = value_at_assign_do(tmp, &argv[1], argv[2], argv+3, argc-4, func, argv[argc-1]);
	value_clear(&func);
	return res;
}

value value_at_assign_mod_arg(int argc, value argv[])
{
	value *tmp = value_deref(argv[0]);
	if (missing_arguments(argc-1, argv+1, "at%=()"))
		return value_init_error();
	
	value func = value_set_fun(&value_mod_arg);
	return_if_error(func);
	value res = value_at_assign_do(tmp, &argv[1], argv[2], argv+3, argc-4, func, argv[argc-1]);
	value_clear(&func);
	return res;
}

value value_at_assign_and_arg(int argc, value argv[])
{
	value *tmp = value_deref(argv[0]);
	if (missing_arguments(argc-1, argv+1, "at&=()"))
		return value_init_error();
	
	value func = value_set_fun(&value_and_arg);
	return_if_error(func);
	value res = value_at_assign_do(tmp, &argv[1], argv[2], argv+3, argc-4, func, argv[argc-1]);
	value_clear(&func);
	return res;
}

value value_at_assign_xor_arg(int argc, value argv[])
{
	value *tmp = value_deref(argv[0]);
	if (missing_arguments(argc-1, argv+1, "at^=()"))
		return value_init_error();
	
	value func = value_set_fun(&value_xor_arg);
	return_if_error(func);
	value res = value_at_assign_do(tmp, &argv[1], argv[2], argv+3, argc-4, func, argv[argc-1]);
	value_clear(&func);
	return res;
}

value value_at_assign_or_arg(int argc, value argv[])
{
	value *tmp = value_deref(argv[0]);
	if (missing_arguments(argc-1, argv+1, "at|=()"))
		return value_init_error();
	
	value func = value_set_fun(&value_or_arg);
	return_if_error(func);
	value res = value_at_assign_do(tmp, &argv[1], argv[2], argv+4, argc-4, func, argv[3]);
	value_clear(&func);
	return res;
}

value value_at_assign_shl_arg(int argc, value argv[])
{
	value *tmp = value_deref(argv[0]);
	if (missing_arguments(argc-1, argv+1, "at<<=()"))
		return value_init_error();
	
	value func = value_set_fun(&value_shl_arg);
	return_if_error(func);
	value res = value_at_assign_do(tmp, &argv[1], argv[2], argv+3, argc-4, func, argv[argc-1]);
	value_clear(&func);
	return res;
}

value value_at_assign_shr_arg(int argc, value argv[])
{
	value *tmp = value_deref(argv[0]);
	if (missing_arguments(argc-1, argv+1, "at>>=()"))
		return value_init_error();
	
	value func = value_set_fun(&value_shr_arg);
	return_if_error(func);
	value res = value_at_assign_do(tmp, &argv[1], argv[2], argv+3, argc-4, func, argv[argc-1]);
	value_clear(&func);
	return res;
}

value value_concat_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "concat()") ? value_init_error() : value_concat(argv[0], argv[1]);
}

value value_delete_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "delete()") ? value_init_error() : value_delete(argv[0], argv[1]);
}

value value_delete_all_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "delete_all()") ? value_init_error() : value_delete_all(argv[0], argv[1]);
}

value value_delete_at_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "delete_at()") ? value_init_error() : value_delete_at(argv[0], argv[1]);
}

value value_delete_at_now_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "delete_at!()") ? value_init_error() : value_delete_at_now(&argv[0], argv[1]);
}

value value_each_arg(int argc, value argv[])
{
	value *tmp = value_deref(argv[0]);
	return missing_arguments(argc-1, argv+1, "each()") ? value_init_error() : value_each(tmp, argv[1], argv[2]);
}

value value_each_index_arg(int argc, value argv[])
{
	value *tmp = value_deref(argv[0]);
	return missing_arguments(argc-1, argv+1, "each_index()") ? value_init_error() : value_each_index(tmp, argv[1], argv[2]);
}

value value_empty_p_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "empty?()") ? value_init_error() : value_empty_p_std(argv[0]);
}

value value_filter_arg(int argc, value argv[])
{
	value *tmp = value_deref(argv[0]);
	return missing_arguments(argc-1, argv+1, "filter()") ? value_init_error() : value_filter(tmp, argv[1], argv[2]);
}

value value_find_arg(int argc, value argv[])
{
	value *tmp = value_deref(argv[0]);
	return missing_arguments(argc-1, argv+1, "find()") ? value_init_error() : value_find(tmp, argv[1], argv[2]);
}

value value_flatten_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "flatten()") ? value_init_error() : value_flatten(argv[0]);
}

value value_flatten_now_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "flatten!()") ? value_init_error() : value_flatten_now(&argv[0]);
}

value value_fold_arg(int argc, value argv[])
{
	value *tmp = value_deref(argv[0]);
	return missing_arguments(argc-1, argv+1, "fold()") ? value_init_error() : value_fold(tmp, argv[1], argv[2], argv[3]);
}

value value_join_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "join()") ? value_init_error() : value_join(argv[0], argv[1]);
}

value value_last_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "last()") ? value_init_error() : value_last(argv[0]);
}

value value_map_arg(int argc, value argv[])
{
	value *tmp = value_deref(argv[0]);
	return missing_arguments(argc-1, argv+1, "map()") ? value_init_error() : value_map(tmp, argv[1], argv[2]);
}

value value_map_now_arg(int argc, value argv[])
{
	value *tmp = value_deref(argv[0]);
	return missing_arguments(argc-1, argv+1, "map!()") ? value_init_error() : value_map_now(tmp, &argv[1], argv[2]);
}

value value_map_drop_arg(int argc, value argv[])
{
	value *tmp = value_deref(argv[0]);
	return missing_arguments(argc-1, argv+1, "map_drop()") ? value_init_error() : value_map_drop(tmp, argv[1], argv[2], argv[3]);
}

value value_pop_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "pop()") ? value_init_error() : value_pop(argv[0]);
}

value value_pop_now_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "pop!()") ? value_init_error() : value_pop_now(&argv[0]);
}

value value_shuffle_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "shuffle()") ? value_init_error() : value_shuffle(argv[0]);
}

value value_shuffle_now_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "shuffle!()") ? value_init_error() : value_shuffle_now(&argv[0]);
}

value value_size_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "size()") ? value_init_error() : value_size_std(argv[0]);
}

value value_sort_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "sort()") ? value_init_error() : value_sort(argv[0]);
}

value value_sort_now_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "sort!()") ? value_init_error() : value_sort_now(&argv[0]);
}

value value_uniq_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "uniq()") ? value_init_error() : value_uniq(argv[0]);
}

value value_uniq_now_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "uniq!()") ? value_init_error() : value_uniq_now(&argv[0]);
}

value value_uniq_sort_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "uniq_sort()") ? value_init_error() : value_uniq_sort(argv[0]);
}

value value_uniq_sort_now_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "uniq_sort!()") ? value_init_error() : value_uniq_sort_now(&argv[0]);
}

/*
 *  value_block.c
 *  Simfpl
 *
 *  Created by Michael Dickens on 4/4/10.
 *
 */

/* 
 * A block is an array of values that can be called as if it were a function. 
 * It is internally represented by a struct containing an array and a 
 * description.
 * 
 * A built-in function contains a pointer to a C function. This is considerably 
 * more efficient than external functions.
 * 
 * A user-defined function contains an ID with the name of the function. When 
 * it is called, the function is retrieved from the variable list. It happens 
 * then and not earlier because it's possible for the function to be modified 
 * after compile time but before it's called.
 * 
 * An unnamed function contains a pointer to two values. One is the list of 
 * variable names, and the other is a block.
 */

#include "value.h"

value value_set_block(value array[], size_t length)
{
	if (length < 0)
		length = 0;
	value res;
	res.type = VALUE_BLK;
	res.core.u_blk.s = NULL;
	res.core.u_blk.a = value_malloc(NULL, sizeof(value) * next_size(length));
	return_if_null(res.core.u_blk.a);
	res.core.u_blk.length = length;
	
	unsigned long i;
	for (i = 0; i < length; ++i)
		res.core.u_blk.a[i] = value_set(array[i]);
	
	return res;
}

value value_set_fun(value (*fun)(int argc, value argv[]))
{
	value res;
	
	res.type = VALUE_BIF;
	res.core.u_bif = value_malloc(NULL, sizeof(struct value_bif));
	return_if_null(res.core.u_bif);
	res.core.u_bif->f = fun;
	res.core.u_bif->spec = value_nil_function_spec;
	return res;
}

int value_commutative_p(value fun)
{
	if (fun.type == VALUE_BIF) {
		value (*f)(int argc, value argv[]) = fun.core.u_bif->f;
		
		if (f == &value_add_arg || f == &value_mul_arg) {
			return TRUE;
		} else {
			return FALSE;
		}

	}
	
	return FALSE;
}

value value_call(value *variables, value func, int argc, value argv[])
{
	value res = value_init_nil();
	if (func.type == VALUE_BIF) {
		res = value_bifcall(func, argc, argv);
	} else if (func.type == VALUE_UDF) {
		res = value_udfcall(variables, func, argc, argv);
	} else if (func.type == VALUE_BLK) {
		res = eval(variables, func);
	} else {
		value_error(1, "Type Error: call() is undefined where op1 is %ts (function or block expected).", func);
		res = value_init_error();
	}

	return res;
}

value value_bifcall_sexp(value *variables, value *ud_functions, value sexp)
{
	size_t length = sexp.core.u_blk.length;
	int error_p = FALSE;
	value res = value_init_nil();
	
	struct value_spec spec = sexp.core.u_blk.a[0].core.u_bif->spec;

	// Call the function that's pointed to by the VALUE_BIF.
	
	int argc = spec.argc;
	if (argc < length && spec.rest_p)
		argc = length - 1;
			
	int args_length = argc+1;
	value args[args_length];
	int clear_args_p[args_length];
	value *vptrs[args_length]; // holds pointers to variables inside of a variable list
	memset(clear_args_p, 0, sizeof(int) * (args_length)); // the default for clear_args_p is FALSE; 
														  // that is, don't clear unless specifically told to
	memset(vptrs, 0, sizeof(value) * (args_length));
	
	// The reason for vptrs is because of how value copying works. If the function to be called 
	// takes a pointer, the pointer has to be a reference to the correct value. (args) will not 
	// reference the correct value because the value is copied from (sexp). (vptrs) therefore 
	// holds pointers to the actual values. After the s-expression is evaluated, (vptrs) is set 
	// to (args), thus making it point to the new values.
	
	size_t i, j = 0;
	if (spec.needs_variables_p == NEEDS_UD_FUNCTIONS)
		args[j++] = value_refer(ud_functions);
	else if (spec.needs_variables_p == TRUE)
		args[j++] = value_refer(variables);
	
	// Move the contents of (sexp) over to (args), which will be passed into the called function 
	// as the argument list.
	for (i = 1; i < length; ++i, ++j) {
		if (spec.delay_eval_p) {
			args[j] = sexp.core.u_blk.a[i];
		} else if (sexp.core.u_blk.a[i].type == VALUE_VAR && !(i == 1 && spec.keep_arg_p)) {
			// sexp.core.u_blk.a[i] is a variable. Find its value and put the value in its place. 
			// Finds a reference to the value, not a copy.
			
			if (value_hash_exists(*variables, sexp.core.u_blk.a[i]))
				vptrs[j] = value_hash_get_ref(*variables, sexp.core.u_blk.a[i]);
			else if (value_hash_exists(global_variables, sexp.core.u_blk.a[i]))
				vptrs[j] = value_hash_get_ref(global_variables, sexp.core.u_blk.a[i]);
			else {
				value_error(1, "Error: Unrecognized function or value %s.", sexp.core.u_blk.a[i]);
				error_p = TRUE;
				// Don't break yet; keep executing to see if there are more errors.
			}
			if (vptrs[j])
				args[j] = *vptrs[j];
			
		} else if (sexp.core.u_blk.a[i].type == VALUE_BLK) {
			// sexp.core.u_blk.a[i] is an s-expression. Evaluate it.
			args[j] = eval_generic(variables, sexp.core.u_blk.a[i], TRUE);
			if (args[j].type == VALUE_ERROR)
				error_p = TRUE;
			clear_args_p[j] = TRUE;
		} else {
			args[j] = sexp.core.u_blk.a[i];
		}
	}
	
	int necessary_length = argc;
	if (spec.needs_variables_p)
		++necessary_length;
	if (length - 1 < necessary_length) {
		for (; j < necessary_length; ++j)
			if (j < spec.optional) args[j].type = VALUE_MISSING_ARG;
			else args[j].type = VALUE_NIL;
	}
	
	// Missing and extra arguments can't be identified at compile time because then (quote) 
	// won't work.
	if (spec.rest_p == FALSE && j < necessary_length) {
		value_error(1, "Argument Error: In %s, %d extra arguments (%d expected, %d found).", sexp.core.u_blk.a[0], args_length - j, j, args_length);
		error_p = TRUE;
	}
	
	if (error_p) {
		res = value_init_error();
	} else res = (*sexp.core.u_blk.a[0].core.u_bif->f)(j, args);
	
	i = 0;
	if (spec.needs_variables_p)
		++i; // We don't want to accidentally clear the variables, which are 
			 // held in args[0].
	for ( ; i < j; ++i) {
		if (clear_args_p[i])
			value_clear(&args[i]);
		else if (vptrs[i])
			*vptrs[i] = args[i];
	}
	
	return res;
}

value value_bifcall(value op, int argc, value argv[])
{
	if (op.type == VALUE_BIF) {
		return (*(op.core.u_bif->f))(argc, argv);
	} else {
		value_error(1, "Type Error: bifcall() is undefined where op is %ts (function expected).", op);
		return value_init_error();
	}
}

value value_udfcall(value *variables, value op, int argc, value argv[])
{
	if (op.type != VALUE_UDF) {
		value_error(1, "Type Error: udfcall() is undefined where op is %ts (user-defined function expected).", op);
		return value_init_error();
	}
			
	int fargc = op.core.u_udf->spec.argc;
	if (fargc > argc) {
		value_error(1, "Argument Error: In %s, %d missing arguments (%d expected, %d found).", op, fargc - argc, fargc, argc);
		return value_init_error();
	}
	
	int change_scope_p = op.core.u_udf->spec.change_scope_p;
	int delay_eval_p = op.core.u_udf->spec.delay_eval_p;
			
	value varkeys = op.core.u_udf->vars;
	value vnil = value_init_nil();
		
	size_t i;
	
	value one_array[1];
	value *new_vars = one_array;
	
	// Add variables from the function call to the list of variables.
	if (change_scope_p) {
		*new_vars = value_hash_init();
		return_if_error(*new_vars);
	} else {
		// When the scope is not changed, add the function variables to the 
		// variable list and remove them afterwards.
		
		new_vars = variables;
	}
		
	size_t length = varkeys.type == VALUE_BLK ? varkeys.core.u_blk.length : 1;
	
	int existed[length];

	if (varkeys.type == VALUE_BLK) {
		for (i = 0; i < varkeys.core.u_blk.length; ++i) {
			value key = value_set(varkeys.core.u_blk.a[i]);
			
			if (change_scope_p == FALSE)
				if (value_hash_exists(*new_vars, key))
					existed[i] = TRUE;
				else existed[i] = FALSE;
			
			if (i >= argc) {
				value_hash_put_refs(new_vars, &key, &vnil);
			} else {
				value x;
				if (delay_eval_p)
					x = value_set(argv[i]);
				else x = eval(variables, argv[i]);
				value_hash_put_refs(new_vars, &key, &x);
			}
		}
	} else if (varkeys.type == VALUE_VAR) {
		value key = value_set(varkeys);
		if (change_scope_p == FALSE && value_hash_exists(*new_vars, key))
			existed[0] = TRUE;
		else existed[0] = FALSE;
		
		if (0 >= argc) {
			value_hash_put_refs(new_vars, &key, &vnil);
		} else {
			value x;
			if (delay_eval_p)
				x = value_set(argv[0]);
			else x = eval(variables, argv[0]);
			value_hash_put_refs(new_vars, &key, &x);
		}		
	}

	value res = eval(new_vars, op.core.u_udf->body);
	
	// Remove the (return) wrapper.
	if (op.core.u_udf->spec.not_stop_p == FALSE && res.type == VALUE_STOP && res.core.u_stop.type == STOP_RETURN) {
		value temp = *res.core.u_stop.core;
		value_free(res.core.u_stop.core);
		res = temp;
	}
	
	// If the scope didn't change, remove any variables that were added.
	if (change_scope_p == FALSE) {
		if (varkeys.type == VALUE_BLK) {
			for (i = 0; i < length; ++i) {
				if (existed[i] == FALSE) {
					value_hash_delete_at_void(new_vars, varkeys.core.u_blk.a[i]);
				}
			}
		} else {
			if (existed[0] == FALSE) {
				value_hash_delete_at_void(new_vars, varkeys);
			}
		}

	} else value_clear(new_vars);
	
	return res;
}

value value_def(value *variables, value name, value vars, value body)
{
	int error_p = FALSE;
	
	if (name.type == VALUE_BIF) {
		value *ptr = value_hash_get_ref(primitive_names, name);
		name = *ptr;
	} else if (name.type == VALUE_UDF) {
		value temp;
		temp.type = VALUE_VAR;
		temp.core.u_var = name.core.u_udf->name;
		name = temp;
	}
	
	if (name.type != VALUE_VAR) {
		value_error(1, "Type Error: def() is undefined where name is %ts (variable expected).", name);
		error_p = TRUE;
	}
	
	if (vars.type == VALUE_VAR) {
		value temp = value_init(VALUE_BLK);
		value_append_now2(&temp, &vars);
		vars = temp;
	}
	
	if (vars.type != VALUE_BLK && vars.type != VALUE_NIL) {
		value_error(1, "Type Error: def() is undefined where vars is %ts (block expected).", vars);
		error_p = TRUE;
	}
	
	if (vars.type == VALUE_NIL)
		vars = value_init(VALUE_BLK);
	
	struct value_spec spec = compile_spec("0l15");
	
	value fvars = value_init(VALUE_BLK);

	size_t i;
	for (i = 0; i < vars.core.u_blk.length; ++i) {
		if (vars.core.u_blk.a[i].type == VALUE_VAR) {
			++spec.argc;
			value_append_now(&fvars, vars.core.u_blk.a[i]);
		} else if (vars.core.u_blk.a[i].type == VALUE_SYM) {
			if (streq(vars.core.u_blk.a[i].core.u_s, "delay_eval")) {
				spec.delay_eval_p = TRUE;
			} else if (streq(vars.core.u_blk.a[i].core.u_s, "keep_scope")) {
				spec.change_scope_p = FALSE;
//			} else if (streq(vars.core.u_blk.a[i].core.u_s, "rest")) {
				// This is not fully implemented yet. The UDF has to have a way to access the argument list.
//				rest_p = TRUE;
			} else {
				value_error(1, "Type Error: in def() variable list, undefined symbol %s.", vars.core.u_blk.a[i]);
				error_p = TRUE;
			}
		} else {
			value_error(1, "Type Error: def() is undefined where one of the function arguments is %ts (variable or symbol expected).", vars.core.u_blk.a[i]);
			error_p = TRUE;
		}
	}
	
	if (error_p) {
		return value_init_error();
	}
	
	value fun;
	
	fun.type = VALUE_UDF;
	fun.core.u_udf = value_malloc(NULL, sizeof(struct value_function));
	return_if_null(fun.core.u_udf);
	fun.core.u_udf->name = value_malloc(NULL, strlen(name.core.u_var) + 1);
	return_if_null(fun.core.u_udf->name);
	strcpy(fun.core.u_udf->name, name.core.u_var);
	
	fun.core.u_udf->spec = spec;
	
	fun.core.u_udf->vars = fvars;
	fun.core.u_udf->body = value_set(body);
		
	value_hash_put(variables, name, fun);
			
	return fun;
}

value value_defmacro(value *variables, value name, value vars, value body)
{
	return value_init_error();
}

value value_def_arg(int argc, value argv[])
{
	value *tmp = value_deref(argv[0]);
	return missing_arguments(argc-1, argv+1, "def()") ? value_init_error() : value_def(tmp, argv[1], argv[2], argv[3]);
}

value value_quote(value *variables, value op)
{
	value res = value_init_nil();
	if (op.type == VALUE_BLK) {
		if (op.core.u_blk.a[0].type == VALUE_BIF && (op.core.u_blk.a[0].core.u_bif->f == &value_dequote_arg || 
			op.core.u_blk.a[0].core.u_bif->f == &value_devar_arg)) {
			res = eval(variables, op);
			
		} else {
			res = value_init(VALUE_BLK);
			value_malloc(&res, next_size(op.core.u_blk.length));
			return_if_error(res);
			res.core.u_blk.length = op.core.u_blk.length;
			
			size_t i;
			for (i = 0; i < op.core.u_blk.length; ++i) {
				res.core.u_blk.a[i] = value_quote(variables, op.core.u_blk.a[i]);
			}
		}

		
	} else {
		res = value_set(op);
	}
	
	return res;
}

value value_quote_all_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "quote()") ? value_init_error() : value_set(argv[0]);
}

value value_quote_arg(int argc, value argv[])
{
	value *tmp = value_deref(argv[0]);
	return missing_arguments(argc-1, argv+1, "`()") ? value_init_error() : value_quote(tmp, argv[1]);
}

value value_dequote_arg(int argc, value argv[])
{
	value *tmp = value_deref(argv[0]);
	return missing_arguments(argc-1, argv+1, "dq()") ? value_init_error() : eval(tmp, argv[1]);
}

value value_devar_arg(int argc, value argv[])
{
	value *variables = value_deref(argv[0]);
	if (missing_arguments(argc-1, argv+1, "dv()"))
		return value_init_error();
	
	if (argv[1].type == VALUE_VAR) {
		return value_hash_get(*variables, argv[1]);
	}
	
	return value_set(argv[1]);
}

value value_eval_arg(int argc, value argv[])
{
	value *tmp = value_deref(argv[0]);
	return missing_arguments(argc-1, argv+1, "eval()") ? value_init_error() : eval(tmp, argv[1]);
}

value value_break_arg(int argc, value argv[])
{
	if (missing_arguments(argc, argv, "break()"))
		return value_init_error();
		
	value res;
	res.type = VALUE_STOP;
	res.core.u_stop.type = STOP_BREAK;
	res.core.u_stop.core = NULL;
	return res;
}

value value_continue_arg(int argc, value argv[])
{
	if (missing_arguments(argc, argv, "continue()"))
		return value_init_error();
		
	value res;
	res.type = VALUE_STOP;
	res.core.u_stop.type = STOP_CONTINUE;
	res.core.u_stop.core = NULL;
	return res;
}

value value_yield_arg(int argc, value argv[])
{
	if (missing_arguments(argc, argv, "yield()"))
		return value_init_error();
		
	value res;
	res.type = VALUE_STOP;
	res.core.u_stop.type = STOP_YIELD;
	res.core.u_stop.core = value_malloc(NULL, sizeof(value));
	return_if_null(res.core.u_stop.core);
	*res.core.u_stop.core = value_set(argv[0]);
	return res;
}

value value_return_arg(int argc, value argv[])
{
	if (missing_arguments(argc, argv, "return()"))
		return value_init_error();
		
	value res;
	res.type = VALUE_STOP;
	res.core.u_stop.type = STOP_RETURN;
	res.core.u_stop.core = value_malloc(NULL, sizeof(value));
	return_if_null(res.core.u_stop.core);
	*res.core.u_stop.core = value_set(argv[0]);
	return res;
}

value value_exit_arg(int argc, value argv[])
{
	if (missing_arguments(argc, argv, "exit()"))
		return value_init_error();
	
	value res;
	res.type = VALUE_STOP;
	res.core.u_stop.type = STOP_EXIT;
	res.core.u_stop.core = NULL;
	return res;
}

value value_if(value *variables, value condition, value body, value else_body, int reverse)
{
	value res;
	if (value_true_p(res = eval(variables, condition)) ^ reverse) {
		if (res.type == VALUE_ERROR) return res;
		value_clear(&res);
		res = eval(variables, body);
	} else {
		if (res.type == VALUE_ERROR) return res;
		value_clear(&res);
		res = eval(variables, else_body);
	}
	
	return res;
}

value value_while(value *variables, value condition, value body, int reverse)
{
	value clr, res = value_init(VALUE_ARY);
	while (value_true_p(clr = eval(variables, condition)) ^ reverse) {
		if (clr.type == VALUE_ERROR)
			return clr;
		value_clear(&clr);
		clr = eval(variables, body);
		
		if (clr.type == VALUE_ERROR)
			return clr;
		else if (clr.type == VALUE_STOP && clr.core.u_stop.type == STOP_BREAK)
			break;
		else if (clr.type == VALUE_STOP && clr.core.u_stop.type == STOP_YIELD)
			value_append_now2(&res, clr.core.u_stop.core);
		else if (clr.type == VALUE_STOP && (clr.core.u_stop.type == STOP_RETURN || clr.core.u_stop.type == STOP_EXIT)) {
			value_clear(&res);
			return clr;
		} else value_clear(&clr);
	}
	
	if (value_length(res) == 0)
		value_clear(&res);
	return res;
}

value value_switch(value *variables, value val, value body)
{
	int compare_p = TRUE;
	if (body.type == VALUE_NIL) {
		compare_p = FALSE;
		body = val;
		val.type = VALUE_NIL;
	}
	
	if (body.type != VALUE_BLK) {
		value_error(1, "Type Error: switch() is undefined where body is %ts (block expected).", body);
		return value_init_error();
	}
	
	value cmp = value_init_nil();
	if (compare_p)
		cmp = eval(variables, val);
	value res = value_init_nil();
	value vdefault = value_init_nil();
	int default_defined = FALSE;
	
	size_t i;
	for (i = 0; i < body.core.u_blk.length; ++i) {
		if (body.core.u_blk.a[i].type == VALUE_SYM && streq(body.core.u_blk.a[i].core.u_s, "if")) {
			if (++i >= body.core.u_blk.length) break;
			if (compare_p) {
				if (value_eq(body.core.u_blk.a[i], cmp)) {
					if (++i >= body.core.u_blk.length) break;
					res = eval(variables, body.core.u_blk.a[i]);
					break;
				}
			} else {
				value ev = eval(variables, body.core.u_blk.a[i]);
				if (value_true_p(ev)) {
					if (++i >= body.core.u_blk.length) break;
					res = eval(variables, body.core.u_blk.a[i]);
					break;					
				}
			}

		} else if (body.core.u_blk.a[i].type == VALUE_SYM && streq(body.core.u_blk.a[i].core.u_s, "else")) {
			if (default_defined == FALSE) {
				default_defined = TRUE;
				if (++i >= body.core.u_blk.length) break;
				vdefault = body.core.u_blk.a[i];
			} else {
				value_error(1, "Error: In switch(), multiple :else symbols found.");
				res = value_init_error();
				break;
			}
		}
	}
	
	if (i == body.core.u_blk.length) {
		res = eval(variables, vdefault);
	}
	
	value_clear(&cmp);
	return res;
}

value value_do(value *variables, value todo[], size_t length)
{
	 size_t i;
	 value res = value_init_nil();
	 for (i = 0; i < length; ++i) {
		 value_clear(&res);
		 res = eval(variables, todo[i]);
		 if (res.type == VALUE_ERROR || res.type == VALUE_STOP)
			return res;
	 }
	 
	 return res;
}

value value_comma(value op1, value op2)
{
	value res;
	if (op1.type == VALUE_ARY) {
		res = value_append(op1, op2);
	} else {
		res = value_init(VALUE_ARY);
		value_append_now(&res, op1);
		value_append_now(&res, op2);
	}
	
	return res;
}

value value_for(value *variables, value condition, value body)
{
	int error_p = FALSE;
	
	if (condition.type != VALUE_BLK) {
		value_error(1, "Type Error: for() is undefined where condition is %ts (block expected).", condition);
		error_p = TRUE;
	}
	
	// condition.core.u_blk.a[0] contains the variable name; 
	// condition.core.u_blk.a[1] contains a symbol; 
	// condition.core.u_blk.a[2] contains the iterable
	
	if (error_p) return value_init_error();
	
	value res;
	
	size_t length = condition.core.u_blk.length;
	if (length < 3) {
		value_error(1, "Error: for() is undefined where the condition contains fewer than three words.");
		return value_init_error();
	}
		
	if (condition.core.u_blk.a[0].type == VALUE_VAR || condition.core.u_blk.a[0].type == VALUE_BLK) {
		if (condition.core.u_blk.a[1].type != VALUE_SYM) {
			value_error(1, "Error: Undefined syntax in for loop's condition %s. No symbol found.", condition);
			return value_init_error();
		}
		
		value iter = eval(variables, condition.core.u_blk.a[2]);
		
		size_t ifs_position = length;
		while (ifs_position >= 5 && value_eq(condition.core.u_blk.a[ifs_position-2], value_symbol_if)) {
			value func = value_init(VALUE_UDF);
			func.core.u_udf->vars = value_set(condition.core.u_blk.a[0]);
			func.core.u_udf->body = value_set(condition.core.u_blk.a[ifs_position-1]);
			func.core.u_udf->spec.change_scope_p = FALSE;
			func.core.u_udf->spec.not_stop_p = TRUE;
			func.core.u_udf->spec.argc = 1;
			
			value tmp_iter = value_filter(variables, iter, func);
			value_clear(&iter);
			value_clear(&func);
			iter = tmp_iter;
			
			ifs_position -= 2;
		}
		
		if (value_eq(condition.core.u_blk.a[1], value_symbol_in)) {
			value func = value_init(VALUE_UDF);
			func.core.u_udf->vars = value_set(condition.core.u_blk.a[0]);
			func.core.u_udf->body = value_set(body);
			func.core.u_udf->spec.change_scope_p = FALSE;
			func.core.u_udf->spec.not_stop_p = TRUE;
			func.core.u_udf->spec.argc = 1;
			
			res = value_each(variables, iter, func);
			value_clear(&iter);
			value_clear(&func);
			return res;
		} else if (value_eq(condition.core.u_blk.a[1], value_symbol_dotimes)) {			
			value func = value_init(VALUE_UDF);
			func.core.u_udf->vars = value_set(condition.core.u_blk.a[0]);
			func.core.u_udf->body = value_set(body);
			func.core.u_udf->spec.change_scope_p = FALSE;
			func.core.u_udf->spec.not_stop_p = TRUE;
			func.core.u_udf->spec.argc = 1;
			
			res = value_times(variables, iter, func);
			value_clear(&iter);
			value_clear(&func);
			return res;			
		}
	} else {
		value_error(1, "Error: Undefined syntax for loop's condition %s. No variable found.", condition);
		return value_init_error();
	}

	
	return value_init_nil();
}

value value_if_arg(int argc, value argv[])
{
	value *tmp = value_deref(argv[0]);
	return missing_arguments(argc-1, argv+1, "if()") ? value_init_error() : value_if(tmp, argv[1], argv[2], argv[3], FALSE);
}

value value_unless_arg(int argc, value argv[])
{
	value *tmp = value_deref(argv[0]);
	return missing_arguments(argc-1, argv+1, "unless()") ? value_init_error() : value_if(tmp, argv[1], argv[2], argv[3], TRUE);
}

value value_while_arg(int argc, value argv[])
{
	value *tmp = value_deref(argv[0]);
	return missing_arguments(argc-1, argv+1, "while()") ? value_init_error() : value_while(tmp, argv[1], argv[2], FALSE);
}

value value_until_arg(int argc, value argv[])
{
	value *tmp = value_deref(argv[0]);
	return missing_arguments(argc-1, argv+1, "until()") ? value_init_error() : value_while(tmp, argv[1], argv[2], TRUE);
}

value value_switch_arg(int argc, value argv[])
{
	value *tmp = value_deref(argv[0]);
	return missing_arguments(argc-1, argv+1, "switch()") ? value_init_error() : value_switch(tmp, argv[1], argv[2]);
}

value value_for_arg(int argc, value argv[])
{
	value *tmp = value_deref(argv[0]);
	return missing_arguments(argc-1, argv+1, "for()") ? value_init_error() : value_for(tmp, argv[1], argv[2]);
}

value value_do_both_arg(int argc, value argv[])
{
	value *tmp = value_deref(argv[0]);
	return missing_arguments(argc-1, argv+1, ";()") ? value_init_error() : value_do(tmp, argv+1, (size_t) argc-1);
}

value value_do_all_arg(int argc, value argv[])
{
	value *tmp = value_deref(argv[0]);
	return missing_arguments(argc-1, argv+1, "do_all()") ? value_init_error() : value_do(tmp, argv+1, (size_t) argc-1);
}

value value_comma_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, ",()") ? value_init_error() : value_comma(argv[0], argv[1]);
}

/*
 *  value_exception.c
 *  Calculator
 *
 *  Created by Michael Dickens on 7/13/10.
 *
 */

#include "value.h"

exception exception_init(exception *parent, char *name)
{
	exception res;
	res.parent = parent;
	res.name = value_malloc(NULL, strlen(name) + 1);
	if (res.name) strcpy(res.name, name);
	res.description = NULL;
	res.stack_trace = NULL;
	return res;
}

value value_throw(exception op, char *description)
{
	value exc;
	exc.core.u_exc = op;
	value res = value_set(exc);
	if (res.core.u_exc.description)value_free(res.core.u_exc.description);
	res.core.u_exc.description = value_malloc(NULL, strlen(description) + 1);
	return_if_null(res.core.u_exc.description);
	strcpy(res.core.u_exc.description, description);
	return res;
}/*
 *  value_hash.c
 *  Simfpl
 *
 *  Created by Michael Dickens on 3/16/10.
 *
 */

/* 
 * Hash Table Implementation
 * 
 * A hash table is implemented as an array of buckets. Each bucet
 * contains a two-element value array with a key and a value. This is 
 * an implementation of the separate chaining method. An array is 
 * used to represent the bucket rather than a linked list because 
 * lists take at least five times longer to iterate over.
 * 
 * (name).core.u_h is used to store the array. On the surface, a hash 
 * is identical to an array except that its type is VALUE_HSH instead 
 * of VALUE_ARY.
 * 
 * The first index of a hash table is not the length. Rather, it is a 
 * three-element array containing first the length of the array, then 
 * the number of buckets that contain something, then the number of 
 * values currently held in the hash.
 */

#include "value.h"

value value_hash_init()
{
	return value_hash_init_capacity(HASH_DEFAULT_CAPACITY);
}

value value_hash_init_capacity(size_t capacity)
{
	if (capacity == 0)
		capacity = HASH_DEFAULT_CAPACITY;
	else if (capacity < 0) {
		value_error(1, "Argument Error: Cannot initialize a hash with capacity %d.", capacity);
		return value_init_error();
	}
	
	value hash;
	
	hash.type = VALUE_HSH;
	hash.core.u_h.a = value_malloc(NULL, sizeof(value) * next_size(capacity));
	return_if_null(hash.core.u_h.a);
	hash.core.u_h.length = capacity;
	hash.core.u_h.occupied = 0;
	hash.core.u_h.size = 0;
	
	size_t i;
	for (i = 0; i < capacity; ++i)
		hash.core.u_h.a[i] = value_init_nil();
				
	return hash;
}

void value_hash_clear(value *hash)
{
	if (hash->type != VALUE_HSH) {
		value_error(1, "Type Error: hash_clear() is undefined where hash is %ts (hash expected).", *hash);
		return;
	}
	size_t i, length = value_hash_length(*hash);
	
	for (i = 0; i < length; ++i)
		value_clear(&hash->core.u_h.a[i]);
	
value_free(hash->core.u_h.a);
	hash->type = VALUE_NIL;
}

/* The length of the array used to represent the hash.
 */
size_t value_hash_length(value hash)
{
	if (hash.type != VALUE_HSH) {
		value_error(1, "Type Error: hash_length() is undefined where hash is %ts (hash expected).", hash);
		return -1;
	}
	return hash.core.u_h.length;
}

/* A count of the number of currently occupied buckets.
 */
size_t value_hash_occupied(value hash)
{
	if (hash.type != VALUE_HSH) {
		value_error(1, "Type Error: hash_occupied() is undefined where hash is %ts (hash expected).", hash);
		return -1;
	}
	return hash.core.u_h.occupied;
}

/* The number of elements in the hash.
 */
size_t value_hash_size(value hash)
{
	if (hash.type != VALUE_HSH) {
		value_error(1, "Type Error: hash_size() is undefined where hash is %ts (hash expected).", hash);
		return -1;
	}
	return hash.core.u_h.size;
}

value value_hash_resize(value *hash)
{
	if (hash->type != VALUE_HSH) {
		value_error(1, "Type Error: hash_resize() is undefined where hash is %ts (hash expected).", *hash);
		return value_init_error();
	}
	size_t inner_len, length = value_hash_length(*hash);
	
	value new = value_hash_init_capacity(next_size(length * 4));
	size_t i, j;
	for (i = 0; i < length; ++i) {
		if (hash->core.u_h.a[i].type == VALUE_NIL)
			continue;
		inner_len = value_length(hash->core.u_h.a[i]);
		for (j = 0; j < inner_len; ++j)
			value_hash_put_refs(&new, &hash->core.u_h.a[i].core.u_a.a[j].core.u_a.a[0], &hash->core.u_h.a[i].core.u_a.a[j].core.u_a.a[1]);
	}
	
	// Don't clear the keys and the values, because they are now references in the new hash. But clear everything else.
//	value_hash_clear(hash);
	for (i = 0; i < length; ++i) {
		if (hash->core.u_h.a[i].type == VALUE_NIL)
			continue;
		inner_len = value_length(hash->core.u_h.a[i]);
		for (j = 0; j < inner_len; ++j)
		value_free(hash->core.u_h.a[i].core.u_a.a[j].core.u_a.a);
		value_free(hash->core.u_h.a[i].core.u_a.a);
	}
	
	value_free(hash->core.u_h.a);
	
	*hash = new;
	
	return value_init_nil();
}

value value_hash_put(value *hash, value key, value val)
{
	value k = value_set(key), v = value_set(val);
	return value_hash_put_refs(hash, &k, &v);
}

value value_hash_put_refs(value *hash, value *key, value *val)
{
	return value_hash_put_refs_generic(hash, key, val, TRUE);
}

value value_hash_put_refs_override(value *hash, value *key, value *val)
{
	return value_hash_put_refs_generic(hash, key, val, FALSE);
}

value value_hash_put_refs_generic(value *hash, value *key, value *val, int clear_p)
{
	if (hash->type != VALUE_HSH) {
		value_error(1, "Type Error: hash_put_refs() is undefined where hash is %ts (hash expected).", *hash);
		return value_init_error();
	}
	
	size_t length = value_hash_length(*hash);
	if (length == 0) {
		value_hash_clear(hash);
		*hash = value_hash_init();
		length = value_hash_length(*hash);
	}
	size_t index = value_private_hash_function(*key) % length;
	
	int count;
	if (hash->core.u_h.a[index].type == VALUE_NIL) {
		// This bucket hasn't been initialized. Initialize it, and add the first element.
		value ary[] = { *key, *val };
		
		hash->core.u_h.a[index].type = VALUE_ARY;
		hash->core.u_h.a[index].core.u_a.a = value_malloc(NULL, sizeof(value) * next_size(1));
		if (hash->core.u_h.a[index].core.u_h.a == NULL) {
			return value_init_nil();
		}
		hash->core.u_h.a[index].core.u_a.length = 1;
		hash->core.u_h.a[index].core.u_a.a[0] = value_set_ary_ref(ary, 2);
		++hash->core.u_h.occupied;
		count = 1;
	} else {
		if (hash->core.u_h.a[index].core.u_a.length == 0)
			++hash->core.u_h.occupied;
		
		count = value_private_put_pair_in_bucket(&hash->core.u_h.a[index], key, val, clear_p);
		if (count == VALUE_ERROR) {
			return value_init_error();
		}
	}

	hash->core.u_h.size += count;

	/* If more than 75% of the indices are occupied, it's to make a new, bigger hash. */
	if ((hash->core.u_h.occupied * 100) / length > 75) {
		value_hash_resize(hash);
	}
	
	return value_init_nil();
}

value value_hash_put_str(value *hash, const char *key, value val)
{
	if (hash->type != VALUE_HSH) {
		value_error(1, "Type Error: hash_put_str() is undefined where hash is %ts (hash expected).", *hash);
		return value_init_error();
	}

	value vkey;
	
	vkey.type = VALUE_STR;
	value_malloc(&vkey, strlen(key) + 1);
	if (vkey.type == VALUE_ERROR) return vkey;
	strcpy(vkey.core.u_s, key);
	value res = value_hash_put(hash, vkey, val);
	value_free(vkey.core.u_s);
	
	return res;
}

value value_hash_put_var(value *hash, const char *key, value val)
{
	if (hash->type != VALUE_HSH) {
		value_error(1, "Type Error: hash_put_str() is undefined where hash is %ts (hash expected).", *hash);
		return value_init_error();
	}

	value vkey;
	
	vkey.type = VALUE_VAR;
	value_malloc(&vkey, strlen(key) + 1);
	if (vkey.type == VALUE_ERROR) return vkey;
	strcpy(vkey.core.u_s, key);
	value res = value_hash_put(hash, vkey, val);
	value_free(vkey.core.u_s);
	
	return res;
}

value value_hash_put_str_str(value *hash, const char *key, const char *val)
{
	if (hash->type != VALUE_HSH) {
		value_error(1, "Type Error: hash_put_str_str() is undefined where hash is %ts (hash expected).", *hash);
		return value_init_error();
	}
	value vkey;
	
	vkey.type = VALUE_STR;
	value_malloc(&vkey, strlen(key) + 1);
	if (vkey.type == VALUE_ERROR) return vkey;
	strcpy(vkey.core.u_s, key);
	
	value vval;
	
	vval.type = VALUE_STR;
	value_malloc(&vval, strlen(val) + 1);
	if (vval.type == VALUE_ERROR) return vval;
	strcpy(vval.core.u_s, val);
	
	return value_hash_put_refs(hash, &vkey, &vval);
}

int value_hash_exists(value hash, value key)
{
	if (hash.type != VALUE_HSH) {
		value_error(1, "Type Error: hash_exists() is undefined where hash is %ts (hash expected).", hash);
		return FALSE;
	}
	size_t i, length = value_hash_length(hash);
	if (length == 0)
		return FALSE;
	size_t index = value_private_hash_function(key) % length;
	if (hash.core.u_h.a[index].type == VALUE_NIL)
		return FALSE;
	size_t inner_len = value_length(hash.core.u_h.a[index]);
	for (i = 0; i < inner_len; ++i)
		if (value_eq(hash.core.u_h.a[index].core.u_a.a[i].core.u_a.a[0], key))
			return TRUE;
	return FALSE;
}

int value_hash_exists_str(value hash, char *key)
{
	if (hash.type != VALUE_HSH) {
		value_error(1, "Type Error: hash_exists_str() is undefined where hash is %ts (hash expected).", hash);
		return FALSE;
	}
	value vkey;
	
	vkey.type = VALUE_STR;
	value_malloc(&vkey, strlen(key) + 1);
	if (vkey.type == VALUE_ERROR) return FALSE;
	strcpy(vkey.core.u_s, key);
	int res = value_hash_exists(hash, vkey);
value_free(vkey.core.u_s);
	return res;
}

int value_contains_value(value op, value val)
{
	if (op.type != VALUE_HSH) {
		value_error(1, "Type Error: contains_value() is undefined where op is %ts (hash expected.", op);
		return FALSE;
	}
	
	size_t i, length = value_hash_length(op);
	size_t index = value_private_hash_function(val) % length;
	if (op.core.u_h.a[index].type == VALUE_NIL)
		return FALSE;
	size_t inner_len = value_length(op.core.u_h.a[index]);
	for (i = 0; i < inner_len; ++i)
		if (value_eq(op.core.u_h.a[index].core.u_a.a[i].core.u_a.a[1], val))
			return TRUE;
	
	return FALSE;
}

value value_contains_value_std(value op, value val)
{
	if (op.type != VALUE_HSH) {
		value_error(1, "Type Error: contains_value() is undefined where hash is %ts (hash expected).", op);
		return value_init_error();
	}
	return value_set_bool(value_contains_value(op, val));
}

value value_contains_value_arg(int argc, value argv[])
{
	return value_contains_value_std(argv[0], argv[1]);
}

value value_hash_delete_at(value *hash, value key)
{
	if (hash->type != VALUE_HSH) {
		value_error(1, "Type Error: hash_delete_at() is undefined where hash is %ts (hash expected).", *hash);
		return value_init_error();
	}
	
	size_t length = hash->core.u_h.length;
	if (length == 0)
		return value_init_nil();
	size_t index = value_private_hash_function(key) % length;
	if (hash->core.u_h.a[index].type == VALUE_NIL)
		return value_init_nil();
	
	value res = value_init_nil();
	value ptr = hash->core.u_h.a[index];
	
	size_t i;
	for (i = 0; i < ptr.core.u_a.length; ++i) {
		if (value_eq(ptr.core.u_a.a[i].core.u_a.a[0], key)) {
			--hash->core.u_h.size;
			--hash->core.u_h.a[index].core.u_a.length;
			res = ptr.core.u_a.a[i];
//			memmove(ptr.core.u_a.a + i, ptr.core.u_a.a + i + 1, ptr.core.u_a.length - i);
			for (; i < ptr.core.u_a.length; ++i)
				ptr.core.u_a.a[i] = ptr.core.u_a.a[i+1];
			
			if (hash->core.u_h.a[index].core.u_a.length == 0)
				--hash->core.u_h.occupied;
		}
	}
	
	return res;
}

void value_hash_delete_at_void(value *hash, value key)
{
	value clr = value_hash_delete_at(hash, key);
	value_clear(&clr);
}

/* 
 * Returns a reference to the object.
 * 
 * Warning: If the value is not found, returns NULL. Also returns NULL if there is 
 * an error. But the only case in which an error will return NULL is when (hash) is  
 * not a VALUE_HSH, so that should be easily avoidable.
 */
value * value_hash_get_ref(value hash, value key)
{
	if (hash.type != VALUE_HSH) {
		value_error(1, "Type Error: hash_get_ref() is undefined where hash is %ts (hash expected).", hash);
		return NULL;
	}
	size_t length = value_hash_length(hash);
	if (length == 0)
		return NULL;
	size_t index = value_private_hash_function(key) % length;
	if (hash.core.u_h.a[index].type == VALUE_NIL)
		return NULL;
	value pair = value_private_find_pair_in_bucket(hash.core.u_h.a[index], key);
	if (pair.type == VALUE_NIL)
		return NULL;
	return &pair.core.u_a.a[1];
}

/* Returns nil if the key is not found.
 */
value value_hash_get(value hash, value key)
{
	if (hash.type != VALUE_HSH) {
		value_error(1, "Type Error: hash_get() is undefined where hash is %ts (hash expected).", hash);
		return value_init_error();
	}
	value *ref = value_hash_get_ref(hash, key);
	if (ref == NULL) return value_init_nil();
	return value_set(*ref);
}

value * value_hash_get_ref_str(value hash, char *key)
{
	if (hash.type != VALUE_HSH) {
		value_error(1, "Type Error: hash_get_ref_str() is undefined where hash is %ts (hash expected).", hash);
		return NULL;
	}
	value vkey;
	
	vkey.type = VALUE_STR;
	value_malloc(&vkey, strlen(key) + 1);
	if (vkey.type == VALUE_ERROR) return NULL;
	strcpy(vkey.core.u_s, key);
	value *res = value_hash_get_ref(hash, vkey);
value_free(vkey.core.u_s);
	return res;
}

value value_hash_get_str(value hash, char *key)
{
	if (hash.type != VALUE_HSH) {
		value_error(1, "Type Error: hash_get_str() is undefined where hash is %ts (hash expected).", hash);
		return value_init_error();
	}
	value vkey;
	
	vkey.type = VALUE_STR;
	value_malloc(&vkey, strlen(key) + 1);
	return_if_error(vkey);
	strcpy(vkey.core.u_s, key);
	value res = value_hash_get(hash, vkey);
value_free(vkey.core.u_s);
	return res;
}

value * value_hash_get_pair_ref(value hash, value key)
{
	if (hash.type != VALUE_HSH) {
		value_error(1, "Type Error: hash_get_pair_ref() is undefined where hash is %ts (hash expected).", hash);
		return NULL;
	}
	size_t length = value_hash_length(hash);
	if (length == 0)
		return NULL;
	size_t index = value_private_hash_function(key) % length;
	if (hash.core.u_h.a[index].type == VALUE_NIL)
		return NULL;
	value *pair = value_malloc(NULL, sizeof(value));
	if (pair == NULL) return pair;
	*pair = value_private_find_pair_in_bucket(hash.core.u_h.a[index], key);
	if (pair->type == VALUE_NIL)
		return NULL;
	
	return pair;
}

value value_hash_get_pair(value hash, value key)
{
	if (hash.type != VALUE_HSH) {
		value_error(1, "Type Error: get_pair() is undefined where hash is %ts (hash expected).", hash);
		return value_init_error();
	}
	value *ref = value_hash_get_pair_ref(hash, key);
	if (ref == NULL) return value_init_nil();
	return value_set(*ref);
}

/* Assumes that bucket is of the correct type.
 * 
 * A return value of 0 indicates that a previous value was overwritten. 1 indicates 
 * that a new pair was created.
 */
int value_private_put_pair_in_bucket(value *bucket, value *key, value *val, int clear_p)
{	
	size_t i, length = value_length(*bucket);
	for (i = 0; i < length; ++i) {
		if (bucket->core.u_a.a[i].type == VALUE_ARY && value_eq(bucket->core.u_a.a[i].core.u_a.a[0], *key)) {
			if (clear_p) {
				value_clear(&bucket->core.u_a.a[i].core.u_a.a[0]);
				value_clear(&bucket->core.u_a.a[i].core.u_a.a[1]);
			}
			bucket->core.u_a.a[i].core.u_a.a[0] = *key;
			bucket->core.u_a.a[i].core.u_a.a[1] = *val;
			return 0;
		}
	}
	
	// Add the new pair to the end of the array.
	value pair;
	
	pair.type = VALUE_ARY;
	// The pair will never be reallocated so it's (* 2) and not (* next_size(2)).
	pair.core.u_a.length = 2;
	pair.core.u_a.a = value_malloc(NULL, sizeof(value) * 2);
	if (pair.core.u_a.a == NULL) return VALUE_ERROR;
	pair.core.u_a.a[0] = *key;
	pair.core.u_a.a[1] = *val;
		
	value_append_now2(bucket, &pair);
	return 1;
}

/* Assumes that (bucket) is already of type VALUE_ARY and that each element 
 * of (bucket) is a two-element array.
 */
value value_private_find_pair_in_bucket(value bucket, value key)
{
	size_t i, length = value_length(bucket);
	for (i = 0; i < length; ++i)
		if (value_eq(bucket.core.u_a.a[i].core.u_a.a[0], key))
			return bucket.core.u_a.a[i];
	return value_init_nil();
}

int value_private_hash_function_old(value op)
{
	int hash = 5381;

	char *tmp = value_to_string(op);
	--tmp;
	
	while (*(++tmp))
		hash = ((hash << 5) + hash) + *tmp;
		
	// Just in case it overflowed, return the absolute value.
	return (size_t) abs(hash);
}

size_t value_private_hash_function(value op)
{
	size_t hash = 5381 - VALUE_STR + op.type;
	char *tmp;
	
	switch (op.type) {
		case VALUE_NIL:
		case VALUE_INF:
		case VALUE_ERROR:
			break;
		case VALUE_BOO:
			hash += op.core.u_b;
			break;
		case VALUE_MPZ:
			// The number is randomized by a single iteration of a Linear Congruential 
			// Generator. It's likely that the most common numbers will be close 
			// together (e.g. 0, 1, 2, 3) so this will separate them.
			hash += mpz_get_si(op.core.u_mz) * 1103515245 + 12345;
			break;
		case VALUE_MPF:
			// A similar idea to MPZ. Adds INT_MAX/2 so that 1, 2, 3 won't hash to the 
			// same things as 1.0, 2.0, 3.0.
			hash += (size_t) ((mpfr_get_d(op.core.u_mf, value_mpfr_round) + INT_MAX/2) * 1103515245 + 12345);
			break;
		case VALUE_STR:
		case VALUE_ID:
		case VALUE_VAR:
			tmp = op.core.u_s - 1;
			while (*(++tmp))
				hash = ((hash << 5) + hash) + *tmp;
			break;
		case VALUE_ARY:
		case VALUE_HSH:
		case VALUE_BLK:
			;
			size_t i;
			// What (length / 10) + 1 does is that it ensures that no more than 
			// ten elements out of the array will be hashed. Doing more than that 
			// would be slow and not provide much benefit.
			for (i = 0; i < op.core.u_h.length; i += (op.core.u_h.length / 10) + 1)
				hash += value_private_hash_function(op.core.u_a.a[i]);
			hash += op.core.u_h.length;
			break;
		case VALUE_LST:
			hash += value_private_hash_function(op.core.u_l[0]);
			hash += value_private_hash_function(op.core.u_l[1]);
		case VALUE_PTR:
			hash += value_private_hash_function(*op.core.u_ptr);
		default:
			break;
	}
	
	// Just in case it overflowed, return the absolute value.
	return (size_t) abs(hash);	
}

int value_hash_print(value hash)
{
	if (hash.type != VALUE_HSH) {
		value_error(1, "Type Error: hash_print() is undefined where hash is %ts (hash expected).", hash);
		return -1;
	}
	size_t i, length = value_hash_length(hash);
	printf("{ ");
	for (i = 0; i < length; ++i) {
		if (hash.core.u_h.a[i].type == VALUE_NIL)
			continue;
		size_t j, inner_len = value_length(hash.core.u_h.a[i]);
		for (j = 0; j < inner_len; ++j) {
			value_print(hash.core.u_h.a[i].core.u_a.a[j].core.u_a.a[0]);
			printf(" -> ");
			value_print(hash.core.u_h.a[i].core.u_a.a[j].core.u_a.a[1]);
			printf(", ");
		}
	}
	
	printf("}");
	return 0;
}

int value_hash_println(value hash)
{
	if (hash.type != VALUE_HSH) {
		value_error(1, "Type Error: hash_clear() is undefined where hash is %ts (hash expected).", hash);
		return -1;
	}
	value_hash_print(hash);
	printf("\n");
	return 0;
}

/*
 *  value_list.c
 *  Calculator
 *
 *  Created by Michael Dickens on 3/15/10.
 *
 */

#include "value.h"

/* 
 * Functions for working with lists. Notice that all of these functions 
 * work with arrays as well.
 */

/* 
 * Linked List Implementation
 * 
 * Linked lists are implemented as a two-element array in core.u_l, 
 * which is pretty much identical to core.u_a; the difference in name 
 * is only for clarification purposes. The first element is the actual 
 * value, and the second element is a pointer to the next list. If it 
 * is the end of the list, this should be VALUE_NIL.
 * 
 * The implementation of empty lists is a little unconventional. An 
 * empty list is not stored as NULL because this decentralizes memory 
 * allocation (it would be nice to always allocate memory in value_init(), 
 * but if in value_init() the list is set to NULL then this doesn't 
 * work so memory allocation has to be done elsewhere). So instead, 
 * a list is considered empty when its tail (cdr) is VALUE_NIL and its  
 * head (car) is VALUE_EMPTY. If the head is ever VALUE_EMPTY when the 
 * tail is not VALUE_NIL, or if an array element is VALUE_EMPTY or 
 * something like that, then it is wrong. The only time when VALUE_EMPTY 
 * is to be used is to denote a list as empty.
 * 
 * If you want to find the tail of a list you can use tail(), but in many 
 * cases this is not what you want to do. This will create a copy of the 
 * tail and return it. To directly access the tail of (list), use 
 * list.core.u_l[1]. Similarly, the head can be accessed by using
 * list.core.u_l[0].
 */

value value_cons(value op1, value op2)
{
	value res = value_init_nil();
	if (op2.type == VALUE_NIL) {
		res = value_init(VALUE_LST);
		res.core.u_l[0] = value_set(op1);
	} else if (op2.type == VALUE_ARY) {
		size_t length = value_length(op2) + 1;
		value array[length];
		array[0] = op1;
		size_t i;
		for (i = 1; i < length; ++i)
			array[i] = op2.core.u_a.a[i-1];
		res = value_set_ary(array, length);
	} else if (op2.type == VALUE_LST) {
		res = value_init(VALUE_LST);
		res.core.u_l[0] = value_set(op1);
		res.core.u_l[1] = value_set(op2);
	} else {
		value_error(1, "Type Error: cons() is undefined where op2 is %ts (nil, array or list expected).", op2);
		res = value_init_error();
	}
	
	return res;
}

value value_cons_now(value op1, value *op2)
{
	value tmp = value_set(op1);
	return value_cons_now2(&tmp, op2);
}

value value_cons_now2(value *op1, value *op2)
{
	if (op2->type == VALUE_NIL) {
		op2->type = VALUE_LST;
		value_malloc(op2, 2);
		if (op2->type == VALUE_ERROR) return;
		op2->core.u_l[0] = *op1;
		op2->core.u_l[1] = value_init_nil();
		
	} else if (op2->type == VALUE_ARY) {
		value res;
		res.type = VALUE_ARY;
		size_t i, length = value_length(*op2);
		if (resize_p(length+1)) {
			value_realloc(op1, next_size(length+1) + 1);
			if (op1->type == VALUE_ERROR)
				return value_init_error();
		}
		for (i = 1; i < length; ++i)
			res.core.u_a.a[i+1] = op2->core.u_a.a[i];
		res.core.u_a.a[0] = *op1;
		res.core.u_a.length = op2->core.u_a.length + 1;
		*op2 = res;
	} else if (op2->type == VALUE_LST) {
		value res;
		res.type = VALUE_LST;
		value_malloc(&res, 2);
		if (res.type == VALUE_ERROR) {
			return value_init_error();
		}
		res.core.u_l[0] = *op1;
		res.core.u_l[1] = *op2;
		*op2 = res;		
	} else {
		value_error(1, "Type Error: cons() is undefined where op2 is %ts (nil, array or list expected).", *op2);
		return value_init_error();
	}
	
	return value_init_nil();
}

value value_drop(value op, value n)
{
	if (op.type == VALUE_NIL) {
		return value_init_nil();
	} else if (op.type == VALUE_ARY) {
		if (n.type == VALUE_MPZ) {
			value length = value_set_long(op.core.u_a.length);
			value res = value_range(op, n, length);
			value_clear(&length);
			return res;
		}
	} else if (op.type == VALUE_LST) {
		if (n.type == VALUE_MPZ) {
			if (value_lt(n, value_zero)) {
				value_error(1, "Domain Error: drop() is undefined where n is %s (>= 0 expected).", n);
				return value_init_error();
			} else if (value_gt(n, value_int_max)) {
				value_error(1, "Domain Error: drop() is undefined where n is %s (<= %s expected).", n, value_int_max);
				return value_init_error();				
			}
			size_t i, max = value_get_long(n);
			value ptr = op;
			for (i = 0; i < max && ptr.type == VALUE_LST; ++i) {
				ptr = ptr.core.u_l[1];
			}
			
			return value_set(ptr);
		}
	} else if (op.type == VALUE_PAR) {
		if (n.type == VALUE_MPZ) {
			if (value_lt(n, value_zero)) {
				value_error(1, "Domain Error: drop() is undefined where n is %s (>= 0 expected).", n);
				return value_init_error();
			} else if (value_gt(n, value_int_max)) {
				value_error(1, "Domain Error: drop() is undefined where n is %s (<= %s expected).", n, value_int_max);
				return value_init_error();				
			}
			size_t i, max = value_get_long(n);
			value ptr = op;
			for (i = 0; i < max && ptr.type == VALUE_PAR; ++i) {
				ptr = ptr.core.u_p->tail;
			}
			
			return value_set(ptr);
		}
	} else {
		value_error(1, "Type Error: drop() is undefined where op1 is %ts (array or list expected).", op);
		if (n.type == VALUE_MPZ)
			return value_init_error();
	}
	
	value_error(1, "Type Error: drop() is undefined where op2 is %ts (integer expected).", n);
	return value_init_error();
}

value value_head(value op)
{
	if (op.type == VALUE_ARY) {
		if (value_length(op) == 0) {
			value_error(1, "Error: cannot find head() of an empty array.");
			return value_init_error();
		}

		return value_set(op.core.u_a.a[0]);
	} else if (op.type == VALUE_LST) {
		return value_set(op.core.u_l[0]);
	} else if (op.type == VALUE_PAR) {
		return value_set(op.core.u_p->head);
	} else {
		value_error(1, "Type Error: head() is undefined where op is %ts (array or list expected).", op);
		return value_init_error();
	}
}

value * value_head_ref(value op)
{
	if (op.type == VALUE_ARY) {
		if (value_length(op) == 0) {
			value_error(1, "Error: cannot find head() of an empty array.");
			return NULL;
		}

		return &op.core.u_a.a[0];
	} else if (op.type == VALUE_LST) {
		return &op.core.u_l[0];
	} else if (op.type == VALUE_PAR) {
		return &op.core.u_p->head;
	} else {
		value_error(1, "Type Error: head() is undefined where op is %ts (array or list expected).", op);
	}

	return NULL;
}

value value_tail(value op)
{
	if (op.type == VALUE_ARY) {
		size_t length = value_length(op);
		if (length == 0) {
			value_error(1, "Error: cannot find tail() of an empty array.");
			return value_init_error();
		}
		
		value array[length - 1];
		size_t i;
		for (i = 0; i < length-1; ++i)
			array[i] = op.core.u_a.a[i+1];
		
		value res = value_set_ary(array, length-1);
		
		return res;
		
	} else if (op.type == VALUE_LST) {		
		return value_set(op.core.u_l[1]);
		
	} else if (op.type == VALUE_PAR) {
		return value_set(op.core.u_p->tail);
	} else {
		value_error(1, "Type Error: tail() is undefined where op is %ts (array or list expected).", op);
		return value_init_error();
	}

}

value value_tail_now(value *op)
{
	if (op->type == VALUE_NIL) {
		value_error(1, "Error: cannot find tail!() of an empty list.");
		return value_init_error();
	} else if (op->type == VALUE_ARY) {
		size_t i, length = value_length(*op);
		if (length == 0) {
			value_error(1, "Error: cannot find tail!() of an empty array.");
			return value_init_error();
		}
		
		value_clear(&op->core.u_a.a[0]);
		for (i = 0; i < length-1; ++i)
			op->core.u_a.a[i] = op->core.u_a.a[i+1];
		
		--op->core.u_a.length;
	} else if (op->type == VALUE_LST) {
		if (value_empty_p(*op)) {
			value_error(1, "Error: cannot find tail!() of an empty list.");
			return value_init_error();
		} else {
			value_clear(&op->core.u_l[0]);
			value_free(op->core.u_l);
			*op = op->core.u_l[1];
		}
	} else if (op->type == VALUE_PAR) {
		value tmp = op->core.u_p->tail;
		value_clear(&op->core.u_p->head);
		value_free(op->core.u_p);
		*op = tmp;
	} else {
		value_error(1, "Type Error: tail!() is undefined where op is %ts (array or list expected).", *op);
		return value_init_error();
	}

	
	return value_init_nil();
}

value value_take(value op, value n)
{
	if (op.type == VALUE_NIL) {
		return value_init_nil();
	} else if (op.type == VALUE_ARY) {
		if (n.type == VALUE_MPZ) {
			value start = value_set_long(0);
			value res = value_range(op, start, n);
			value_clear(&start);
			return res;
		}
	} else if (op.type == VALUE_LST) {
		if (n.type == VALUE_MPZ) {
			if (value_lt(n, value_zero)) {
				value_error(1, "Domain Error: drop() is undefined where n is %s (>= 0 expected).", n);
				return value_init_error();
			} else if (value_gt(n, value_int_max)) {
				value_error(1, "Domain Error: drop() is undefined where n is %s (<= %s expected).", n, value_int_max);
				return value_init_error();				
			}
			
			value res = value_init_nil();
			size_t i, max = value_get_long(n);
			value ptr = op;
			for (i = 0; i < max && ptr.type == VALUE_LST; ++i) {
				value_cons_now(ptr.core.u_l[0], &res);
				ptr = ptr.core.u_l[1];
			}
			
			value_reverse_now(&res);
			
			return res;
		}
	} else if (op.type == VALUE_PAR) {
		if (n.type == VALUE_MPZ) {
			if (value_lt(n, value_zero)) {
				value_error(1, "Domain Error: drop() is undefined where n is %s (>= 0 expected).", n);
				return value_init_error();
			} else if (value_gt(n, value_int_max)) {
				value_error(1, "Domain Error: drop() is undefined where n is %s (<= %s expected).", n, value_int_max);
				return value_init_error();				
			}
			
			value res = value_init_nil();
			size_t i, max = value_get_long(n);
			value ptr = op;
			for (i = 0; i < max && ptr.type == VALUE_PAR; ++i) {
				value_cons_now(ptr.core.u_p->tail, &res);
				ptr = ptr.core.u_p->tail;
			}
			
			value_reverse_now(&res);
			
			return res;
		}
	} else {
		value_error(1, "Type Error: take() is undefined where op is %ts (array or list expected).", op);
		if (n.type == VALUE_MPZ)
			return value_init_error();
	}
	
	value_error(1, "Type Error: drop() is undefined where n is %ts (integer expected).", n);
	return value_init_error();

}

value value_cons_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "cons()") ? value_init_error() : value_cons(argv[0], argv[1]);
}

value value_cons_now_arg(int argc, value argv[])
{
	if (missing_arguments(argc, argv, "cons!()"))
		return value_init_error();
	value_cons_now(argv[0], &argv[1]);
	return value_init_nil();
}

value value_drop_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "drop()") ? value_init_error() : value_drop(argv[0], argv[1]);
}

value value_head_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "head()") ? value_init_error() : value_head(argv[0]);
}

value value_tail_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "tail()") ? value_init_error() : value_tail(argv[0]);
}

value value_take_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "take()") ? value_init_error() : value_take(argv[0], argv[1]);
}

/*
 *  value_number.c
 *  Simfpl
 *
 *  Created by Michael Dickens on 6/2/10.
 *  Copyright 2010 The Khabele School. All rights reserved.
 *
 */

#include "value.h"

value value_add(value op1, value op2)
{
	value res = value_init_error();
	
	if (op1.type == VALUE_MPZ && op2.type == VALUE_MPZ) {
		res = value_init(VALUE_MPZ);
		mpz_add(res.core.u_mz, op1.core.u_mz, op2.core.u_mz);
	} else if (op1.type == VALUE_MPZ && op2.type == VALUE_MPF) {
		res = value_init(VALUE_MPF);
		mpfr_set_z(res.core.u_mf, op1.core.u_mz, value_mpfr_round);
		mpfr_add(res.core.u_mf, res.core.u_mf, op2.core.u_mf, value_mpfr_round);
	} else if (op1.type == VALUE_MPF && op2.type == VALUE_MPZ) {
		res = value_init(VALUE_MPF);
		mpfr_set_z(res.core.u_mf, op2.core.u_mz, value_mpfr_round);
		mpfr_add(res.core.u_mf, op1.core.u_mf, res.core.u_mf, value_mpfr_round);
	} else if (op1.type == VALUE_MPF && op2.type == VALUE_MPF) {
		res = value_init(VALUE_MPF);
		mpfr_add(res.core.u_mf, op1.core.u_mf, op2.core.u_mf, value_mpfr_round);
	} else if (op1.type == VALUE_STR && op2.type == VALUE_STR) {
		int length = strlen(op1.core.u_s) + strlen(op2.core.u_s);
		char str[length+1];
		strcpy(str, op1.core.u_s);
		strcpy(str+strlen(op1.core.u_s), op2.core.u_s);
		res = value_set_str(str);
	} else if (op1.type == VALUE_STR) {
		op2 = value_cast(op2, VALUE_STR);
		int length = strlen(op1.core.u_s) + strlen(op2.core.u_s);
		char str[length+1];
		strcpy(str, op1.core.u_s);
		strcpy(str+strlen(op1.core.u_s), op2.core.u_s);
		res = value_set_str(str);
		value_clear(&op2);
	} else if (op1.type == VALUE_RGX && op2.type == VALUE_RGX) {
		int length = strlen(op1.core.u_x) + strlen(op2.core.u_x);
		char *str = value_malloc(NULL, length+1);
		return_if_null(str);
		strcpy(str, op1.core.u_s);
		strcpy(str+strlen(op1.core.u_x), op2.core.u_x);
		res.type = VALUE_RGX;
		res.core.u_x = str;
	} else if (op1.type == VALUE_ARY && op2.type == VALUE_ARY
			|| op1.type == VALUE_PAR && op2.type == VALUE_PAr) {
		res = value_concat(op1, op2);
	} else if (op1.type == VALUE_ARY || op1.type == VALUE_PAR) {
		res = value_append(op1, op2);
	} else if (op2.type == VALUE_ARY || op2.type == VALUE_PAR) {
		res = value_cons(op1, op2);
	} else if (op2.type == VALUE_STR) {
		op1 = value_cast(op1, VALUE_STR);
		int length = strlen(op1.core.u_s) + strlen(op2.core.u_s);
		char str[length+1];
		strcpy(str, op1.core.u_s);
		strcpy(str+strlen(op1.core.u_s), op2.core.u_s);
		res = value_set_str(str);
		value_clear(&op1);
	} else {
		value_error(1, "Argument Error: Addition is undefined for %ts and %ts.", op1, op2);
	}
	
	return res;
}

value value_add_now(value *op1, value op2)
{	
	value res = value_init_nil();
	
	if (op1->type == VALUE_MPZ && op2.type == VALUE_MPZ) {
		mpz_add(op1->core.u_mz, op1->core.u_mz, op2.core.u_mz);
	} else if (op1->type == VALUE_MPZ && op2.type == VALUE_MPF) {
		value tmp;
		tmp.type = VALUE_MPF;
		mpfr_init_set_z(tmp.core.u_mf, op1->core.u_mz, value_mpfr_round);
		mpfr_add(tmp.core.u_mf, tmp.core.u_mf, op2.core.u_mf, value_mpfr_round);
		value_clear(op1);
		*op1 = tmp;
	} else if (op1->type == VALUE_MPF && op2.type == VALUE_MPZ) {
		mpfr_add_z(op1->core.u_mf, op1->core.u_mf, op2.core.u_mz, value_mpfr_round);
	} else if (op1->type == VALUE_MPF && op2.type == VALUE_MPF) {
		mpfr_add(op1->core.u_mf, op1->core.u_mf, op2.core.u_mf, value_mpfr_round);
	} else if (op1->type == VALUE_STR && op2.type == VALUE_STR) {
		size_t len1 = strlen(op1->core.u_s), len2 = strlen(op2.core.u_s);
		size_t length = len1 + len2;
		value_realloc(op1, length + 1);
		if (op1->type == VALUE_ERROR)
			return value_init_error();
		strcpy(op1->core.u_s + len1, op2.core.u_s);
	} else if (op1->type == VALUE_STR) {
		op2 = value_cast(op2, VALUE_STR);
		if (op2.type == VALUE_ERROR)
			return op2;
		res = value_add_now(op1, op2);
		value_clear(&op2);
	} else if (op2.type == VALUE_STR) {
		value cast = value_cast(*op1, VALUE_STR);
		if (cast.type == VALUE_ERROR)
			return cast;
		res = value_add_now(&cast, op2);
		value_clear(op1);
		*op1 = cast;
	} else if (op1->type == VALUE_ARY && op2.type == VALUE_ARY
			|| op1->type == VALUE_PAR && op2.type == VALUE_PAR) {
		res = value_concat_now(op1, op2);
	} else if (op1->type == VALUE_ARY || op1->type == VALUE_PAR) {
		res = value_append_now(op1, op2);
	} else {
		value_error(1, "Type Error: In-place addition is undefined for %ts and %ts.", *op1, op2);
		res =  value_init_error();
	}
	
	return res;
}

value value_sub(value op1, value op2)
{
	value res;
	if (op1.type == VALUE_MPZ && op2.type == VALUE_MPZ) {
		res = value_init(VALUE_MPZ);
		mpz_sub(res.core.u_mz, op1.core.u_mz, op2.core.u_mz);
	} else if (op1.type == VALUE_MPZ && op2.type == VALUE_MPF) {
		res = value_init(VALUE_MPF);
		mpfr_set_z(res.core.u_mf, op1.core.u_mz, value_mpfr_round);
		mpfr_sub(res.core.u_mf, res.core.u_mf, op2.core.u_mf, value_mpfr_round);
	} else if (op1.type == VALUE_MPF && op2.type == VALUE_MPZ) {
		res = value_init(VALUE_MPF);
		mpfr_set_z(res.core.u_mf, op2.core.u_mz, value_mpfr_round);
		mpfr_sub(res.core.u_mf, op1.core.u_mf, res.core.u_mf, value_mpfr_round);
	} else if (op1.type == VALUE_MPF && op2.type == VALUE_MPF) {
		res = value_init(VALUE_MPF);
		mpfr_sub(res.core.u_mf, op1.core.u_mf, op2.core.u_mf, value_mpfr_round);
	} else {
		if (op1.type != VALUE_MPZ && op1.type != VALUE_MPF)
			value_error(1, "Type Error: Subtraction is undefined where op1 is %ts (number expected).", op1);
		if (op2.type != VALUE_MPZ && op2.type != VALUE_MPF)
			value_error(1, "Type Error: Subtraction is undefined where op2 is %ts (number expected).", op2);
	}
	
	return res;
}

value value_sub_now(value *op1, value op2)
{
	value res = value_sub(*op1, op2);
	if (res.type == VALUE_ERROR)
		return res;
	value_clear(op1);
	*op1 = res;
	return value_init_nil();
}

value value_mul(value op1, value op2)
{
	value res;
	if (op1.type == VALUE_MPZ && op2.type == VALUE_MPZ) {
		res = value_init(VALUE_MPZ);
		mpz_mul(res.core.u_mz, op1.core.u_mz, op2.core.u_mz);
	} else if (op1.type == VALUE_MPZ && op2.type == VALUE_MPF) {
		res = value_init(VALUE_MPF);
		mpfr_set_z(res.core.u_mf, op1.core.u_mz, value_mpfr_round);
		mpfr_mul(res.core.u_mf, res.core.u_mf, op2.core.u_mf, value_mpfr_round);
	} else if (op1.type == VALUE_MPF && op2.type == VALUE_MPZ) {
		res = value_init(VALUE_MPF);
		mpfr_set_z(res.core.u_mf, op2.core.u_mz, value_mpfr_round);
		mpfr_mul(res.core.u_mf, op1.core.u_mf, res.core.u_mf, value_mpfr_round);
	} else if (op1.type == VALUE_MPF && op2.type == VALUE_MPF) {
		res = value_init(VALUE_MPF);
		mpfr_mul(res.core.u_mf, op1.core.u_mf, op2.core.u_mf, value_mpfr_round);
	} else if (op1.type == VALUE_STR && op2.type == VALUE_MPZ) {
		value zero = value_set_long(0), max = value_set_ulong(LONG_MAX);
		if (value_lt(op2, zero)) {
			value_error(1, "Domain Error: Cannot multiply an array by a negative number.");
			return value_init_error(); 
		}
		if (value_gt(op2, max)) {
			value_error(1, "Domain Error: Cannot multiply an array by a number larger than LONG_MAX.");
			return value_init_error();
		}
		value_clear(&zero); value_clear(&max);
		
		unsigned long count = mpz_get_ui(op2.core.u_mz);
		int len = strlen(op1.core.u_s);
		char str[len * count + 1]; *str = '\0';
		char *ptr = str;
		int i; for (i = 0; i < count; ++i, ptr += len)
			strcpy(ptr, op1.core.u_s);
		res = value_set_str(str);
	} else if (op1.type == VALUE_MPZ && op2.type == VALUE_STR) {
		if (value_lt(op1, value_zero)) {
			value_error(1, "Domain Error: Cannot multiply an array by a negative number.");
			return value_init_error(); 
		}
		if (value_gt(op1, value_int_max)) {
			value_error(1, "Domain Error: Cannot multiply an array by a number larger than LONG_MAX.");
			return value_init_error();
		}

		unsigned long count = mpz_get_ui(op1.core.u_mz);
		int len = strlen(op2.core.u_s);
		char str[len * count + 1]; *str = '\0';
		char *ptr = str;
		int i; for (i = 0; i < count; ++i, ptr += len)
			strcpy(ptr, op2.core.u_s);
		res = value_set_str(str);	
	} else if (op1.type == VALUE_ARY && op2.type == VALUE_MPZ) {
		if (value_lt(op2, value_zero)) {
			value_error(1, "Domain Error: Cannot multiply an array by a negative number.");
			return value_init_error(); 
		}
		if (value_gt(op2, value_int_max)) {
			value_error(1, "Domain Error: Cannot multiply an array by a number larger than %s.", value_int_max);
			return value_init_error();
		}
		size_t count = value_get_ulong(op2);
		size_t length = value_length(op1);
		
		value array[length * count];
				
		size_t i, j;
		for (i = 0; i < count; ++i)
			for (j = 0; j < length; ++j)
				array[i*length+j] = value_set(op1.core.u_a.a[j]);
		
		res = value_set_ary(array, length * count);
	} else if (op1.type == VALUE_MPZ && op2.type == VALUE_ARY) {
		if (value_lt(op2, value_zero)) {
			value_error(1, "Domain Error: Cannot multiply an array by a negative number.");
			return value_init_error(); 
		}
		if (value_gt(op2, value_int_max)) {
			value_error(1, "Domain Error: Cannot multiply an array by a number larger than %s.", value_int_max);
			return value_init_error();
		}
		size_t count = value_get_ulong(op1);
		size_t length = value_length(op2);
		
		value array[length * count];
				
		size_t i, j;
		for (i = 0; i < count; ++i)
			for (j = 0; j < length; ++j)
				array[i*length+j] = value_set(op2.core.u_a.a[j]);
		
		res = value_set_ary(array, length * count);
	} else if (op1.type == VALUE_PAR && op2.type == VALUE_MPZ) {
		if (value_lt(op2, value_zero)) {
			value_error(1, "Domain Error: Cannot multiply a string by negative number.");
			return value_init_error(); 
		}
		if (value_gt(op2, value_int_max)) {
			value_error(1, "Domain Error: Cannot multiply a string by a number larger than %s.", value_int_max);
			return value_init_error();
		}
		size_t count = value_get_ulong(op2);
		
		res = value_set(op1);
		size_t i;
		for (i = 1; i < count; ++i)
			value_concat_now(&res, op1);
				
	} else if (op1.type == VALUE_MPZ && op2.type == VALUE_PAR) {
		if (value_lt(op2, value_zero)) {
			value_error(1, "Domain Error: Cannot multiply a string by a negative number.");
			return value_init_error(); 
		}
		if (value_gt(op2, value_int_max)) {
			value_error(1, "Domain Error: Cannot multiply a string by a number larger than %s.", value_int_max);
			return value_init_error();
		}
		size_t count = value_get_ulong(op2);
		
		res = value_set(op2);
		size_t i;
		for (i = 1; i < count; ++i)
			value_concat_now(&res, op2);
	
	} else {
		value_error(1, "Type Error: Multiplication is undefined for %ts and %ts.", op1, op2);
		res = value_init_error();
	}
	
	return res;
}

value value_mul_now(value *op1, value op2)
{
	value res = value_mul(*op1, op2);
	if (res.type == VALUE_ERROR)
		return res;
	value_clear(op1);
	*op1 = res;
	return value_init_nil();
}

value value_div(value op1, value op2)
{
	if ((op1.type == VALUE_MPZ || op1.type == VALUE_MPF) && 
			value_eq(op2, value_zero)) {
		return value_init(VALUE_NAN);
	}

	value res;
		
	if (op1.type == VALUE_MPZ && op2.type == VALUE_MPZ) {
		res = value_init(VALUE_MPZ);
		mpz_div(res.core.u_mz, op1.core.u_mz, op2.core.u_mz);
	} else if (op1.type == VALUE_MPZ && op2.type == VALUE_MPF) {
		res = value_init(VALUE_MPF);
		mpfr_set_z(res.core.u_mf, op1.core.u_mz, value_mpfr_round);
		mpfr_div(res.core.u_mf, res.core.u_mf, op2.core.u_mf, value_mpfr_round);
	} else if (op1.type == VALUE_MPF && op2.type == VALUE_MPZ) {
		res = value_init(VALUE_MPF);
		mpfr_set_z(res.core.u_mf, op2.core.u_mz, value_mpfr_round);
		mpfr_div(res.core.u_mf, op1.core.u_mf, res.core.u_mf, value_mpfr_round);
	} else if (op1.type == VALUE_MPF && op2.type == VALUE_MPF) {
		res = value_init(VALUE_MPF);
		mpfr_div(res.core.u_mf, op1.core.u_mf, op2.core.u_mf, value_mpfr_round);
	} else {
		if (op1.type != VALUE_MPZ && op1.type != VALUE_MPF)
			value_error(1, "Type Error: Division is undefined where op1 is %ts (number expected).", op1);
		if (op2.type != VALUE_MPZ && op2.type != VALUE_MPF)
			value_error(1, "Type Error: Division is undefined where op2 is %ts (number expected).", op2);
	}
	
	return res;
}

value value_div_now(value *op1, value op2)
{
	value res = value_div(*op1, op2);
	if (res.type == VALUE_ERROR)
		return res;
	value_clear(op1);
	*op1 = res;
	return value_init_nil();
}

value value_mod(value op1, value op2)
{
	value res = value_init_error();
	value zero = value_set_long(0);
	if (op1.type == VALUE_MPZ && op2.type == VALUE_MPZ) {
		if (value_eq(op2, zero)) {
			value_error(1, "Arithmetic error: Modulo by zero.");
			res.type = VALUE_NAN;
		} else {
			res = value_init(VALUE_MPZ);
			mpz_tdiv_r(res.core.u_mz, op1.core.u_mz, op2.core.u_mz);
		}
	} else {
		if (op1.type != VALUE_MPZ)
			value_error(1, "Type Error: Modulo is undefined where op1 is %ts (integer expected).", op1);
		if (op2.type != VALUE_MPZ)
			value_error(1, "Type Error: Modulo is undefined where op2 is %ts (integer expected).", op2);
	}
	
	value_clear(&zero);
	return res;
}

value value_mod_now(value *op1, value op2)
{
	value res = value_mod(*op1, op2);
	if (res.type == VALUE_ERROR)
		return res;
	value_clear(op1);
	*op1 = res;
	return value_init_nil();
}

value value_add_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "addition") ? value_init_error() : value_add(argv[0], argv[1]);
}

value value_sub_arg(int argc, value argv[])
{
	if (argv[0].type == VALUE_MISSING_ARG)
		argv[0] = value_set_long(0);
	else if (argv[1].type == VALUE_MISSING_ARG) {
		argv[1] = argv[0];
		argv[0] = value_set_long(0);
	}
	if (missing_arguments(argc, argv, "subtraction"))
		return value_init_error();
	return value_sub(argv[0], argv[1]);
}

value value_mul_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "multiplication") ? value_init_error() : value_mul(argv[0], argv[1]);
}

value value_div_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "division") ? value_init_error() : value_div(argv[0], argv[1]);
}

value value_mod_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "modulo") ? value_init_error() : value_mod(argv[0], argv[1]);
}

value value_inc(value op)
{
	value res;
	if (op.type == VALUE_MPZ) {
		res = value_init(VALUE_MPZ);
		mpz_add_ui(res.core.u_mz, op.core.u_mz, 1);
	} else if (op.type == VALUE_MPF) {
		res = value_init(VALUE_MPF);
		mpfr_add_ui(res.core.u_mf, op.core.u_mf, 1, value_mpfr_round);
	} else {
		value_error(1, "Type Error: Increment is undefined where op is %ts (number expected).", op);
		res = value_init_error();
	}
	return res;
}

value value_inc_now(value *op)
{
	if (op->type == VALUE_MPZ)
		mpz_add_ui(op->core.u_mz, op->core.u_mz, 1);
	else if (op->type == VALUE_MPF)
		mpfr_add_ui(op->core.u_mf, op->core.u_mf, 1, value_mpfr_round);
	else {
		value_error(1, "Type Error: Increment is undefined where op is %ts (number expected).", *op);
		return value_init_error();
	}
	
	return value_init_nil();
}

value value_dec(value op)
{
	value res;
	if (op.type == VALUE_MPZ) {
		res = value_init(VALUE_MPZ);
		mpz_sub_ui(res.core.u_mz, op.core.u_mz, 1);
	} else if (op.type == VALUE_MPF) {
		res = value_init(VALUE_MPF);
		mpfr_sub_ui(res.core.u_mf, op.core.u_mf, 1, value_mpfr_round);
	} else {
		value_error(1, "Type Error: Decrement is undefined where op is %ts (number expected).", op);
		res = value_init_error();
	}
	return res;	
}

value value_dec_now(value *op)
{
	if (op->type == VALUE_MPZ)
		mpz_sub_ui(op->core.u_mz, op->core.u_mz, 1);
	else if (op->type == VALUE_MPF)
		mpfr_sub_ui(op->core.u_mf, op->core.u_mf, 1, value_mpfr_round);
	else {
		value_error(1, "Type Error: Decrement is undefined where op is %ts (number expected).", *op);
		return value_init_error();
	}
	
	return value_init_nil();
}

value value_inc_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "increment") ? value_init_error() : value_inc(argv[0]);
}

value value_dec_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "decrement") ? value_init_error() : value_dec(argv[0]);
}

value value_uminus(value op)
{
	if (op.type == VALUE_MPZ) {
		value res = value_init(VALUE_MPZ);
		mpz_neg(res.core.u_mz, op.core.u_mz);
		return res;
	} else if (op.type == VALUE_MPF) {
		value res = value_init(VALUE_MPF);
		mpfr_neg(res.core.u_mf, op.core.u_mf, value_mpfr_round);
		return res;
	} else {
		value_error(1, "Type Error: Unary minus is undefined where op is %ts (number expected).", op);
		return value_init_error();
	}

}

value value_uplus(value op)
{
	if (op.type == VALUE_MPZ || op.type == VALUE_MPF) {
		value res = value_set(op);
		return res;
	} else {
		value_error(1, "Type Error: Unary plus is undefined where op is %ts (number expected).", op);
		return value_init_error();
	}
}

value value_abs(value op)
{
	if (op.type == VALUE_MPZ) {
		value res = value_init(VALUE_MPZ);
		mpz_abs(res.core.u_mz, op.core.u_mz);
		return res;
	} else if (op.type == VALUE_MPF) {
		value res = value_init(VALUE_MPF);
		mpfr_abs(res.core.u_mf, op.core.u_mf, value_mpfr_round);
		return res;
	} else {
		value_error(1, "Type Error: abs is undefined where op is %ts (number expected).", op);
		return value_init_error();
	}
}

value value_uminus_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "unary minus") ? value_init_error() : value_uminus(argv[0]);
}

value value_uplus_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "unary plus") ? value_init_error() : value_uplus(argv[0]);
}

value value_abs_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "abs()") ? value_init_error() : value_abs(argv[0]);
}

int compare_to_zero(int x)
{
	if (x < 0) return -1;
	if (x == 0) return 0;
	return 1;
}

/* 
 * Return Codes
 * 
 * -2: error
 * -1: op1 < op2
 *  0: op1 == op2
 *  1: op1 > op2
 * 
 * Other comparison functions may return values that are greater or less than 1 or 
 * -1. value_cmp() is guaranteed to return -1, 0, or 1. In order to convert values 
 * to -1, 0, or 1, the expression (v > 0) - (v < 0) is used. From 
 * http://graphics.stanford.edu/~seander/bithacks.html#CopyIntegerSign
 */
int value_cmp(value op1, value op2)
{
	int v;
	if (op1.type == VALUE_MPZ) {
		if (op2.type == VALUE_MPZ) {
			return ((v = mpz_cmp(op1.core.u_mz, op2.core.u_mz)) > 0) - (v < 0);
			
		} else if (op2.type == VALUE_MPF) {
			return ((v = mpfr_cmp_z(op2.core.u_mf, op1.core.u_mz)) < 0) - (v > 0);
		}
	}
	
	if (op1.type == VALUE_MPF) {
		if (op2.type == VALUE_MPZ) {
			return ((v = mpfr_cmp_z(op1.core.u_mf, op2.core.u_mz)) > 0) - (v < 0);
		} else if (op2.type == VALUE_MPF) {
			return ((mpfr_cmp(op1.core.u_mf, op2.core.u_mf)) > 0) - (v < 0);
		}
	}
	
	if (op1.type != op2.type)
		return -2;
	
	size_t i, length;
	
	switch (op1.type) {
	case VALUE_NIL:
	case VALUE_INF:
	case VALUE_NAN:
		return 0;
		
	case VALUE_BOO:
		// Since 0 is false and 1 is true, this will return -1, 0, or 1.
		return op2.core.u_b - op1.core.u_b;

	case VALUE_STR:
	case VALUE_ID:
	case VALUE_VAR:
	case VALUE_RGX:
	case VALUE_SYM:
		return ((v = strcmp(op1.core.u_s, op2.core.u_s)) > 0) - (v < 0);
	
	case VALUE_ARY:
		length = op1.core.u_a.length < op2.core.u_a.length ? op1.core.u_a.length : op2.core.u_a.length;
		int cmp;
		for (i = 0; i < length; ++i)
			if (cmp = value_cmp_any(op1.core.u_a.a[i], op2.core.u_a.a[i]))
				return cmp;
		
		if (op1.core.u_a.length < op2.core.u_a.length)
			return -1;
		if (op1.core.u_a.length == op2.core.u_a.length)
			return 0;
		return 1;
	
	case VALUE_LST:
		while (op1.type != VALUE_NIL) {
			if (op2.type == VALUE_NIL)
				return 1;
			if ((v = value_cmp_any(op1, op2)) != 0)
				return v;
			op1 = op1.core.u_l[1];
			op2 = op2.core.u_l[1];
		}
		
		if (op2.type == VALUE_NIL)
			return 0;
		return -1;
		
	case VALUE_PTR:
		while (op1.type == VALUE_PAR) {
			if (op2.type != VALUE_PAR)
				return 1;
			if ((v = value_cmp_any(op1.core.u_p->head, op2.core.u_p->head)) != 0)
				return v;
			op1 = op1.core.u_p->tail;
			op2 = op2.core.u_p->tail;
		}
		
		if (op2.type != VALUE_PAR)
			return value_cmp_any(op1, op2);
		return -1;
		
		
		
	default:
		value_error(1, "Type Error: Comparison is undefined for %ts and %ts.", op1, op2);
		return -2;
	}
	
	return -2;
}

int value_cmp_any(value op1, value op2)
{
	int v;
	if (op1.type == VALUE_MPZ) {
		if (op2.type == VALUE_MPZ) {
			return ((v = mpz_cmp(op1.core.u_mz, op2.core.u_mz)) > 0) - (v < 0);
			
		} else if (op2.type == VALUE_MPF) {
			return ((v = mpfr_cmp_z(op2.core.u_mf, op1.core.u_mz)) < 0) - (v > 0);
		}
	}
	
	if (op1.type == VALUE_MPF) {
		if (op2.type == VALUE_MPZ) {
			return ((v = mpfr_cmp_z(op1.core.u_mf, op2.core.u_mz)) > 0) - (v < 0);
		} else if (op2.type == VALUE_MPF) {
			return ((mpfr_cmp(op1.core.u_mf, op2.core.u_mf)) > 0) - (v < 0);
		}
	}
	
	if (op1.type != op2.type)
		return op1.type < op2.type ? -1 : op1.type == op2.type ? 0 : 1;
		
	return value_cmp(op1, op2);
}

value value_cmp_std(value op1, value op2)
{
	int res = value_cmp(op1, op2);
	if (res == -2)
		return value_init_error();
	return value_set_long(res);	
}

int value_lt(value op1, value op2)
{
	int res = value_cmp(op1, op2);
	if (res == -2)
		return FALSE;
	return res < 0;
}

value value_lt_std(value op1, value op2)
{
	int res = value_cmp(op1, op2);
	if (res == -2)
		return value_init_error();
	return value_set_bool(res < 0);
}

int value_le(value op1, value op2)
{
	int res = value_cmp(op1, op2);
	if (res == -2)
		return FALSE;
	return res <= 0;
}

value value_le_std(value op1, value op2)
{
	int res = value_cmp(op1, op2);
	if (res == -2)
		return value_init_error();
	return value_set_bool(res <= 0);
}

int value_eq(value op1, value op2)
{
	// If the types are not equal, op1 and op2 cannot be equal unless they are MPZ or MPF.
	if (op1.type != op2.type && !(op1.type == VALUE_MPZ && op2.type == VALUE_MPF || op1.type == VALUE_MPF && op2.type == VALUE_MPZ))
		return FALSE;
	
	size_t i, length1, length2;

	switch (op1.type) {
	case VALUE_NIL:
	case VALUE_NAN:
	case VALUE_INF: 
	case VALUE_ERROR:
		return TRUE;
	case VALUE_MPZ:
		if (op2.type == VALUE_MPZ)
			return mpz_cmp(op1.core.u_mz, op2.core.u_mz) == 0;
		if (op2.type == VALUE_MPF) {
			mpfr_t opf;
			mpfr_init_set_z(opf, op1.core.u_mz, value_mpfr_round);
			int res = mpfr_equal_p(opf, op2.core.u_mf);
			mpfr_clear(opf);
			return res;
		}
	case VALUE_MPF:
		if (op2.type == VALUE_MPZ) {
			mpfr_t opf;
			mpfr_init_set_z(opf, op2.core.u_mz, value_mpfr_round);
			int res = mpfr_equal_p(op1.core.u_mf, opf);
			mpfr_clear(opf);
			return res;
		}
		if (op2.type == VALUE_MPF)
			return mpfr_equal_p(op1.core.u_mf, op2.core.u_mf);
	case VALUE_BOO:
		return (op1.core.u_b && op2.core.u_b) || (!op1.core.u_b && !op2.core.u_b);
	case VALUE_STR:
	case VALUE_RGX:
	case VALUE_SYM:
	case VALUE_ID:
	case VALUE_VAR:
		return strcmp(op1.core.u_s, op2.core.u_s) == 0;
	case VALUE_ARY:
		if (op1.core.u_a.length != op2.core.u_a.length)
			return FALSE;
		
		for (i = 0; i < op1.core.u_a.length; ++i)
			if (value_ne(op1.core.u_a.a[i], op2.core.u_a.a[i]))
				return FALSE;
		return TRUE;
	
	case VALUE_LST:
		while (op1.type != VALUE_NIL) {
			if (op2.type == VALUE_NIL)
				return FALSE;
			if (value_ne(op1.core.u_l[0], op2.core.u_l[0]))
				return FALSE;
			op1 = op1.core.u_l[1];
			op2 = op2.core.u_l[1];
		}
		return TRUE;

	case VALUE_PAR:
		while (op1.type == VALUE_PAR) {
			if (op2.type != VALUE_PAR)
				return FALSE;
			if (value_ne(op1.core.u_p->head, op2.core.u_p->head))
				return FALSE;
			op1 = op1.core.u_p->tail;
			op2 = op2.core.u_p->tail;
		}
		return value_eq(op1, op2);

	case VALUE_HSH:
		length1 = value_hash_length(op1);
		length2 = value_hash_length(op2);
		if (length1 != length2)
			return FALSE;
		for (i = 0; i < length1; ++i)
			if (value_ne(op1.core.u_h.a[i], op2.core.u_h.a[i]))
				return FALSE;
		return TRUE;
	
	case VALUE_BLK:
		if (op1.core.u_blk.length != op2.core.u_blk.length)
			return FALSE;
		
		for (i = 0; i < op1.core.u_blk.length; ++i)
			if (value_ne(op1.core.u_blk.a[i], op2.core.u_blk.a[i]))
				return FALSE;
		return TRUE;
		
	case VALUE_BIF:
		return op1.core.u_bif->f == op2.core.u_bif->f;
	
	case VALUE_TYP:
		return op1.core.u_type == op2.core.u_type;

	}

	return FALSE;
}

int value_eq_with_if_statements(value op1, value op2)
{
	// If the types are not equal, op1 and op2 cannot be equal unless they are MPZ or MPF.
	if (op1.type != op2.type && !(op1.type == VALUE_MPZ && op2.type == VALUE_MPF || op1.type == VALUE_MPF && op2.type == VALUE_MPZ))
		return FALSE;
	
	if (op1.type == VALUE_NIL)
		return TRUE;
	if (op1.type == VALUE_NAN)
		return TRUE;
	if (op1.type == VALUE_INF)
		return TRUE;
	if (op1.type == VALUE_ERROR)
		return TRUE;
	if (op1.type == VALUE_MPZ && op2.type == VALUE_MPZ)
		return mpz_cmp(op1.core.u_mz, op2.core.u_mz) == 0;
	if (op1.type == VALUE_MPZ && op2.type == VALUE_MPF) {
		mpfr_t opf;
		mpfr_init_set_z(opf, op1.core.u_mz, value_mpfr_round);
		int res = mpfr_cmp(opf, op2.core.u_mf) == 0;
		mpfr_clear(opf);
		return res;
	}
	if (op1.type == VALUE_MPF && op2.type == VALUE_MPZ) {
		mpfr_t opf;
		mpfr_init_set_z(opf, op2.core.u_mz, value_mpfr_round);
		int res = mpfr_cmp(op1.core.u_mf, opf) == 0;
		mpfr_clear(opf);
		return res;
	}
	if (op1.type == VALUE_MPF && op2.type == VALUE_MPF)
		return mpfr_cmp(op1.core.u_mf, op2.core.u_mf) == 0;
	if (op1.type == VALUE_BOO)
		return (op1.core.u_b && op2.core.u_b) || (!op1.core.u_b && !op2.core.u_b);
	if (op1.type == VALUE_STR || op1.type == VALUE_RGX || op1.type == VALUE_SYM)
		return strcmp(op1.core.u_s, op2.core.u_s) == 0;
	if (op1.type == VALUE_ARY) {
		if (op1.core.u_a.length != op2.core.u_a.length)
			return FALSE;
		
		size_t i;
		for (i = 0; i < op1.core.u_a.length; ++i)
			if (value_ne(op1.core.u_a.a[i], op2.core.u_a.a[i]))
				return FALSE;
		return TRUE;
	}
	
	if (op1.type == VALUE_LST) {
		while (op1.type != VALUE_NIL) {
			if (op2.type == VALUE_NIL)
				return FALSE;
			if (value_ne(op1.core.u_l[0], op2.core.u_l[0]))
				return FALSE;
			op1 = op1.core.u_l[1];
			op2 = op2.core.u_l[1];
		}
		return TRUE;
	}

	if (op1.type == VALUE_HSH) {
		size_t i, length1 = value_hash_length(op1), length2 = value_hash_length(op2);
		if (length1 != length2)
			return FALSE;
		for (i = 0; i < length1; ++i)
			if (value_ne(op1.core.u_h.a[i], op2.core.u_h.a[i]))
				return FALSE;
		return TRUE;
	}
	
	if (op1.type == VALUE_BLK) {
		if (op1.core.u_blk.length != op2.core.u_blk.length)
			return FALSE;
		
		size_t i;
		for (i = 0; i < op1.core.u_blk.length; ++i)
			if (value_ne(op1.core.u_blk.a[i], op2.core.u_blk.a[i]))
				return FALSE;
		return TRUE;
	}
		
	if (op1.type == VALUE_ID)
		return strcmp(op1.core.u_id, op2.core.u_id) == 0;
	if (op1.type == VALUE_VAR)
		return strcmp(op1.core.u_var, op2.core.u_var) == 0;
	
	if (op1.type == VALUE_BIF)
		return op1.core.u_bif->f == op2.core.u_bif->f;
	
	if (op1.type == VALUE_TYP)
		return op1.core.u_type == op2.core.u_type;

	return FALSE;
}

value value_eq_std(value op1, value op2)
{
	return value_set_bool(value_eq(op1, op2));
}

int value_ne(value op1, value op2)
{
	return !value_eq(op1, op2);
}

value value_ne_std(value op1, value op2)
{
	return value_set_bool(value_ne(op1, op2));
}

int value_ge(value op1, value op2)
{
	int res = value_cmp(op1, op2);
	if (res == -2)
		return FALSE;
	return res >= 0;
}

value value_ge_std(value op1, value op2)
{
	int res = value_cmp(op1, op2);
	if (res == -2)
		return value_init_error();
	return value_set_bool(res >= 0);
}


int value_gt(value op1, value op2)
{
	int res = value_cmp(op1, op2);
	if (res == -2)
		return FALSE;
	return res > 0;
}

value value_gt_std(value op1, value op2)
{
	int res = value_cmp(op1, op2);
	if (res == -2)
		return value_init_error();
	return value_set_bool(res > 0);
}

/* 
 * Not yet implemented. This is currently useless because nothing is pass by 
 * reference.
 */
int value_equal_p(value op1, value op2)
{
	return VALUE_ERROR;
}

value value_equal_p_std(value op1, value op2)
{
	int res = value_equal_p(op1, op2);
	if (res == VALUE_ERROR)
		return value_init_error();
	return value_set_bool(res);
	
}

value value_cmp_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "comparison") ? value_init_error() : value_cmp_std(argv[0], argv[1]);
}

value value_lt_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "less than comparison") ? value_init_error() : value_lt_std(argv[0], argv[1]);
}

value value_le_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "less than or equal to comparison") ? value_init_error() : value_le_std(argv[0], argv[1]);
}

value value_eq_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "equals comparison") ? value_init_error() : value_eq_std(argv[0], argv[1]);
}

value value_ne_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "not equal comparison") ? value_init_error() : value_ne_std(argv[0], argv[1]);
}

value value_ge_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "greater than or equal to comparison") ? value_init_error() : value_ge_std(argv[0], argv[1]);
}

value value_gt_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "greater than comparison") ? value_init_error() : value_gt_std(argv[0], argv[1]);
}


int value_not_p(value op)
{
	return !value_true_p(op);
}

value value_not_p_std(value op)
{
	return value_set_bool(value_not_p(op));
}

int value_and_p(value op1, value op2)
{
	return value_true_p(op1) && value_true_p(op2);
}

value value_and_p_std(value op1, value op2)
{
	if (value_true_p(op1))
		return value_set(op2);
	return value_set(op1);
}

int value_or_p(value op1, value op2)
{
	return value_true_p(op1) || value_true_p(op2);
}

value value_or_p_std(value op1, value op2)
{
	if (value_true_p(op1))
		return value_set(op1);
	return value_set(op2);
}

value value_not_p_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "logical NOT") ? value_init_error() : value_not_p_std(argv[0]);
}

value value_and_p_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "logical AND") ? value_init_error() : value_and_p_std(argv[0], argv[1]);
}

value value_or_p_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "logical OR") ? value_init_error() : value_or_p_std(argv[0], argv[1]);
}


value value_2exp(value op1, long op2)
{
	if (op2 < 0)
		return value_shr(op1, (unsigned long) (-op2));
	else if (op2 == 0)
		return op1;
	return value_shl(op1, (unsigned long) op2);
}

value value_shl(value op1, unsigned long op2)
{
	value res = value_set(op1);
	if (res.type == VALUE_MPZ)
		mpz_mul_2exp(res.core.u_mz, op1.core.u_mz, op2);
	else if (res.type == VALUE_MPF)
		mpfr_mul_2exp(res.core.u_mf, op1.core.u_mf, op2, value_mpfr_round);
	else
		value_error(1, "Type Error: Bit shift left is undefined where op1 is %ts (number expected).", op1);
	return res;
}

value value_shr(value op1, unsigned long op2)
{
	value res = value_set(op1);
	if (res.type == VALUE_MPZ)
		mpz_div_2exp(res.core.u_mz, op1.core.u_mz, op2);
	else if (res.type == VALUE_MPF)
		mpfr_div_2exp(res.core.u_mf, op1.core.u_mf, op2, value_mpfr_round);
	else
		value_error(1, "Type Error: Bit shift right is undefined where op1 is %ts (number expected).", op1);
	return res;
}

value value_shl_std(value op1, value op2)
{
	if (value_lt(op2, value_int_max) && value_ge(op2, value_zero))
		return value_shl(op1, value_get_long(op2));
	else {
		value_error(1, "Type Error: left shift is undefined where op2 is greater than LONG_MAX.");
		return value_init_error();
	}
}

value value_shr_std(value op1, value op2)
{
	if (value_lt(op2, value_int_max) && value_ge(op2, value_zero))
		return value_shr(op1, value_get_long(op2));
	else {
		value_error(1, "Type Error: right shift is undefined where op2 is greater than LONG_MAX.");
		return value_init_error();
	}	
}

value value_and(value op1, value op2)
{
	value res;
	if (op1.type == VALUE_BOO && op2.type == VALUE_BOO) {
		res = value_set_bool(op1.core.u_b && op2.core.u_b);
	} else if (op1.type == VALUE_MPZ && op2.type == VALUE_MPZ) {
		res = value_init(VALUE_MPZ);
		mpz_and(res.core.u_mz, op1.core.u_mz, op2.core.u_mz);
	} else if (op1.type == VALUE_ARY && op2.type == VALUE_ARY) {
		op1 = value_uniq(op1);
		res = value_init(VALUE_ARY);
		size_t i, length = value_length(op1);
		for (i = 0; i < length; ++i)
			if (value_contains_p(op2, op1.core.u_a.a[i]))
				if (value_append_now(&res, op1.core.u_a.a[i]).type == VALUE_ERROR)
					return value_init_error();
	} else {
		value_error(1, "Type Error: Bitwise AND is undefined for %ts and %ts.", op1, op2);
		res = value_init_error();
	}
	
	return res;
}

value value_or(value op1, value op2)
{
	value res;
	if (op1.type == VALUE_BOO && op2.type == VALUE_BOO) {
		res = value_set_bool(op1.core.u_b || op2.core.u_b);
	} else if (op1.type == VALUE_MPZ && op2.type == VALUE_MPZ) {
		res = value_init(VALUE_MPZ);
		mpz_ior(res.core.u_mz, op1.core.u_mz, op2.core.u_mz);
	} else if (op1.type == VALUE_ARY && op2.type == VALUE_ARY) {
		res = value_concat(op1, op2);
		if (value_uniq_now(&res).type == VALUE_ERROR)
			return value_init_error();
	} else {
		value_error(1, "Type Error: Bitwise OR is undefined for %ts and %ts.", op1, op2);
		res = value_init_error();
	}
	
	return res;
}

value value_xor(value op1, value op2)
{
	value res;
	if (op1.type == VALUE_BOO && op2.type == VALUE_BOO) {
		res = value_set_bool(op1.core.u_b & op2.core.u_b);
	} else if (op1.type == VALUE_MPZ && op2.type == VALUE_MPZ) {
		res = value_init(VALUE_MPZ);
		mpz_xor(res.core.u_mz, op1.core.u_mz, op2.core.u_mz);
	} else if (op1.type == VALUE_ARY && op2.type == VALUE_ARY) {
		res = value_init(VALUE_ARY);
		value hash = value_cast(op2, VALUE_HSH);
		size_t i, length = value_length(op1);
		for (i = 0; i < length; ++i)
			if (!value_hash_exists(hash, op1.core.u_a.a[i])) {
				if (value_append_now(&res, op1.core.u_a.a[i]).type == VALUE_ERROR)
					return value_init_error();
			}
		
		value_clear(&hash);
		hash = value_cast(op1, VALUE_HSH);
		length = value_length(op2);
		for (i = 0; i < length; ++i)
			if (!value_hash_exists(hash, op2.core.u_a.a[i])) {
				if (value_append_now(&res, op2.core.u_a.a[i]).type == VALUE_ERROR)
					return value_init_error();
			}
		
		value_clear(&hash);
		return res;
		
	} else {
		value_error(1, "Type Error: Bitwise XOR is undefined for %ts and %ts.", op1, op2);
		res = value_init_error();
	}
	
	return res;
}

value value_not(value op)
{
	value res = value_init_error();
	if (op.type == VALUE_MPZ) {
		res = value_init(VALUE_MPZ);
		mpz_com(res.core.u_mz, op.core.u_mz);
	} else
		value_error(1, "Type Error: Bitwise NOT is undefined where op1 is %ts (integer expected).", op);
	
	return res;
}

value value_2exp_arg(int argc, value argv[])
{
	if (missing_arguments(argc, argv, "2exp()"))
		return value_init_error();
	else if (value_lt(argv[1], value_int_max) && value_ge(argv[1], value_zero))
		return value_2exp(argv[0], value_get_long(argv[1]));
	else {
		value_error(1, "Type Error: 2exp() is undefined where op2 is greater than ULONG_MAX.");
		return value_init_error();
	}
}

value value_shl_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "left shift") ? value_init_error() : value_shl_std(argv[0], argv[1]);
}

value value_shr_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "right shift") ? value_init_error() : value_shr_std(argv[0], argv[1]);
}

value value_and_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "bitwise AND") ? value_init_error() : value_and(argv[0], argv[1]);
}

value value_or_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "bitwise OR") ? value_init_error() : value_or(argv[0], argv[1]);
}

value value_xor_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "bitwise XOR") ? value_init_error() : value_xor(argv[0], argv[1]);
}

value value_not_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "bitwise NOT") ? value_init_error() : value_not(argv[0]);
}


int value_probab_prime_p(value op)
{
	if (op.type == VALUE_MPZ)
		return mpz_probab_prime_p(op.core.u_mz, 10);
	else {
		value_error(1, "Type Error: probab_prime() is undefined where op is %ts (integer expected).", op);
		return FALSE;
	}
}

value value_probab_prime_p_std(value op)
{
	if (op.type == VALUE_MPZ)
		return value_set_bool(mpz_probab_prime_p(op.core.u_mz, 10));
	else {
		value_error(1, "Type Error: probab_prime() is undefined where op is %ts (integer expected).", op);
		return value_init_error();
	}
}

value value_nextprime(value op)
{
	if (op.type == VALUE_MPZ) {
		value res = value_init(VALUE_MPZ);
		mpz_nextprime(res.core.u_mz, op.core.u_mz);
		return res;
	} else {
		value_error(1, "Type Error: nextprime() is undefined where op is %ts (integer expected).", op);
		return value_init_error();
	}

}

value value_gcd(value op1, value op2)
{
	if (op1.type == VALUE_MPZ && op2.type == VALUE_MPZ) {
		value res = value_init(VALUE_MPZ);
		mpz_gcd(res.core.u_mz, op1.core.u_mz, op2.core.u_mz);
		return res;
	} else {
		if (op1.type != VALUE_MPZ)
			value_error(1, "Type Error: nextprime() is undefined where op1 is %ts (integer expected).", op1);
		if (op2.type != VALUE_MPZ)
			value_error(1, "Type Error: nextprime() is undefined where op2 is %ts (integer expected).", op2);
		return value_init_error();
	}

}

value value_probab_prime_p_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "probab_prime?()") ? value_init_error() : value_probab_prime_p_std(argv[0]);
}

value value_nextprime_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "nextprime()") ? value_init_error() : value_nextprime(argv[0]);
}

value value_gcd_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "gcd()") ? value_init_error() : value_gcd(argv[0], argv[1]);
}

value value_seconds()
{
	return value_set_ulong((unsigned long) time(NULL));
}

value value_seconds_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "seconds()") ? value_init_error() : value_seconds();
}

value value_pow(value op1, value op2)
{
	int error_p = FALSE;
	
	if (op1.type != VALUE_MPZ && op1.type != VALUE_MPF) {
		value_error(1, "Type Error: Exponentiation is undefined where op1 is %ts (number expected).", op1);
		error_p = TRUE;
	}
	
	if (op2.type != VALUE_MPZ && op2.type != VALUE_MPF) {
		value_error(1, "Type Error: Exponentiation is undefined where op2 is %ts (number expected).", op2);
		error_p = TRUE;
	}
	
	if (error_p)
		return value_init_error();
	
	value res, x, y;
	
	res = value_init(VALUE_MPF);
	if (op1.type == VALUE_MPF)
		x = op1;
	else x = value_cast(op1, VALUE_MPF);
	
	if (op2.type == VALUE_MPF)
		y = op2;
	else y = value_cast(op2, VALUE_MPF);
	
	mpfr_pow(res.core.u_mf, x.core.u_mf, y.core.u_mf, value_mpfr_round);
	
	if (op1.type != VALUE_MPF)
		value_clear(&x);
	if (op2.type != VALUE_MPF)
		value_clear(&y);
	
	// If both numbers are integers and the exponent is non-negative, convert the result from 
	// a float to an integer.
	if (op1.type == VALUE_MPZ && op2.type == VALUE_MPZ && mpz_cmp_si(op2.core.u_mz, 0) >= 0) {
		y = res;
		res = value_cast(y, VALUE_MPZ);
		value_clear(&y);
	}
	
	return res;
}

value value_choose(value op1, value op2)
{
	value res;
	
	int error_p = FALSE;
	if (op1.type != VALUE_MPZ) {
		value_error(1, "Type Error: Binomial coefficient (n choose k) is undefined where op1 is %ts (integer expected).", op1);
		error_p = TRUE;
	}
	if (op2.type != VALUE_MPZ) {
		value_error(1, "Type Error: Binomial coefficient (n choose k) is undefined where op2 is %ts (integer expected).", op2);
		error_p = TRUE;
	}
	if (error_p)
		return value_init_error();
		
	if (value_gt(op2, op1)) {
		return value_set_long(0);
	}
	
	if (value_gt(op2, value_int_max)) {
		value_error(1, "Domain Error: Combinatoin (op1 choose op2) is undefined where op2 is greater than %ts.", value_int_max);
		return value_init_error();
	}
	unsigned long ui = mpz_get_ui(op2.core.u_mz);
	
	res.type = VALUE_MPZ;
	mpz_init(res.core.u_mz);
	mpz_bin_ui(res.core.u_mz, op1.core.u_mz, ui);
	return res;
}

value value_exp(value op)
{
	if (op.type != VALUE_MPZ && op.type != VALUE_MPF) {
		value_error(1, "Argument Error: Logarithms are undefined when op is %ts (number expected).", op);
		return value_init_error();
	}
	
	value x;
	if (op.type == VALUE_MPF)
		x = op;
	else x = value_cast(op, VALUE_MPF);
	
	value res = value_init(VALUE_MPF);
	mpfr_exp(res.core.u_mf, x.core.u_mf, value_mpfr_round);
	if (op.type != VALUE_MPF)
		value_clear(&x);
	return res;
}

value value_log(value op)
{
	if (op.type != VALUE_MPZ && op.type != VALUE_MPF) {
		value_error(1, "Argument Error: Logarithms are undefined when op is %ts (number expected).", op);
		return value_init_error();
	}
	
	if (value_le(op, value_zero))
		return value_init(VALUE_NAN);
	
	value x;
	if (op.type == VALUE_MPF)
		x = op;
	else x = value_cast(op, VALUE_MPF);
	
	value res = value_init(VALUE_MPF);
	mpfr_log(res.core.u_mf, x.core.u_mf, value_mpfr_round);
	if (op.type != VALUE_MPF)
		value_clear(&x);
	return res;
}

value value_log2(value op)
{
	if (op.type != VALUE_MPZ && op.type != VALUE_MPF) {
		value_error(1, "Argument Error: Logarithms are undefined when op is %ts (number expected).", op);
		return value_init_error();
	}
	
	if (value_le(op, value_zero))
		return value_init(VALUE_NAN);
	
	value x;
	if (op.type == VALUE_MPF)
		x = op;
	else x = value_cast(op, VALUE_MPF);
	
	value res = value_init(VALUE_MPF);
	mpfr_log2(res.core.u_mf, x.core.u_mf, value_mpfr_round);
	if (op.type != VALUE_MPF)
		value_clear(&x);
	return res;
}

value value_log10(value op)
{
	if (op.type != VALUE_MPZ && op.type != VALUE_MPF) {
		value_error(1, "Argument Error: Logarithms are undefined when op is %ts (number expected).", op);
		return value_init_error();
	}
	
	if (value_le(op, value_zero))
		return value_init(VALUE_NAN);
	
	value x;
	if (op.type == VALUE_MPF)
		x = op;
	else x = value_cast(op, VALUE_MPF);
	
	value res = value_init(VALUE_MPF);
	mpfr_log10(res.core.u_mf, x.core.u_mf, value_mpfr_round);
	if (op.type != VALUE_MPF)
		value_clear(&x);
	return res;
}

value value_sqrt(value op)
{	
	if (op.type != VALUE_MPZ && op.type != VALUE_MPF) {
		value_error(1, "Argument Error: Square root is undefined when op is %ts (number expected).", op);
		return value_init_error();
	}
	
	if (value_lt(op, value_zero))
		return value_init(VALUE_NAN);
	
	value x;
	if (op.type == VALUE_MPF)
		x = op;
	else x = value_cast(op, VALUE_MPF);
	
	value res = value_init(VALUE_MPF);
	mpfr_sqrt(res.core.u_mf, x.core.u_mf, value_mpfr_round);
	if (x.type != VALUE_MPF)
		value_clear(&x);
	
	return res;
}

value value_factorial(value op)
{
	value res;
	
	if (op.type != VALUE_MPZ) {
		value_error(1, "Type Error: Factorial is undefined where op is %ts (integer expected).", op);
		return value_init_error();
	}
	
	if (mpz_sgn(op.core.u_mz) == -1) {
		value_error(1, "Type Error: Factorial is undefined where op is %ts (non-negative integer expected).", op);
		return value_init_error();
	}
	
	unsigned long ulop = value_get_ulong(op);
	if (mpz_cmp_ui(op.core.u_mz, ulop)) {
		value_error(1, "Type Error: Factorial is undefined where op is %ts (must be less than ULONG_MAX).", op);
		return value_init_error();
	}
	
	res = value_init(VALUE_MPZ);
	mpz_fac_ui(res.core.u_mz, ulop);	
	
	return res;
}

value value_pow_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "exponentiation") ? value_init_error() : value_pow(argv[0], argv[1]);
}

value value_choose_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "combination (op1 choose op2)") ? value_init_error() : value_choose(argv[0], argv[1]);
}

value value_exp_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "natural exponentiation") ? value_init_error() : value_exp(argv[0]);
}

value value_log_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "log") ? value_init_error() : value_log(argv[0]);
}

value value_log10_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "log10") ? value_init_error() : value_log10(argv[0]);
}

value value_log2_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "log2") ? value_init_error() : value_log2(argv[0]);
}

value value_sqrt_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "sqrt") ? value_init_error() : value_sqrt(argv[0]);
}

value value_factorial_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "factorial") ? value_init_error() : value_factorial(argv[0]);
}

value value_trig(value op, int func)
{
	if (op.type != VALUE_MPZ && op.type != VALUE_MPF) {
		value_error(1, "Argument Error: Trigonometric functions are undefined when op is %ts (number expected.", op);
		return value_init_error();
	}
	
	value res;
	res.type = VALUE_MPF;

	if (op.type == VALUE_MPZ)
		mpfr_init_set_z(res.core.u_mf, op.core.u_mz, value_mpfr_round);
	else mpfr_init_set(res.core.u_mf, op.core.u_mf, value_mpfr_round);
	
	switch (func) {
		case VALUE_SIN:
			mpfr_sin(res.core.u_mf, res.core.u_mf, value_mpfr_round);
			break;
		case VALUE_COS:
			mpfr_cos(res.core.u_mf, res.core.u_mf, value_mpfr_round);
			break;
		case VALUE_TAN:
			mpfr_tan(res.core.u_mf, res.core.u_mf, value_mpfr_round);
			break;
		case VALUE_CSC:
			mpfr_csc(res.core.u_mf, res.core.u_mf, value_mpfr_round);
			break;
		case VALUE_SEC:
			mpfr_sec(res.core.u_mf, res.core.u_mf, value_mpfr_round);
			break;
		case VALUE_COT:
			mpfr_cot(res.core.u_mf, res.core.u_mf, value_mpfr_round);
			break;
		case VALUE_ASIN:
			if (mpfr_cmp_si(res.core.u_mf, -1) < 0 || mpfr_cmp_si(res.core.u_mf, 1) > 0) {
				value_error(1, "Argument Error: In asin(), argument is out of the function domain.");
				return value_init_error();
			}
			mpfr_asin(res.core.u_mf, res.core.u_mf, value_mpfr_round);
			break;
		case VALUE_ACOS:
			if (mpfr_cmp_si(res.core.u_mf, -1) < 0 || mpfr_cmp_si(res.core.u_mf, 1) > 0) {
				value_error(1, "Argument Error: In cos(), argument is out of the function domain.");
				return value_init_error();
			}
			mpfr_acos(res.core.u_mf, res.core.u_mf, value_mpfr_round);
			break;
		case VALUE_ATAN:
			mpfr_atan(res.core.u_mf, res.core.u_mf, value_mpfr_round);
			break;
		case VALUE_SINH:
			mpfr_sinh(res.core.u_mf, res.core.u_mf, value_mpfr_round);
			break;
		case VALUE_COSH:
			mpfr_cosh(res.core.u_mf, res.core.u_mf, value_mpfr_round);
			break;
		case VALUE_TANH:
			mpfr_tanh(res.core.u_mf, res.core.u_mf, value_mpfr_round);
			break;
		case VALUE_CSCH:
			mpfr_csch(res.core.u_mf, res.core.u_mf, value_mpfr_round);
			break;
		case VALUE_SECH:
			mpfr_sech(res.core.u_mf, res.core.u_mf, value_mpfr_round);
			break;
		case VALUE_COTH:
			mpfr_coth(res.core.u_mf, res.core.u_mf, value_mpfr_round);
			break;
		case VALUE_ASINH:
			if (mpfr_cmp_si(res.core.u_mf, -1) < 0 || mpfr_cmp_si(res.core.u_mf, 1) > 0) {
				value_error(1, "Argument Error: In asin(), argument is out of the function domain.");
				return value_init_error();
			}
			mpfr_asinh(res.core.u_mf, res.core.u_mf, value_mpfr_round);
			break;
		case VALUE_ACOSH:
			if (mpfr_cmp_si(res.core.u_mf, -1) < 0 || mpfr_cmp_si(res.core.u_mf, 1) > 0) {
				value_error(1, "Argument Error: In cos(), argument is out of the function domain.");
				return value_init_error();
			}
			mpfr_acosh(res.core.u_mf, res.core.u_mf, value_mpfr_round);
			break;
		case VALUE_ATANH:
			mpfr_atanh(res.core.u_mf, res.core.u_mf, value_mpfr_round);
			break;
	}
		
	return res;
}

value value_sin_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "sin") ? value_init_error() : value_sin(argv[0]);
}

value value_cos_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "cos") ? value_init_error() : value_cos(argv[0]);
}

value value_tan_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "tan") ? value_init_error() : value_tan(argv[0]);
}

value value_csc_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "csc") ? value_init_error() : value_csc(argv[0]);
}

value value_sec_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "sec") ? value_init_error() : value_sec(argv[0]);
}

value value_cot_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "cot") ? value_init_error() : value_cot(argv[0]);
}

value value_asin_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "asin") ? value_init_error() : value_asin(argv[0]);
}

value value_acos_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "acos") ? value_init_error() : value_acos(argv[0]);
}

value value_atan_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "atan") ? value_init_error() : value_atan(argv[0]);
}

value value_sinh_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "sin") ? value_init_error() : value_sinh(argv[0]);
}

value value_cosh_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "cos") ? value_init_error() : value_cosh(argv[0]);
}

value value_tanh_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "tan") ? value_init_error() : value_tanh(argv[0]);
}

value value_csch_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "csc") ? value_init_error() : value_csch(argv[0]);
}

value value_sech_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "sec") ? value_init_error() : value_sech(argv[0]);
}

value value_coth_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "cot") ? value_init_error() : value_coth(argv[0]);
}

value value_asinh_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "asin") ? value_init_error() : value_asinh(argv[0]);
}

value value_acosh_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "acos") ? value_init_error() : value_acosh(argv[0]);
}

value value_atanh_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "atan") ? value_init_error() : value_atanh(argv[0]);
}

/* 
 * Returns a new function which is the derivative of (op). (op) must be in standard S-expression 
 * form.
 * 
 * It currently assumes that all variables represent the same variable.
 * 
 * In order to simplify the results, value_optimize1_now() is called. This removes addition by 
 * zero, multiplication by 1, etc.
 */
value value_deriv(value op)
{
	if (op.type == VALUE_MPZ || op.type == VALUE_MPF) {
		/* The derivative of a number is 0. */
		return value_set_long(0);
	} else if (op.type == VALUE_VAR) {
		/* The derivative of a lone variable is 1. */
		return value_set_long(1);
	} else if (op.type != VALUE_BLK) {
		value_error(1, "Type Error: deriv() is undefined for %ts (number, variable or block expected).", op);
		return value_init_error();
	}
	
	if (op.core.u_blk.length == 0) {
		return value_set(op);
	} else if (op.core.u_blk.length == 1) {
		return value_deriv(op.core.u_blk.a[0]);
	}
	
	if (op.core.u_blk.a[0].type != VALUE_BIF) {
		value_error(1, "Error: In deriv(), undefined syntax for the first element of %s.", op);
		return value_init_error();
	}
	
	value res = value_init_nil();
	if (op.core.u_blk.length == 2) {
		res = value_deriv_2(op);
	} else if (op.core.u_blk.length == 3) {
		res = value_deriv_3(op);
	}
	
	return res;
}

/* 
 * Takes the derivative of a block with two elements.
 */
value value_deriv_2(value op)
{
	value res = value_init_nil();
	value der = value_init_nil();
	value blk = value_init_nil();
	value fun = value_init_nil();
	
	value (*f)(int argc, value *argv) = op.core.u_blk.a[0].core.u_bif->f;
	
	if (f == &value_uminus_arg) {
		/* deriv (-X) = -deriv(X) */
		
		res = value_init(VALUE_BLK);
		fun = value_set_fun(&value_uminus_arg);
		der = value_deriv(op.core.u_blk.a[1]);
		value_append_now2(&res, &fun);
		value_append_now2(&res, &der);
		
	} else if (f == &value_sin_arg) {
		/* sine rule: deriv (sin(X)) = deriv(X) * cos(X) */
		
		// deriv(X)
		der = value_deriv(op.core.u_blk.a[1]);
		
		// Create a block containing cos(X).
		fun = value_set_fun(&value_cos_arg);
		blk = value_init(VALUE_BLK);
		value_append_now2(&blk, &fun);
		value_append_now(&blk, op.core.u_blk.a[1]);
		
		// Create a block containing deriv(X) * cos(X).
		res = value_init(VALUE_BLK);
		fun = value_set_fun(&value_mul_arg);
		value_append_now2(&res, &fun);
		value_append_now2(&res, &blk);
		value_append_now2(&res, &der);
		
	} else if (f == &value_cos_arg) {
		/* sine rule: deriv (cos(X)) = deriv(X) * -sin(X) */
		
		// deriv(X)
		der = value_deriv(op.core.u_blk.a[1]);
		
		// Create a block containing sin(X).
		fun = value_set_fun(&value_sin_arg);
		blk = value_init(VALUE_BLK);
		value_append_now2(&blk, &fun);
		value_append_now(&blk, op.core.u_blk.a[1]);
		
		// Create a block containing -sin(X).
		value tmp = blk;
		blk = value_init(VALUE_BLK);
		fun = value_set_fun(&value_uminus_arg);
		value_append_now2(&blk, &fun);
		value_append_now2(&blk, &tmp);
		
		// Create a block containing deriv(X) * -cos(X).
		res = value_init(VALUE_BLK);
		fun = value_set_fun(&value_mul_arg);
		value_append_now2(&res, &fun);
		value_append_now2(&res, &blk);
		value_append_now2(&res, &der);
		
	} else if (f == &value_log_arg) {
		/* logarithm rule: deriv(log(X)) = 1 / X */
		
		// deriv(X)
		der = value_deriv(op.core.u_blk.a[1]);
		
		// Create a block containing deriv(X) / X.
		res = value_init(VALUE_BLK);
		fun = value_set_fun(&value_div_arg);
		value_append_now2(&res, &fun);
		value_append_now2(&res, &der);
		value_append_now(&res, op.core.u_blk.a[1]);
		
	} else if (f == &value_exp_arg) {
		/* exponent rule: deriv(e**X) = e**X */
		
		// deriv(X)
		der = value_deriv(op.core.u_blk.a[1]);
		
		res = value_init(VALUE_BLK);
		fun = value_set_fun(&value_mul_arg);
		value_append_now2(&res, &fun);
		value_append_now(&res, op);
		value_append_now2(&res, &der);
	}
	
	value_optimize_now(&res, O_1 | O_2 | O_ASSUME_NUMERIC);
	
	return res;
}

/* 
 * Takes the derivative of a block with three elements.
 */
value value_deriv_3(value op)
{
	value res = value_init_nil();
	value der = value_init_nil();
	value blk = value_init_nil();
	value fun = value_init_nil();
	
	value (*f)(int argc, value *argv) = op.core.u_blk.a[0].core.u_bif->f;
	if (f == &value_add_arg || f == &value_sub_arg) {
		/* Addition and subtraction rules: deriv (X + Y) = deriv(X) + deriv(Y) */
		
		res = value_init(VALUE_BLK);
		value_append_now(&res, op.core.u_blk.a[0]);
		der = value_deriv(op.core.u_blk.a[1]);
		value_append_now2(&res, &der);
		der = value_deriv(op.core.u_blk.a[2]);
		value_append_now2(&res, &der);
				
	} else if (f == &value_mul_arg) {
		/* Multiplication rule: deriv (X * Y) = Y*deriv(X) + X*deriv(Y) */
		
		res = value_init(VALUE_BLK);
		fun = value_set_fun(&value_add_arg);
		value_append_now2(&res, &fun);
		
		// Create a block containing Y*deriv(X) and add it to (res)
		der = value_deriv(op.core.u_blk.a[1]);
		blk = value_init(VALUE_BLK);
		fun = value_set_fun(&value_mul_arg);
		value_append_now2(&blk, &fun);
		value_append_now(&blk, op.core.u_blk.a[2]);
		value_append_now2(&res, &blk);
		value_append_now2(&blk, &der);
		
		// Create a block containing X*deriv(Y) and add it to (res)
		der = value_deriv(op.core.u_blk.a[2]);
		blk = value_init(VALUE_BLK);
		fun = value_set_fun(&value_mul_arg);
		value_append_now2(&blk, &fun);
		value_append_now(&blk, op.core.u_blk.a[1]);
		value_append_now2(&res, &blk);
		value_append_now2(&blk, &der);
		
	} else if (f == &value_div_arg) {
		/* Quotient rule: deriv (X / Y) = (Y*deriv(X) - X*deriv(Y)) / (Y**2) */
		
		fun = value_set_fun(&value_sub_arg);
		res = value_init(VALUE_BLK);
		value_append_now2(&res, &fun);
				
		// Create a block containing Y*deriv(X) and add it to (res)
		blk = value_init(VALUE_BLK);
		der = value_deriv(op.core.u_a.a[1]);
		fun = value_set_fun(&value_mul_arg);
		value_append_now2(&blk, &fun);
		value_append_now(&blk, op.core.u_a.a[2]);
		value_append_now2(&blk, &der);
		value_append_now2(&res, &blk);
		
		// Create a block containing X*deriv(Y) and add it to (res)
		blk = value_init(VALUE_BLK);
		der = value_deriv(op.core.u_a.a[2]);
		fun = value_set_fun(&value_mul_arg);
		value_append_now2(&blk, &fun);
		value_append_now(&blk, op.core.u_a.a[1]);
		value_append_now2(&blk, &der);
		value_append_now2(&res, &blk);		
		
		// Create a block containing Y**2
		blk = value_init(VALUE_BLK);
		fun = value_set_fun(&value_pow_arg);
		value tmp = value_set_long(2);
		value_append_now2(&blk, &fun);
		value_append_now(&blk, op.core.u_a.a[2]);
		value_append_now2(&blk, &tmp);
		
		// Divide (res) by (Y**2)
		tmp = value_init(VALUE_BLK);
		fun = value_set_fun(&value_div_arg);
		value_append_now2(&tmp, &fun);
		value_append_now2(&tmp, &res);
		value_append_now2(&tmp, &blk);
				
		res = tmp;
				
	} else if (f == &value_pow_arg) {
		/* Power rule: deriv (X ** n) = deriv(X) * n * (X**(n-1))
		 * Exponent rule: deriv (n ** X) = deriv(X) * (n ** X) * log n
		 */
		
		// Don't forget about the chain rule.
		
		if (op.core.u_blk.a[2].type == VALUE_MPZ || op.core.u_blk.a[2].type == VALUE_MPF) {
			// Calculate the derivative of X ** n.
						
			// deriv(X)
			der = value_deriv(op.core.u_blk.a[1]);
			
			// n - 1
			blk = value_dec(op.core.u_blk.a[2]);
			
			// Create a block containing X**(n-1)
			res = value_init(VALUE_BLK);
			fun = value_set_fun(&value_pow_arg);
			value_append_now2(&res, &fun);
			value_append_now(&res, op.core.u_blk.a[1]);
			value_append_now2(&res, &blk);
			blk = res;
			
			// Create a block containing n * X**(n-1)
			res = value_init(VALUE_BLK);
			fun = value_set_fun(&value_mul_arg);
			value_append_now(&res, fun);
			value_append_now(&res, op.core.u_blk.a[2]);
			value_append_now2(&res, &blk);
			blk = res;
			
			// Create a block containing deriv(X) * n * X**(n-1)
			res = value_init(VALUE_BLK);
			value_append_now2(&res, &fun);
			value_append_now2(&res, &blk);
			value_append_now2(&res, &der);
		}
	
	}
		
	value_optimize_now(&res, O_1 | O_2 | O_ASSUME_NUMERIC);
	
	return res;
}

value value_deriv_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "deriv") ? value_init_error() : value_deriv(argv[0]);
}

value value_eint(value op)
{
	value res = value_init_nil();
	if (op.type == VALUE_MPF) {
		res = value_init(VALUE_MPF);
		mpfr_eint(res.core.u_mf, op.core.u_mf, value_mpfr_round);
		return res;
	} else {
		value_error(1, "Type Error: eint() is undefined where op is %ts (float expected).", op);
		res = value_init_error();
	}
	
	return res;
}

value value_li2(value op)
{
	value res = value_init_nil();
	if (op.type == VALUE_MPF) {
		res = value_init(VALUE_MPF);
		mpfr_li2(res.core.u_mf, op.core.u_mf, value_mpfr_round);
		return res;
	} else {
		value_error(1, "Type Error: li2() is undefined where op is %ts (float expected).", op);
		res = value_init_error();
	}
	
	return res;	
}

value value_gamma(value op)
{
	value res = value_init_nil();
	if (op.type == VALUE_MPF) {
		res = value_init(VALUE_MPF);
		mpfr_gamma(res.core.u_mf, op.core.u_mf, value_mpfr_round);
		return res;
	} else {
		value_error(1, "Type Error: gamma() is undefined where op is %ts (float expected).", op);
		res = value_init_error();
	}
	
	return res;	
}

value value_lngamma(value op)
{
	value res = value_init_nil();
	if (op.type == VALUE_MPF) {
		res = value_init(VALUE_MPF);
		mpfr_lngamma(res.core.u_mf, op.core.u_mf, value_mpfr_round);
		return res;
	} else {
		value_error(1, "Type Error: lngamma() is undefined where op is %ts (float expected).", op);
		res = value_init_error();
	}
	
	return res;	
}

value value_zeta(value op)
{
	value res = value_init_nil();
	if (op.type == VALUE_MPF) {
		res = value_init(VALUE_MPF);
		mpfr_zeta(res.core.u_mf, op.core.u_mf, value_mpfr_round);
		return res;
	} else {
		value_error(1, "Type Error: zeta() is undefined where op is %ts (float expected).", op);
		res = value_init_error();
	}
	
	return res;	
}

value value_erf(value op)
{
	value res = value_init_nil();
	if (op.type == VALUE_MPF) {
		res = value_init(VALUE_MPF);
		mpfr_erf(res.core.u_mf, op.core.u_mf, value_mpfr_round);
		return res;
	} else {
		value_error(1, "Type Error: erf() is undefined where op is %ts (float expected).", op);
		res = value_init_error();
	}
	
	return res;	
}

value value_erfc(value op)
{
	value res = value_init_nil();
	if (op.type == VALUE_MPF) {
		res = value_init(VALUE_MPF);
		mpfr_erfc(res.core.u_mf, op.core.u_mf, value_mpfr_round);
		return res;
	} else {
		value_error(1, "Type Error: erfc() is undefined where op is %ts (float expected).", op);
		res = value_init_error();
	}
	
	return res;	
}


value value_srand(value seed)
{
	if (seed.type == VALUE_MPZ) {
		value max = value_set_ulong(ULONG_MAX);
		if (value_le(seed, max)) {
			init_genrand(value_get_ulong(seed));
		}
		
		value_clear(&max);
	}
	
	value_error(1, "Implementation error: srand() has not yet been implemented.");
	return value_init_error();
}

value value_rand(value max)
{
	value res, tmp, 
			adder = value_init_nil(), 
			max32 = value_set_ulong(0xffffffff);
	size_t shift = 0;
	
	if (value_eq(max, value_zero)) {
		res = value_set_double(genrand_real2());
		
	} else if (max.type == VALUE_MPZ) {
		
		res = value_set_ulong(0);
		max = value_set(max);
		
		while (value_gt(max, max32)) {
			value_clear(&adder);
			adder = value_set_ulong(genrand_int32());
			tmp = adder;
			adder = value_shl(adder, shift);
			value_clear(&tmp);
			
			value_add_now(&res, adder);
			tmp = max;
			max = value_shr(max, 32);
			value_clear(&tmp);
			shift += 32;
		}
		
		value_clear(&adder);
		tmp = value_rand(value_zero);
		adder = value_mul(tmp, max);
		value_clear(&tmp);
		tmp = value_cast(adder, VALUE_MPZ);
		value_clear(&adder);
		adder = value_shl(tmp, shift);
		value_clear(&tmp);
		
		value_add_now(&res, adder);
		value_clear(&max);
				
	} else if (max.type == VALUE_MPF) {
		
		// This is a bit slower than I'd like it to be. It has to not only 
		// calculate a random MPZ, but has to calculate a logarithm and 
		// perform several initializations, sets, and clears. This won't 
		// matter if (rand) isn't being called much, but if the user relies 
		// heavily on (rand), this will be important.
		
		// (prec) holds the precision, to ensure that the precision of the 
		// result is at least as great as (max) requires.
		mpfr_prec_t prec;
		value log = value_log2(max);
		prec = mpfr_get_d(log.core.u_mf, value_mpfr_round);
		value_clear(&log);
		
		value zmax = value_cast(max, VALUE_MPZ);
		value zres = value_rand(zmax);
		value randf = value_set_double(genrand_real2());
		prec += mpfr_get_prec(randf.core.u_mf);
		
		res.type = VALUE_MPF;
		mpfr_init2(res.core.u_mf, prec + 1);
		mpfr_add_z(res.core.u_mf, randf.core.u_mf, zres.core.u_mz, value_mpfr_round);
		
		value_clear(&zmax);
		value_clear(&zres);
		value_clear(&randf);
				
	} else {
		value_error(1, "Type Error: rand() is undefined where op is %ts (number expected).", max);
		res = value_init_error();
	}
	
	value_clear(&adder);
	value_clear(&max32);
	return res;
}

value value_srand_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "srand()") ? value_init_error() : value_srand(argv[0]);
}

value value_rand_arg(int argc, value argv[])
{
	if (argv[0].type == VALUE_NIL)
		argv[0] = value_set_long(0);
	
	return missing_arguments(argc, argv, "rand()") ? value_init_error() : value_rand(argv[0]);
}


value value_times(value *variables, value op, value func)
{	
	value res = value_init_nil();
	if (op.type == VALUE_MPZ) {
		value iter;
		for (iter = value_set_long(0); value_lt(iter, op); value_inc_now(&iter)) {
			value tmp = value_call(variables, func, 1, &iter);
			if (tmp.type == VALUE_ERROR || tmp.type == VALUE_STOP && (tmp.core.u_stop.type == STOP_RETURN || tmp.core.u_stop.type == STOP_EXIT)) {
				res = tmp;
				break;
			} else if (tmp.type == VALUE_STOP && tmp.core.u_stop.type == STOP_BREAK) {
				break;
			} else if (tmp.type == VALUE_STOP && tmp.core.u_stop.type == STOP_YIELD) {
				if (res.type == VALUE_NIL) res = value_init(VALUE_ARY);
				value_append_now(&res, *tmp.core.u_stop.core);
			}			
			value_clear(&tmp);
		}
		
		value_clear(&iter);
		
	} else {
		value_error(1, "Type Error: times() is undefined where op is %ts (integer expected).", op);
		res = value_init_error();
	}
	
	return res;
}

value value_summation(value *variables, value op, value func)
{
	value res = value_init_nil();
	
	if (op.type == VALUE_ARY) {
		size_t i;
		value tmp = value_init_nil();
		for (i = 0; i < op.core.u_a.length; ++i) {
			tmp = value_call(variables, func, 1, &op.core.u_a.a[i]);

			if (tmp.type == VALUE_STOP && tmp.core.u_stop.type == STOP_BREAK) {
				value_clear(&tmp);
				break;
			} else if (tmp.type == VALUE_ERROR || tmp.type == VALUE_STOP && (tmp.core.u_stop.type == STOP_RETURN || tmp.core.u_stop.type == STOP_EXIT)) {
				value_clear(&res);
				res = tmp;
				break;
			}
			
			if (i == 0)
				res = tmp;
			else {
				value_add_now(&res, tmp);
				value_clear(&tmp);
			}
		}
	

	} else if (op.type == VALUE_PAR) {
		value optr = op;
		
		int first_time_p = TRUE;
		value tmp = value_init_nil();
		while (optr.type == VALUE_PAR) {
			tmp = value_call(variables, func, 1, optr.core.u_l + 0);
			if (tmp.type == VALUE_STOP && tmp.core.u_stop.type == STOP_BREAK) {
				value_clear(&tmp);
				break;
			} else if (tmp.type == VALUE_ERROR || tmp.type == VALUE_STOP && (tmp.core.u_stop.type == STOP_RETURN || tmp.core.u_stop.type == STOP_EXIT)) {
				value_clear(&res);
				res = tmp;
				break;
			}
			
			if (first_time_p) {
				res = tmp;
				first_time_p = FALSE;
			} else {
				value_add_now(&res, tmp);
				value_clear(&tmp);
			}
			
			optr = optr.core.u_p->tail;
		}
			
	} else if (op.type == VALUE_RNG) {
		if (value_eq(op.core.u_r->min, op.core.u_r->max))
			return res;
		value min = value_set(op.core.u_r->min);
		value max = value_set(op.core.u_r->max);
		int reversed_p = value_gt(min, max);
		if (op.core.u_r->inclusive_p)
			if (reversed_p)
				value_dec_now(&max);
			else value_inc_now(&max);
		
		int first_time_p = TRUE;
		value tmp = value_init_nil();
		for (; reversed_p ? value_gt(min, max) : value_lt(min, max); reversed_p ? value_dec_now(&min) : value_inc_now(&min)) {
			tmp = value_call(variables, func, 1, &min);
			if (tmp.type == VALUE_STOP && tmp.core.u_stop.type == STOP_BREAK) {
				value_clear(&tmp);
				break;
			} else if (tmp.type == VALUE_ERROR || tmp.type == VALUE_STOP && (tmp.core.u_stop.type == STOP_RETURN || tmp.core.u_stop.type == STOP_EXIT)) {
				res = tmp;
				break;
			}
			
			if (first_time_p) {
				value_clear(&res);
				res = tmp;
				first_time_p = FALSE;
			} else {
				value_add_now(&res, tmp);
				value_clear(&tmp);
			}
		}
				
		value_clear(&min);
		value_clear(&max);
				
	
	} else {
		value_error(1, "Type Error: summation() is undefined where op is %ts (iterable expected).", op);
		res = value_init_error();
	}
	
	return res;
}

value value_times_arg(int argc, value argv[])
{
	value *tmp = value_deref(argv[0]);
	return missing_arguments(argc-1, argv+1, "times()") ? value_init_error() : value_times(tmp, argv[1], argv[2]);
}

value value_summation_arg(int argc, value argv[])
{
	value *tmp = value_deref(argv[0]);
	return missing_arguments(argc-1, argv+1, "summation()") ? value_init_error() : value_summation(tmp, argv[1], argv[2]);
}/*
 *  value_range.c
 *  Calculator
 *
 *  Created by Michael Dickens on 6/10/10.
 *  Copyright 2010 The Khabele School. All rights reserved.
 *
 */

#include "value.h"

value value_range_to(value op1, value op2)
{
	if (op1.type == VALUE_MPZ && op2.type == VALUE_MPZ) {
		int error_p = FALSE;
		if (value_gt(op2, value_int_max) || value_lt(op2, value_int_min)) {
			value_error(1, "Domain Error: ..() is undefined where op2 is greater than %s.", value_int_max);
			error_p = TRUE;
		}
		if (value_gt(op1, value_int_max) || value_lt(op1, value_int_min)) {
			value_error(1, "Domain Error: ..() is undefined where op1 is greater than %s.", value_int_max);
			error_p = TRUE;
		}
		value diff = value_sub(op2, op1);
		if (value_gt(diff, value_int_max) || value_lt(diff, value_int_min)) {
			value_error(1, "Domain Error: ..() is undefined where the difference between op1 and op2 is greater than %s.", value_int_max);
			error_p = TRUE;
		}
		value_clear(&diff);
		if (error_p)
			return value_init_error();
				
		value res;
		res.type = VALUE_RNG;
		res.core.u_r = value_malloc(NULL, sizeof(struct value_range));
		return_if_null(res.core.u_r);
		res.core.u_r->inclusive_p = TRUE;
		res.core.u_r->min = value_set(op1);
		res.core.u_r->max = value_set(op2);

		return res;
	}
	
	if (op1.type != VALUE_MPZ)
		value_error(1, "Type Error: ..() is undefined where op1 is %ts (integer expected).", op1);

	if (op1.type != op2.type)
		value_error(1, "Type Error: ..() is undefined for %ts and %ts.", op1, op2);
	
	return value_init_error();
}

value value_range_until(value op1, value op2)
{
	if (op1.type == VALUE_MPZ && op2.type == VALUE_MPZ) {
		int error_p = FALSE;
		if (value_gt(op2, value_int_max) || value_lt(op2, value_int_min)) {
			value_error(1, "Domain Error: ...() is undefined where op2 is greater than %s.", value_int_max);
			error_p = TRUE;
		}
		if (value_gt(op1, value_int_max) || value_lt(op1, value_int_min)) {
			value_error(1, "Domain Error: ...() is undefined where op1 is greater than %s.", value_int_max);
			error_p = TRUE;
		}
		value diff = value_sub(op2, op1);
		if (value_gt(diff, value_int_max) || value_lt(diff, value_int_min)) {
			value_error(1, "Domain Error: ...() is undefined where the difference between op1 and op2 is greater than %s.", value_int_max);
			error_p = TRUE;
		}
		value_clear(&diff);
		if (error_p)
			return value_init_error();
		
		value res;
		res.type = VALUE_RNG;
		res.core.u_r = value_malloc(NULL, sizeof(struct value_range));
		return_if_null(res.core.u_r);
		res.core.u_r->inclusive_p = FALSE;
		res.core.u_r->min = value_set(op1);
		res.core.u_r->max = value_set(op2);

		return res;
	}
	
	if (op1.type != VALUE_MPZ)
		value_error(1, "Type Error: ...() is undefined where op1 is %ts (integer expected).", op1);

	if (op1.type != op2.type)
		value_error(1, "Type Error: ...() is undefined for %ts and %ts.", op1, op2);
	
	return value_init_error();
}

value value_range_to_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "..()") ? value_init_error() : value_range_to(argv[0], argv[1]);
}

value value_range_until_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "...()") ? value_init_error() : value_range_until(argv[0], argv[1]);
}

/*
 *  value_regex.c
 *  Calculator
 *
 *  Created by Michael Dickens on 6/1/10.
 * 
 *  Uses POSIX regular expressions from the GNU C Library.
 *  GNU Regular Expressions: http://www.gnu.org/s/libc/manual/html_node/Regular-Expressions.html
 *  POSIX: http://www.regular-expressions.info/posix.html
 */

#include "value.h"

int compile_regex(regex_t *compiled, char *regex, int flags)
{
	int r = regcomp(compiled, regex, flags | REG_EXTENDED);
	if (r == REG_BADBR)
		value_error(1, "Syntax Error: Cannot compile regular expression '%s'; invalid construct between curly brackets.", regex);
	else if (r == REG_BADPAT)
		value_error(1, "Syntax Error: Cannot compile regular expression '%s'; syntax error.", regex);
	else if (r == REG_BADRPT)
		value_error(1, "Syntax Error: Cannot compile regular expression '%s'; repetition operator (?, *, +) appeared in a bad position.", regex);
	else if (r == REG_ECOLLATE)
		value_error(1, "Syntax Error: Cannot compile regular expression '%s'; referred to an invalid collating element.", regex);
	else if (r == REG_ECTYPE)
		value_error(1, "Syntax Error: Cannot compile regular expression '%s'; referred to an invalid character class name.", regex);
	else if (r == REG_EESCAPE)
		value_error(1, "Syntax Error: Cannot compile regular expression '%s'; ended with '\\'.", regex);
	else if (r == REG_ESUBREG)
		value_error(1, "Syntax Error: Cannot compile regular expression '%s'; invalid number in \\digit construct.", regex);
	else if (r == REG_EBRACK)
		value_error(1, "Syntax Error: Cannot compile regular expression '%s'; unbalanced square brackets.", regex);
	else if (r == REG_EPAREN)
		value_error(1, "Syntax Error: Cannot compile regular expression '%s'; unbalanced parentheses.", regex);
	else if (r == REG_EBRACE)
		value_error(1, "Syntax Error: Cannot compile regular expression '%s'; unbalanced curly brackets.", regex);
	else if (r == REG_ERANGE)
		value_error(1, "Syntax Error: Cannot compile regular expression '%s'; one of the enpoints in a range expression was invalid.", regex);
	else if (r == REG_ESPACE)
		value_error(1, "Syntax Error: Cannot compile regular expression '%s'; compiler ran out of memory.", regex);
	
	return r;
}

int value_match_p(value regex, value str)
{
	int error_p = FALSE;
	if (regex.type != VALUE_RGX && regex.type != VALUE_STR) {
		value_error(1, "Type Error: match?() is undefined where regex is %ts (string or regular expression expected).", regex);
		error_p = TRUE;
	}
	
	if (str.type != VALUE_STR) {
		value_error(1, "Type Error: match?() is undefined where str is %ts (string expected).", str);
		error_p = TRUE;
	}
	
	if (error_p)
		return -1;
	
	regex_t compiled;
	int r = compile_regex(&compiled, regex.core.u_x, 0);
	if (r != 0)
		return -2;
	int match = regexec(&compiled, str.core.u_s, 0, NULL, 0);
	if (match == REG_ESPACE) {
		value_error(1, "Memory Error: match?() ran out of memory.");
		return -3;
	}
	
	return match == 0;
}

value value_match_p_std(value regex, value str)
{
	int match = value_match_p(regex, str);
	if (match < 0)
		return value_init_error();
	return value_set_bool(match);
}

/* 
 * Return Codes (contained in res.rm_so)
 * 
 * -1: No match.
 * -2: Memory error.
 * -3: Compile error.
 * -4: Type error.
 */
regmatch_t value_match(value regex, value str)
{
	int error_p = FALSE;
	if (regex.type != VALUE_RGX && regex.type != VALUE_STR) {
		value_error(1, "Type Error: match() is undefined where regex is %ts (string or regular expression expected).", regex);
		error_p = TRUE;
	}
	
	if (str.type != VALUE_STR) {
		value_error(1, "Type Error: match() is undefined where str is %ts (string expected).", str);
		error_p = TRUE;
	}
	
	regmatch_t matchptr[1];
	matchptr[0].rm_so = -1; // -1 indicates that there was no match.
	
	if (error_p) {
		matchptr[0].rm_so = -4;
		return matchptr[0];
	}
	
	regex_t compiled;
	int r = compile_regex(&compiled, regex.core.u_x, 0);
	if (r != 0) {
		matchptr[0].rm_so = -3;
		return matchptr[0];
	}
	
	int match = regexec(&compiled, str.core.u_s, 1, matchptr, 0);
	if (match == REG_ESPACE) {
		value_error(1, "Memory Error: match() ran out of memory.");
		matchptr[0].rm_so = -2;
		return matchptr[0];
	}

	return matchptr[0];	
}

regmatch_t value_match_str(value regex, char *str)
{
	value x;
	x.type = VALUE_STR;
	x.core.u_s = str;
	return value_match(regex, x);
}

value value_match_std(value regex, value str)
{
	regmatch_t match = value_match(regex, str);
	
	if (match.rm_so < -1)
		return value_init_error();
	if (match.rm_so == -1)
		return value_init_nil();
	return value_set_long((long) match.rm_so);	
}

value value_match_p_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "match?()") ? value_init_error() : value_match_p_std(argv[0], argv[1]);
}

value value_match_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "match()") ? value_init_error() : value_match_std(argv[0], argv[1]);
}
/*
 *  value_string.c
 *  Calculator
 *
 *  Created by Michael Dickens on 2/13/10.
 *
 */

#include "value.h"

value value_set_str(char *str)
{
	value res;
	
	res.type = VALUE_STR;
	size_t len = strlen(str);
	value_malloc(&res, len+1);
	return_if_error(res);
	strcpy(res.core.u_s, str);
	return res;
}

value value_set_str_length(char *str, size_t length)
{
	value res;
	
	res.type = VALUE_STR;
	value_malloc(&res, length + 1);
	return_if_error(res);
	strncpy(res.core.u_s, str, length);
	res.core.u_s[length] = '\0';
	return res;
}

value value_set_symbol(char *str)
{
	value res;
	
	res.type = VALUE_SYM;
	size_t len = strlen(str);
	res.core.u_s = value_malloc(NULL, len+1);
	return_if_null(res.core.u_s);
	strcpy(res.core.u_s, str);
	return res;
}

value value_capitalize(value op)
{
	if (op.type != VALUE_STR) {
		value_error(1, "Type Error: String operation capitalize() is undefined where op is not a string.");
		return value_init_error();
	}
	
	value res;
	
	res.type = VALUE_STR;
	value_malloc(&res, strlen(op.core.u_s) + 1);
	return_if_error(res);
	strcpy(res.core.u_s, op.core.u_s);
	char *ptr = res.core.u_s;
	*ptr = toupper(*ptr);
	while (*(++ptr) = tolower(*ptr))
		;
	
	return res;
}

value value_asc(value op)
{
	if (op.type == VALUE_STR) {
		if (op.core.u_s[0] != '\0' && op.core.u_s[1] == '\0') {
			return value_set_long(op.core.u_s[0]);
		} else {
			value_error(1, "Type Error: asc() is undefined where op is %s (it must contain only one character).", op);
		}
		
	} else {
		value_error(1, "Type Error: asc() is undefined where op is %ts (string expected).", op);
	}

	return value_init_error();
}

value value_chop(value op)
{
	if (op.type == VALUE_STR) {
		value res;
		
		res.type = VALUE_STR;
		size_t length = strlen(op.core.u_s);
		if (length == 0) {
			res = value_set_str("");
			return res;
		}
		value_malloc(&res, length);
		return_if_error(res);
		strncpy(res.core.u_s, op.core.u_s, length-1);
		res.core.u_s[length-1] = '\0';
		return res;
	} else if (op.type == VALUE_RGX) {
		value res;
		
		res.type = VALUE_RGX;
		size_t length = strlen(op.core.u_x);
		if (length == 0) {
			res.core.u_x = value_malloc(NULL, sizeof(char) * 1);
			return_if_null(res.core.u_x);
			res.core.u_x[0] = '\0';
			return res;
		}
		res.core.u_x = value_malloc(NULL, length);
		return_if_null(res.core.u_x);
		strncpy(res.core.u_x, op.core.u_x, length-1);
		res.core.u_s[length-1] = '\0';
		return res;
	} else {
		value_error(1, "Type Error: chop() is undefined where op is %ts (string expected).", op);
		return value_init_error();
	}
	
}

value value_chop_now(value *op)
{
	value res = value_init_nil();
	if (op->type == VALUE_STR) {
		size_t length = strlen(op->core.u_s);
		value_realloc(op, length);
		return_if_error(*op);
		op->core.u_s[length-1] = '\0';
	} else if (op->type == VALUE_RGX) {
		op->type = VALUE_STR;
		res = value_chop_now(op);
		op->type = VALUE_RGX;
	} else {
		value_error(1, "Type Error: chop!() is undefined where op is %ts (string expected).", *op);
		res = value_init_error();
	}
	
	return res;
}

value value_chr(value op)
{
	if (op.type == VALUE_MPZ) {
		value zero = value_set_long(0);
		value charmax = value_set_long(256);
		value res;
		if (value_ge(op, zero) && value_lt(op, charmax)) {
			char str[2];
			str[0] = value_get_ulong(op);
			str[1] = '\0';
			res = value_set_str(str);
		} else {
			value_error(1, "Argument Error: In chr(), %ts is out of the character range.", op);
			res = value_init_error();
		}
		
		value_clear(&zero);
		value_clear(&charmax);
		return res;
	} else {
		value_error(1, "Type Error: chr() is undefined where op is %ts (integer expected).", op);
		return value_init_error();
	}

}

int value_contains_p(value op1, value op2)
{
	value res = value_contains_p_std(op1, op2);
	if (res.type == VALUE_BOO)
		return res.core.u_b;
	else return FALSE;
}

value value_contains_p_std(value op1, value op2)
{
	if (op1.type == VALUE_STR) {
		if (op2.type == VALUE_STR) {
			return value_set_bool(strstr(op1.core.u_s, op2.core.u_s) != NULL);
		} else if (op2.type == VALUE_RGX) {
			regex_t compiled;
			int r = compile_regex(&compiled, op2.core.u_x, 0);
			if (r != 0)
				return value_init_error();
			int match = regexec(&compiled, op1.core.u_s, 0, NULL, 0);
			if (match == REG_ESPACE) {
				value_error(1, "Memory Error: contains?() ran out of memory.");
				return value_init_error();
			}
			return value_set_bool(match == 0);			
		} else {
			value_error(1, "Type Error: contains?() is undefined where op1 is a string and op2 is %ts (string or regular expression expected).", op1);
			return value_init_error();
		}

	} else if (op1.type == VALUE_ARY) {
		int length = value_length(op1);
		int i;
		for (i = 0; i < length; ++i)
			if (value_eq(op1.core.u_a.a[i], op2))
				return value_set_bool(TRUE);
		return value_set_bool(FALSE);
		
	} else if (op1.type == VALUE_LST) {
		while (!value_empty_p(op1))
			if (value_eq(op1.core.u_l[0], op2))
				return value_set_bool(TRUE);
			else op1 = op1.core.u_l[1];
		return value_set_bool(FALSE);
		
	} else if (op1.type == VALUE_HSH) {
		return value_set_bool(value_hash_exists(op1, op2));
	}
	
	value_error(1, "Type Error: contains?() is undefined where op1 is %ts (string or array expected).", op1);
	return value_init_error();
}

int value_ends_with_p(value op1, value op2)
{
	return value_ends_with_p_std(op1, op2).core.u_b;
}

value value_ends_with_p_std(value op1, value op2)
{
	int error_p = FALSE;
	if (op1.type != VALUE_STR) {
		value_error(1, "Type Error: ends_with() is undefined where op1 is %ts (string expected).", op1);
		error_p = TRUE;
	}
		
	if (op2.type != VALUE_STR) {
		value_error(1, "Type Error: ends_with() is undefined where op2 is %ts (string expected).", op2);
		error_p = TRUE;
	}
	
	if (error_p)
		return value_init_error();
	
	size_t addition = value_length(op1) - value_length(op2);
	return value_set_bool(strcmp(op1.core.u_s + addition, op2.core.u_s) == 0);
}

size_t value_index(value op1, value op2)
{	
	if (op1.type == VALUE_STR) {
		if (op2.type == VALUE_STR) {
			char *ptr = strstr(op1.core.u_s, op2.core.u_s);
			if (ptr == NULL)
				return -1;
			else return ptr - op1.core.u_s;
		} else if (op2.type == VALUE_RGX) {
			regex_t compiled;
			int r = compile_regex(&compiled, op2.core.u_x, 0);
			if (r != 0)
				return -2;
			
			// The first element of regexec() tells where the string matches. That's all we care about.
			regmatch_t matchptr[1];
			matchptr[0].rm_so = -1;
			int match = regexec(&compiled, op1.core.u_s, 1, matchptr, 0);
			if (match == REG_ESPACE) {
				value_error(1, "Memory Error: match() ran out of memory.");
				return -2;
			}
			if (matchptr[0].rm_so == -1)
				return -1;
			return (size_t) matchptr[0].rm_so;
			
		} else {
			value_error(1, "Type Error: index() is undefined where op1 is a string and op2 is %ts (string or regular expression expected).", op2);
			return -2;			
		}

	}
	
	if (op1.type == VALUE_ARY) {
		size_t length = value_length(op1);
		size_t i;
		for (i = 0; i < length; ++i)
			if (value_eq(op1.core.u_a.a[i], op2))
				return i;
		return -1;
	}
	
	if (op1.type == VALUE_LST) {
		size_t i;
		for (i = 0; !value_empty_p(op1); ++i)
			if (value_eq(op1.core.u_l[0], op2))
				return i;
			else op1 = op1.core.u_l[1];
		return -1;
	}
	
	value_error(1, "Type Error: index() is undefined where op1 is %ts (string, array or list expected).", op1);
	return -2;
}

value value_index_std(value op1, value op2)
{
	if (op1.type == VALUE_STR) {
		if (op2.type == VALUE_STR) {
			char *ptr = strstr(op1.core.u_s, op2.core.u_s);
			if (ptr == NULL)
				return value_init_nil();
			else return value_set_long(ptr - op1.core.u_s);
		} else if (op2.type == VALUE_RGX) {
			regex_t compiled;
			int r = compile_regex(&compiled, op2.core.u_x, 0);
			if (r != 0)
				return value_init_error();
			
			// The first element of regexec() tells where the string matches. That's all we care about.
			regmatch_t matchptr[1];
			matchptr[0].rm_so = -1;
			int match = regexec(&compiled, op1.core.u_s, 1, matchptr, 0);
			if (match == REG_ESPACE) {
				value_error(1, "Memory Error: match() ran out of memory.");
				return value_init_error();
			}
			if (matchptr[0].rm_so == -1)
				return value_init_nil();
			return value_set_long((long) matchptr[0].rm_so);
			
		} else {
			value_error(1, "Type Error: index() is undefined where op1 is a string and op2 is %ts (string or regular expression expected).", op2);
			return value_init_error();			
		}

	} else if (op1.type == VALUE_ARY) {
		size_t length = value_length(op1);
		size_t i;
		for (i = 0; i < length; ++i)
			if (value_eq(op1.core.u_a.a[i], op2))
				return value_set_ulong(i);
		return value_init_nil();
		
	} else if (op1.type == VALUE_LST) {
		size_t i;
		for (i = 0; !value_empty_p(op1); ++i)
			if (value_eq(op1.core.u_l[0], op2))
				return value_set_long(i);
			else op1 = op1.core.u_l[1];
		return value_init_nil();
	}
	
	value_error(1, "Type Error: index() is undefined where op1 is %ts (string, array or list expected).", op1);
	return value_init_error();
}

value value_insert(value op1, value index, value op3)
{
	long inx;
	
	if (op1.type == VALUE_STR && op3.type == VALUE_STR) {
		if (index.type == VALUE_MPZ) {
			if (value_lt(index, value_zero)) {
				value_error(1, "Domain Error: insert() is undefined where index is %s (>= 0 expected).", index);
				return value_init_error();
			} else if (value_gt(index, value_int_max)) {
				value_error(1, "Domain Error: insert() is undefined where index is %s (<= %s expected).", index, value_int_max);
				return value_init_error();
			} else inx = value_get_long(index);
		} else {
			value_error(1, "Type Error: insert() is undefined where op1 is a string and index is %ts (integer expected).", index);
			return value_init_error();
		}
		
		size_t length = strlen(op1.core.u_s);
		if (inx > length)
			inx = length;
		
		value res;
		res.type = VALUE_STR;
		value_malloc(&res, length + strlen(op3.core.u_s) + 1);
		return_if_error(res);
		strncpy(res.core.u_s, op1.core.u_s, inx);
		strcpy(res.core.u_s + inx, op3.core.u_s);
		strcpy(res.core.u_s + inx + strlen(op3.core.u_s), op1.core.u_s + inx);
		return res;
	} else if (op1.type == VALUE_ARY) {
		if (index.type == VALUE_MPZ) {
			if (value_lt(index, value_zero)) {
				value_error(1, "Domain Error: insert() is undefined where index is %s (>= 0 expected).", index);
				return value_init_error();
			} else if (value_gt(index, value_int_max)) {
				value_error(1, "Domain Error: insert() is undefined where index is %s (<= %s expected).", index, value_int_max);
				return value_init_error();
			} else inx = value_get_long(index);
		} else {
			value_error(1, "Type Error: insert() is undefined where op1 is an array and index is %ts (integer expected).", index);
			return value_init_error();
		}
		
		value res;
		res.type = VALUE_ARY;
		size_t length = value_length(op1);
		if (inx > length)
			inx = length;
		
		res.core.u_a.a = value_malloc(NULL, sizeof(value) * next_size(op1.core.u_a.length + 1));
		return_if_null(res.core.u_a.a);
		res.core.u_a.length = op1.core.u_a.length + 1;
		size_t i;
		for (i = 0; i < inx; ++i)
			res.core.u_a.a[i] = value_set(op1.core.u_a.a[i]);
		res.core.u_a.a[inx] = value_set(op3);
		for (i = inx; i < length; ++i)
			res.core.u_a.a[i+1] = value_set(op1.core.u_a.a[i]);
		
		return res;
	} else if (op1.type == VALUE_LST) {
		if (index.type == VALUE_MPZ) {
			if (value_lt(index, value_zero)) {
				value_error(1, "Domain Error: insert() is undefined where index is %s (>= 0 expected).", index);
				return value_init_error();
			} else if (value_gt(index, value_int_max)) {
				value_error(1, "Domain Error: insert() is undefined where index is %s (<= %s expected).", index, value_int_max);
				return value_init_error();
			} else inx = value_get_long(index);
		} else {
			value_error(1, "Type Error: insert() is undefined where op1 is a list and index is %ts (integer expected).", index);
			return value_init_error();
		}

		value res = value_init_nil();
		value optr = op1;
		value *rptr = &res;
		
		size_t i;
		for (i = 0; optr.type == VALUE_LST; ++i) {
			if (i == inx) {
				*rptr = value_init(VALUE_LST);
				rptr->core.u_l[0] = value_set(op3);
			} else {
				*rptr = value_init(VALUE_LST);
				rptr->core.u_l[0] = value_set(optr.core.u_l[0]);
				optr = optr.core.u_l[1];
			}
			
			rptr->core.u_l[1] = value_init_nil();
			rptr = &rptr->core.u_l[1];
		}
		
		if (i < inx) {
			value_error(1, "Domain Error: insert() is undefined where index is %s (<= %ld expected).", index, i);
			value_clear(&res);
			res = value_init_error();
		}
				
		return res;
		
	} else if (op1.type == VALUE_HSH) {
		value res = value_set(op1);
		value_hash_put(&res, index, op3);
		return res;
	}
	
	if (op1.type != VALUE_STR && op1.type != VALUE_ARY)
		value_error(1, "Type Error: insert() is undefined where op1 is %ts (array or string expected).", op1);
	if (op1.type == VALUE_STR && op3.type != VALUE_STR)
		value_error(1, "Type Error: insert() is undefined where op1 is a string and op3 is %ts (string expected).", op3);
	return value_init_error();
}

value value_insert_now(value *op1, value index, value op3)
{
	value res = value_init_nil();
	long inx;
	
	if (op1->type == VALUE_ARY) {
		if (index.type == VALUE_MPZ) {
			if (value_lt(index, value_zero)) {
				value_error(1, "Type Error: insert!() is undefined where index is %s (>= 0 expected).", index);
				return value_init_error();
			} else if (value_gt(index, value_int_max)) {
				value_error(1, "Type Error: insert!() is undefined where index is %s (<= %s expected).", index, value_int_max);
				return value_init_error();
			} else inx = value_get_long(index);
		} else {
			value_error(1, "Type Error: insert!() is undefined where op1 is an array and index is %ts (integer expected).", index);
			return value_init_error();
		}
		
		if (resize_p(op1->core.u_a.length)) {
			value_realloc(op1, next_size(op1->core.u_a.length));
			return_if_error(*op1);
		}
				
		long i;
		for (i = op1->core.u_a.length; inx < i; )
			op1->core.u_a.a[i] = op1->core.u_a.a[--i];
		
		++op1->core.u_a.length;
		op1->core.u_a.a[inx] = value_set(op3);
	
	} else if (op1->type == VALUE_LST) {
		if (index.type == VALUE_MPZ) {
			if (value_lt(index, value_zero)) {
				value_error(1, "Domain Error: insert!() is undefined where index is %s (>= 0 expected).", index);
				return value_init_error();
			} else if (value_gt(index, value_int_max)) {
				value_error(1, "Domain Error: insert!() is undefined where index is %s (<= %s expected).", index, value_int_max);
				return value_init_error();
			} else inx = value_get_long(index);
		} else {
			value_error(1, "Type Error: insert!() is undefined where op1 is a list and index is %ts (integer expected).", index);
			return value_init_error();
		}

		value *optr = op1;
		
		size_t i;
		for (i = 0; optr->type == VALUE_LST; ++i) {
			if (i == inx) {
				value added = value_cons_now(op3, optr);
				optr = &added;
			}
			
			optr = &optr->core.u_l[1];
		}
		
		if (i < inx) {
			value_error(1, "Domain Error: insert!() is undefined where index is %s (<= %ld expected).", index, i);
			res = value_init_error();
		} else if (i == inx) {
			*optr = value_init(VALUE_LST);
			optr->core.u_l[0] = value_set(op3);
		}
		
	} else if (op1->type == VALUE_HSH) {
		res = value_hash_put(op1, index, op3);
	} else {
		value tmp = value_insert(*op1, index, op3);
		return_if_error(tmp);
		value_clear(op1);
		*op1 = tmp;
	}

	
	return res;
}

int value_alpha_p(value op)
{
	if (op.type != VALUE_STR) {
		value_error(1, "Syntax Error: String operation alpha?() is undefined where op is %ts (string expected).", op);
		return VALUE_ERROR;
	}
	
	char *ptr = op.core.u_s - 1;
	while (*(++ptr) != '\0')
		if (!isalpha(*ptr))
			return FALSE;
	return TRUE;
}

value value_alpha_p_std(value op)
{
	if (op.type != VALUE_STR) {
		value_error(1, "Syntax Error: String operation alpha?() is undefined where op is %ts (string expected).", op);
		return value_init_error();
	}
	
	char *ptr = op.core.u_s - 1;
	while (*(++ptr) != '\0')
		if (!isalpha(*ptr))
			return value_set_bool(FALSE);
	return value_set_bool(TRUE);
}

int value_alnum_p(value op)
{
	if (op.type != VALUE_STR) {
		value_error(1, "Type Error: String operation alnum?() is undefined where op is not a string.");
		return VALUE_ERROR;
	}
	
	char *ptr = op.core.u_s - 1;
	while (*(++ptr) != '\0')
		if (!isalnum(*ptr))
			return FALSE;
	return TRUE;
}

value value_alnum_p_std(value op)
{
	if (op.type != VALUE_STR) {
		value_error(1, "Type Error: String operation alnum?() is undefined where op is not a string.");
		return value_init_error();
	}
	
	char *ptr = op.core.u_s - 1;
	while (*(++ptr) != '\0')
		if (!isalnum(*ptr))
			return value_set_bool(FALSE);
	return value_set_bool(TRUE);
}

int value_num_p(value op)
{
	if (op.type != VALUE_STR) {
		value_error(1, "Type Error: String operation num?() is undefined where op is %ts (string expected).", op);
		return VALUE_ERROR;
	}
	
	char *ptr = op.core.u_s - 1;
	while (*(++ptr) != '\0')
		if (!isdigit(*ptr))
			return FALSE;
	return TRUE;
}

value value_num_p_std(value op)
{
	if (op.type != VALUE_STR) {
		value_error(1, "Type Error: String operation num?() is undefined where op is %ts (string expected).", op);
		return value_init_error();
	}
	
	char *ptr = op.core.u_s - 1;
	while (*(++ptr) != '\0')
		if (!isdigit(*ptr))
			return value_set_bool(FALSE);
	return value_set_bool(TRUE);
}

size_t value_length(value op)
{
	if (op.type == VALUE_NIL)
		return 0;
	else if (op.type == VALUE_STR || op.type == VALUE_RGX)
		return strlen(op.core.u_s);
	else if (op.type == VALUE_ARY)
		return op.core.u_a.length;
	else if (op.type == VALUE_LST) {
		size_t length = 0;
		while (op.type == VALUE_LST) {
			++length;
			op = op.core.u_l[1];
		}
		return length;
	} else if (op.type == VALUE_PAR) {
		size_t length = 0;
		while (op.type == VALUE_PAR) {
			++length;
			op = op.core.u_p->tail;
		}
		return length;
	} else if (op.type == VALUE_BLK)
		return op.core.u_blk.length;
	else {
		value_error(1, "Type Error: length() is undefined where op is %ts (linear container expected).", op);
		return 0;
	}
}

value value_length_std(value op)
{
	if (op.type == VALUE_NIL)
		return value_set_long(0);
	else if (op.type == VALUE_STR || op.type == VALUE_RGX)
		return value_set_long(strlen(op.core.u_s));
	else if (op.type == VALUE_ARY)
		return value_set_long((long) op.core.u_a.length);
	else if (op.type == VALUE_LST || op.type == VALUE_PAR)
		return value_set_long(value_length(op));
	else if (op.type == VALUE_BLK)
		return value_set_long(op.core.u_blk.length);
	else {
		value_error(1, "Type Error: length() is undefined where op is %ts (linear container expected).", op);
		return value_init_error();
	}
}

value value_lstrip(value op)
{
	value res;
	if (op.type == VALUE_STR) {
		char *ptr = op.core.u_s;
		while (isspace(*ptr))
			++ptr;
		res.type = VALUE_STR;
		res.core.u_s = value_malloc(NULL, strlen(ptr));
		return_if_null(res.core.u_s);
		strcpy(res.core.u_s, ptr);
	} else {
		value_error(1, "Type Error: lstrip() is undefined where op is %ts (string expected).", op);
		res = value_init_error();
	}
	
	return res;
}

value value_range(value op, value start, value end)
{
	long istart, iend;
	int error_p = FALSE;
	
	if (start.type == VALUE_MPZ) {
		istart = value_get_long(start);
	} else {
		value_error(1, "Type Error: range() is undefined where start is %ts (integer expected).", start);
		error_p = TRUE;
	}
	
	if (end.type == VALUE_MPZ) {
		iend = value_get_long(end);
	} else {
		value_error(1, "Type Error: range() is undefined where end is %ts (integer expected).", end);
		error_p = TRUE;
	}
	
	if (op.type == VALUE_STR || op.type == VALUE_RGX) {
		if (error_p)
			return value_init_error();
		
		if (iend <= istart)
			return value_init_nil();
		
		size_t length = strlen(op.core.u_s);
		if (istart >= length)
			return value_init_nil();
		if (iend > length)
			iend = length;
		
		value res;
		res.type = VALUE_STR;
		value_malloc(&res, iend - istart + 1);
		return_if_error(res);
		strncpy(res.core.u_s, op.core.u_s+istart, iend - istart);
		res.core.u_s[iend - istart] = '\0';
		return res;
	}
	
	if (op.type == VALUE_ARY) {
		if (error_p)
			return value_init_error();

		if (iend <= istart)
			return value_init_nil();
		
		size_t length = value_length(op);

		if (istart >= length)
			return value_init_nil();
				
		if (iend > length)
			iend = length;
		
		value res;
		res.type = VALUE_ARY;
		res.core.u_a.a = value_malloc(NULL, sizeof(value) * (iend - istart + 1));
		return_if_null(res.core.u_a.a);

		size_t i;
		for (i = istart; i < iend; ++i)
			res.core.u_a.a[i-istart] = value_set(op.core.u_a.a[i]);
		res.core.u_a.length = iend - istart;
		
		return res;
	}
	
	value_error(1, "Type Error: Operation range() is undefined where op is %ts (string or array expected).", op);
	return value_init_error();
}

value value_replace(value op1, value op2, value op3)
{
	int error_p = FALSE;
	if (op1.type != VALUE_STR) {
		value_error(1, "Type Error: String operation replace() is undefined where op1 is %ts (string expected).", op1);
		error_p = TRUE;
	}
	
	if (op2.type != VALUE_STR && op2.type != VALUE_RGX) {
		value_error(1, "Type Error: String operation replace() is undefined where op2 is %ts (string or regex expected).", op2);
		error_p = TRUE;
	}
	
	if (op3.type != VALUE_STR) {
		value_error(1, "Type Error: String operation replace() is undefined where op3 is %ts (string expected).", op3);
		error_p = TRUE;
	}
	
	if (error_p)
		return value_init_error();
	
	value res = value_init_nil();
	
	if (op2.type == VALUE_STR) {
		size_t length = strlen(op1.core.u_s);
		size_t length2 = strlen(op2.core.u_s);
		size_t length3 = strlen(op3.core.u_s);
		
		// (buflen) is the longest that the resulting string can be. If length3 > length2, then 
		// the longest possible resulting string would be if op1 is entirely made up of N 
		// repetitions of op2, in which case the result would be N repetitions of op3.
		size_t buflen = length3 > length2 ? (length / length2 + 1) * length3 : length;
		char buffer[buflen];
		
		size_t bi = 0;
		size_t i, j;
		for (i = 0; i < length; ) {
			int replace_p = TRUE;
			for (j = 0; j < length2; ++j) {
				if (i+j >= length || op1.core.u_s[i+j] != op2.core.u_s[j]) {
					replace_p = FALSE;
					break;
				}
			}
			
			if (replace_p) {
				strcpy(buffer+bi, op3.core.u_s);
				bi += length3;
			} else {
				++j;
				strncpy(buffer+bi, op1.core.u_s+i, j);
				buffer[bi+j] = '\0';
				bi += strlen(buffer+bi);
			}
			
			i += j;
		}
		
		res = value_set_str(buffer);
	} else {
		size_t length = strlen(op1.core.u_s);
		size_t length3 = strlen(op3.core.u_s);
		
		// This is the largest that the result can possibly be, but it takes O(n^2) space. 
		// I need to find a more efficient way to do this.
		size_t buflen = length * length3;
		char buffer[buflen];
		
		size_t i, bi = 0;
		regmatch_t match;
		for (i = 0; i < length; ) {
			if ((match = value_match_str(op2, op1.core.u_s + i)).rm_so != -1) {
				// Copy the part of the string that came before the match.
				strncpy(buffer+bi, op1.core.u_s + i, match.rm_so);
				bi += match.rm_so;
				
				// Copy the match.
				strcpy(buffer+bi, op3.core.u_s);
				bi += length3;
				i += match.rm_eo;
			} else {
				buffer[bi++] = op1.core.u_s[i++];
			}
		}
		
		buffer[bi] = '\0';
		res = value_set_str(buffer);
	}

	
	return res;
}

value value_replace_now(value *op1, value op2, value op3)
{
	value res = value_replace(*op1, op2, op3);
	if (res.type == VALUE_ERROR)
		return res;
	value_clear(op1);
	*op1 = res;
	return value_init_nil();
}

value value_reverse(value op)
{
	value res = value_init_nil();
	
	if (op.type == VALUE_NIL) {
		
	} else if (op.type == VALUE_STR) {
		res = value_set(op);
		size_t i, len = strlen(res.core.u_s), max = len >> 1;
		char temp;
		for (i = 0; i < max; ++i) {
			temp = res.core.u_s[i];
			res.core.u_s[i] = res.core.u_s[len-i-1];
			res.core.u_s[len-i-1] = temp;
		}
	} else if (op.type == VALUE_ARY) {
		res = value_set(op);
		value temp;
		size_t length = value_length(op);
		size_t length2 = length >> 1;
		int i;
		for (i = 0; i < length2; ++i) {
			temp = res.core.u_a.a[i];
			res.core.u_a.a[i] = res.core.u_a.a[length-i-1];
			res.core.u_a.a[length-i-1] = temp;
		}
	} else if (op.type == VALUE_LST) {
		res = value_init_nil();
		
		value ptr = op;
		while (ptr.type == VALUE_LST) {
			value_cons_now(ptr.core.u_l[0], &res);
			ptr = ptr.core.u_l[1];
		}		
		
	} else {
		value_error(1, "Type Error: reverse() is undefined where op is %ts (linear container expected).", op);
		res = value_init_error();
	}

	return res;
}

value value_reverse_now(value *op)
{
	if (op->type == VALUE_NIL) {
		
	} else if (op->type == VALUE_STR) {
		size_t i, len = strlen(op->core.u_s), max = len >> 1;
		char temp;
		for (i = 0; i < max; ++i) {
			temp = op->core.u_s[i];
			op->core.u_s[i] = op->core.u_s[len-i-1];
			op->core.u_s[len-i-1] = temp;
		}
	} else if (op->type == VALUE_ARY) {
		size_t i, len = value_length(*op), max = len >> 1;
		value temp;
		for (i = 0; i < max; ++i) {
			temp = op->core.u_a.a[i];
			op->core.u_a.a[i] = op->core.u_a.a[len-i-1];
			op->core.u_a.a[len-i-1] = temp;
		}
	} else if (op->type == VALUE_LST) {
		// I'm not entirely sure if the memory management is correct here. There 
		// may be some leakage.
		
		value res = value_reverse(*op);
		return_if_error(res);
		value_clear(op);
		*op = res;
		
	} else {
		value_error(1, "Type Error: reverse!() is undefined where op is %ts (linear container expected).", *op);
		return value_init_error();
	}

	
	return value_init_nil();
}

value value_rstrip(value op)
{
	value res;
	if (op.type == VALUE_STR) {
		char *end = op.core.u_s + strlen(op.core.u_s) - 1;
		while (end >= op.core.u_s && isspace(*end))
			--end;
		char saved = *(end+1);
		*(end+1) = '\0';
		res.type = VALUE_STR;
		value_malloc(&res, strlen(op.core.u_s));
		return_if_error(res);
		strcpy(res.core.u_s, op.core.u_s);
		*(end+1) = saved;
	} else {
		value_error(1, "Type Error: rstrip() is undefined where op is %ts (string expected).", op);
		res = value_init_error();
	}

	return res;
}

value value_scan(value op1, value op2)
{
	value res = value_init_nil();
	
	if (op1.type == VALUE_STR) {
				
		if (op2.type == VALUE_STR || op2.type == VALUE_RGX) {
			
			res = value_init(VALUE_ARY);
			
			regex_t compiled;
			regmatch_t match;
			
			compile_regex(&compiled, op2.core.u_x, 0);
			
			char *ptr = op1.core.u_s;
			while (*ptr) {
				match = value_match_str(op2, ptr);
				
				if (match.rm_so == -1) {
					++ptr;
				} else if (match.rm_so < -1) {
					value_clear(&res);
					return value_init_error();
				} else {
					char saved = ptr[match.rm_eo];
					ptr[match.rm_eo] = '\0';
					value vstr = value_set_str(ptr + match.rm_so);
					value_append_now2(&res, &vstr);
					ptr[match.rm_eo] = saved;
					ptr += match.rm_eo;
					if (match.rm_so == match.rm_eo)
						++ptr;
				}

			}
			
		} else {
			value_error(1, "Type Error: scan() is undefined where op2 is %ts (string or regular expression expected).", op2);
			res = value_init_error();
		}

		
	} else {
		value_error(1, "Type Error: scan() is undefined where op1 is %ts (string expected).", op1);
		if (op2.type != VALUE_STR && op2.type != VALUE_RGX)
			value_error(1, "Type Error: scan() is undefined where op2 is %ts (string or regular expression expected).", op2);
		res = value_init_error();
	}
	
	return res;
}

value value_split(value op1, value op2)
{
	int error_p = FALSE;
	if (op1.type != VALUE_STR) {
		value_error(1, "Type Error: split() is undefined where op1 is %ts (string expected).", op1);
		error_p = TRUE;
	}
		
	if (op2.type != VALUE_STR) {
		value_error(1, "Type Error: split() is undefined where op2 is %ts (string expected).", op2);
		error_p = TRUE;
	}
	
	if (error_p)
		return value_init_error();
	
	char *str = op2.core.u_s;
	size_t len = strlen(str);
	
	value res = value_init(VALUE_ARY);
	char *start = op1.core.u_s;
	char *ptr = start;
	
	if (len == 0) {
		while (*ptr) {
			value tmp = value_set_str_length(ptr, 1);
			value_append_now2(&res, &tmp);
			++ptr;
		}
		return res;
	}
	
	char saved;
	value temp;
	while (*ptr != '\0') {
		if (strncmp(ptr, str, len) == 0) {
			saved = *ptr;
			*ptr = '\0';
			if (strlen(start) > 0) {
				temp = value_set_str(start);
				value_append_now(&res, temp);
				value_clear(&temp);
			}
			*ptr = saved;
			ptr += len;
			start = ptr;
		} else ++ptr;
	}
	
	temp = value_set_str(start);
	value_append_now(&res, temp);
	value_clear(&temp);
	
	return res;
}

int value_starts_with_p(value op1, value op2)
{
	int error_p = FALSE;
	if (op1.type != VALUE_STR) {
		value_error(1, "Type Error: starts_with() is undefined where op1 is %ts (string expected).", op1);
		error_p = TRUE;
	}
		
	if (op2.type != VALUE_STR) {
		value_error(1, "Type Error: starts_with() is undefined where op2 is %ts (string expected).", op2);
		error_p = TRUE;
	}
	
	if (error_p)
		return VALUE_ERROR;
	
	return strncmp(op1.core.u_s, op2.core.u_s, value_length(op2)) == 0;
}

value value_starts_with_p_std(value op1, value op2)
{
	int error_p = FALSE;
	if (op1.type != VALUE_STR) {
		value_error(1, "Type Error: starts_with() is undefined where op1 is %ts (string expected).", op1);
		error_p = TRUE;
	}
		
	if (op2.type != VALUE_STR) {
		value_error(1, "Type Error: starts_with() is undefined where op2 is %ts (string expected).", op2);
		error_p = TRUE;
	}
	
	if (error_p)
		return value_init_error();
	
	return value_set_bool(strncmp(op1.core.u_s, op2.core.u_s, value_length(op2)) == 0);
}

value value_strip(value op)
{
	if (op.type != VALUE_STR) {
		value_error(1, "Type Error: strip() is undefined where op is %ts (string expected).", op);
		return value_init_error();
	}
	
	value res;
	char *ptr = op.core.u_s;
	while (isspace(*ptr))
		++ptr;
	char *end = ptr + strlen(ptr) - 1;
	while (end >= ptr && isspace(*end))
		--end;
	char saved = *(end+1);
	*(end+1) = '\0';
	res.type = VALUE_STR;
	value_malloc(&res, strlen(ptr));
	return_if_error(res);
	strcpy(res.core.u_s, ptr);
	*(end+1) = saved;
	return res;	
}

value value_strip_now(value *op)
{
	if (op->type != VALUE_STR) {
		value_error(1, "Type Error: strip() is undefined where op is %ts (string expected).", op);
		return value_init_error();
	}
	
	char *ptr = op->core.u_s;
	while (isspace(*ptr))
		++ptr;
	
	char *end = ptr + strlen(ptr) - 1;
	while (end > ptr && isspace(*end))
		--end;
	++end;
	
	memmove(op->core.u_s, ptr, end - ptr);
	*(end - (ptr - op->core.u_s)) = '\0';
	
	return value_init_nil();
}

value value_to_upper(value op)
{
	if (op.type != VALUE_STR) {
		value_error(1, "Type Error: to_upper() is undefined where op is %ts (string expected).", op);
		return value_init_error();
	}
	
	value res = value_set_str(op.core.u_s);
	char *ptr = res.core.u_s - 1;
	while (*(++ptr) = toupper(*ptr))
		;
	
	return res;
}

value value_to_lower(value op)
{
	if (op.type != VALUE_STR) {
		value_error(1, "Type Error: to_upper() is undefined where op is %ts (string expected).", op);
		return value_init_error();
	}
	
	value res = value_set_str(op.core.u_s);
	char *ptr = res.core.u_s - 1;
	while (*(++ptr) = tolower(*ptr))
		;
	
	return res;
}

value value_asc_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "asc()") ? value_init_error() : value_asc(argv[0]);
}

value value_capitalize_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "capitalize()") ? value_init_error() : value_capitalize(argv[0]);
}

value value_chop_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "chop()") ? value_init_error() : value_chop(argv[0]);
}

value value_chop_now_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "chop!()") ? value_init_error() : value_chop_now(&argv[0]);
}

value value_chr_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "chr()") ? value_init_error() : value_chr(argv[0]);
}

value value_contains_p_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "contains?()") ? value_init_error() : value_contains_p_std(argv[0], argv[1]);
}

value value_ends_with_p_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "ends_with?()") ? value_init_error() : value_ends_with_p_std(argv[0], argv[1]);
}

value value_index_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "index()") ? value_init_error() : value_index_std(argv[0], argv[1]);
}

value value_insert_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "insert()") ? value_init_error() : value_insert(argv[0], argv[1], argv[2]);
}

value value_insert_now_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "insert()") ? value_init_error() : value_insert_now(&argv[0], argv[1], argv[2]);
}

value value_alpha_p_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "is_alpha?()") ? value_init_error() : value_alpha_p_std(argv[0]);
}

value value_alnum_p_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "is_alnum?()") ? value_init_error() : value_alnum_p_std(argv[0]);
}

value value_num_p_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "is_num?()") ? value_init_error() : value_num_p_std(argv[0]);
}

value value_length_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "length()") ? value_init_error() : value_length_std(argv[0]);
}

value value_lstrip_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "lstrip()") ? value_init_error() : value_lstrip(argv[0]);
}

value value_range_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "range()") ? value_init_error() : value_range(argv[0], argv[1], argv[2]);
}

value value_replace_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "replace()") ? value_init_error() : value_replace(argv[0], argv[1], argv[2]);
}

value value_replace_now_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "replace!()") ? value_init_error() : value_replace_now(&argv[0], argv[1], argv[2]);
}

value value_reverse_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "reverse()") ? value_init_error() : value_reverse(argv[0]);
}

value value_reverse_now_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "reverse!()") ? value_init_error() : value_reverse_now(&argv[0]);
}

value value_rstrip_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "rstrip()") ? value_init_error() : value_rstrip(argv[0]);
}

value value_scan_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "scan()") ? value_init_error() : value_scan(argv[0], argv[1]);
}

value value_split_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "split()") ? value_init_error() : value_split(argv[0], argv[1]);
}

value value_starts_with_p_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "starts_with?()") ? value_init_error() : value_starts_with_p_std(argv[0], argv[1]);
}

value value_strip_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "strip()") ? value_init_error() : value_strip(argv[0]);
}

value value_strip_now_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "strip!()") ? value_init_error() : value_strip_now(&argv[0]);
}

value value_to_upper_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "to_upper()") ? value_init_error() : value_to_upper(argv[0]);
}

value value_to_lower_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "to_lower()") ? value_init_error() : value_to_lower(argv[0]);
}



/*
 *  value.c
 *  Simfpl
 *
 *  Created by Michael Dickens on 1/23/10.
 *
 */

#include "value.h"


int init_values()
{
	mpfr_set_default_rounding_mode(value_mpfr_round = GMP_RNDN);
	value_mpfr_round_cast = GMP_RNDZ; // How to round when casting from MPFR to an integer.
	mpfr_set_default_prec(value_mpfr_default_prec = 53);
	
	value_int_min = value_set_long(sizeof(size_t) == sizeof(int) ? INT_MIN : LONG_MIN);
	value_zero = value_set_long(0);
	value_one = value_set_long(1);
	value_int_max = value_set_long(sizeof(size_t) == sizeof(int) ? INT_MAX : LONG_MAX);
	value_nil = value_init_nil();
	
	value_symbol_in = value_set_symbol("in");
	value_symbol_dotimes = value_set_symbol("dotimes");
	value_symbol_if = value_set_symbol("if");

	value_nil_function_spec.needs_variables_p = FALSE;
	value_nil_function_spec.keep_arg_p = FALSE;
	value_nil_function_spec.delay_eval_p = FALSE;
	value_nil_function_spec.argc = 0;
	value_nil_function_spec.optional = INT_MAX;
	value_nil_function_spec.rest_p = FALSE;
	value_nil_function_spec.associativity = '\0';
	value_nil_function_spec.precedence = 0;

	generic_error = exception_init(NULL, "GenericError");
	runtime_error = exception_init(&generic_error, "RuntimeError");
	argument_error = exception_init(&runtime_error, "ArgumentError");
	memory_error;
	syntax_error;
	type_error;
	
	return 0;
}

/* 
 * Called in each _arg function to see if there are missing arguments.
 */
int missing_arguments(int argc, value argv[], char *name)
{	
	int i;
	int missing = 0;
	for (i = 0; i < argc; ++i)
		if (argv[i].type == VALUE_MISSING_ARG)
			++missing;
		// If one of the arguments is an error, then there's no sense in trying to 
		// evaluate the function.
		else if (argv[i].type == VALUE_ERROR)
			return TRUE;
	
	if (missing > 0) {
		if (missing == 1)
			value_error(1, "Argument Error: in %c, %d missing argument (%d expected, %d found).", name, missing, argc, argc - missing);
		else
			value_error(1, "Argument Error: in %c, %d missing arguments (%d expected, %d found).", name, missing, argc, argc - missing);
		return TRUE;
	}
	
	return FALSE;
}

const char * type_to_string(int type)
{
	switch (type) {
		case VALUE_ERROR:
			return "Error";
		case VALUE_NIL:
			return "Nil";
		case VALUE_NAN:
			return "NaN";
		case VALUE_INF:
			return "Infinity";
		case VALUE_BOO:
			return "Boolean";
		case VALUE_MPZ:
			return "Integer";
		case VALUE_MPF:
			return "Float";
		case VALUE_STR:
			return "String";
		case VALUE_RGX:
			return "Regex";
		case VALUE_SYM:
			return "Symbol";
		case VALUE_ARY:
			return "Array";
		case VALUE_LST:
			return "List";
		case VALUE_PAR:
			return "Pair";
		case VALUE_HSH:
			return "Hash";
		case VALUE_TRE: 
			return "Tree";
		case VALUE_PTR:
			return "Pointer";
		case VALUE_RNG:
			return "Range";
		case VALUE_BLK:
			return "Block";
		case VALUE_ID:
			return "Id";
		case VALUE_VAR:
			return "Variable";
		case VALUE_STOP:
			return "Stop";
		case VALUE_SPEC:
			return "Spec";
		case VALUE_BIF:
			return "Primitive";
		case VALUE_UDF:
			return "Function";
		case VALUE_UDF_SHELL:
			return "FunctionShell";
		case VALUE_TYP:
			return "Type";
		case VALUE_MISSING_ARG:
			return "MissingArg";
		default:
			return "UnknownType";
	}
}

int value_array_id_index(value vals[], int length, char *val)
{
	int i;
	for (i = 0; i < length; ++i) {
		if (vals[i].type == VALUE_ID && streq(vals[i].core.u_id, val))
			return i;
	}
	
	return -1;
}

int value_array_copy(value target[], value source[], int size)
{
	int i;
	for (i = 0; i < size; ++i)
		target[i] = value_set(source[i]);
	return 0;
}

value value_init_nil()
{
	return value_nil;
}

value value_init_nil_type(int type)
{
	value res;
	
	res.type = VALUE_NIL;
	res.core.u_nil = type;
	return res;	
}

value value_init_error()
{
	value res;
	
	res.type = VALUE_ERROR;
	return res;
}

value value_init(int type)
{
	value res;
	
	res.type = type;
	switch (type) {
		case VALUE_NIL:
		case VALUE_NAN:
		case VALUE_INF:
		case VALUE_MISSING_ARG:
		case VALUE_ERROR:
			break;
		case VALUE_BOO:
			res.core.u_b = FALSE;
			break;
		case VALUE_MPZ:
			mpz_init(res.core.u_mz);
			break;
		case VALUE_MPF:
			mpfr_init(res.core.u_mf);
			break;
		case VALUE_STR:
		case VALUE_RGX:
		case VALUE_SYM:
		case VALUE_ID:
		case VALUE_VAR:
			value_malloc(&res, 1);
			return_if_error(res);
			res.core.u_s[0] = '\0';
			break;
		case VALUE_ARY:
			res.core.u_a.a = NULL;
			res.core.u_a.length = 0;
			break;
		case VALUE_LST:
			value_malloc(&res, 2);
			return_if_error(res);
			res.core.u_l[0].type = VALUE_NIL;
			res.core.u_l[1].type = VALUE_NIL;
			break;
		case VALUE_PAR:
			value_malloc(&res, 1);
			return_if_error(res);
			res.core.u_p->head.type = VALUE_NIL;
			res.core.u_p->tail.type = VALUE_NIL;
			break;
		case VALUE_HSH:
			res = value_hash_init();
			break;
		case VALUE_RNG:
			value_error(1, "Error: Cannot initialize a range.");
			res.type = VALUE_ERROR;
			break;
		case VALUE_BLK:
			res.core.u_blk.a = NULL;
			res.core.u_blk.length = 0;
			res.core.u_blk.s = NULL;
			break;
		case VALUE_PTR:
			res.core.u_ptr = NULL;
			break;
		case VALUE_BIF:
			res.core.u_bif = NULL;
			break;
		case VALUE_UDF:
		case VALUE_UDF_SHELL:
			res.core.u_udf = value_malloc(NULL, sizeof(struct value_function));
			return_if_null(res.core.u_udf);
			res.core.u_udf->name = NULL;
			res.core.u_udf->vars = value_init_nil();
			res.core.u_udf->body = value_init_nil();
			res.core.u_udf->spec = compile_spec("0l15");
			break;
		default:
			value_error(1, "Type Error: init() is undefined for type %d.", type);
			res.type = VALUE_ERROR;
			break;
	}
	return res;
}

int value_clear(value *op)
{
	size_t i, length;
	
	switch (op->type) {
	case VALUE_NIL:
	case VALUE_NAN:
	case VALUE_INF:
	case VALUE_TYP:
	case VALUE_ERROR:
	case VALUE_SPEC:
		// Do nothing.
		break;
	case VALUE_BOO:
		op->core.u_b = FALSE;
		break;
	case VALUE_MPZ:
		mpz_clear(op->core.u_mz);
		break;
	case VALUE_MPF:
		mpfr_clear(op->core.u_mf);
		break;
	case VALUE_STR:
	case VALUE_RGX:
	case VALUE_SYM:
	case VALUE_ID:
	case VALUE_VAR:
		value_free(op->core.u_s);
		break;
	case VALUE_ARY:
		if (op->core.u_a.a) {
			for (i = 0; i < op->core.u_a.length; ++i)
				value_clear(&(op->core.u_a.a[i]));
			value_free(op->core.u_a.a);
		}
		break;
	case VALUE_LST:
		;
		value ptr = *op;
		value ptr2 = ptr;
		while (ptr.type == VALUE_LST) {
			value_clear(&ptr.core.u_l[0]);
			ptr2 = ptr;
			ptr = ptr.core.u_l[1];
			value_free(ptr2.core.u_l);
			ptr2.type = VALUE_NIL;
		}
		
		break;
	case VALUE_PAR:
		if (op->core.u_p) {
			value_clear(&op->core.u_p->head);
			value_clear(&op->core.u_p->tail);
			value_free(op->core.u_p);
		}
		break;
	case VALUE_HSH:
		value_hash_clear(op);
		break;
	case VALUE_PTR:
		value_clear(op->core.u_ptr);
		op->core.u_ptr = NULL;
		break;
	case VALUE_RNG:
		value_clear(&op->core.u_r->min);
		value_clear(&op->core.u_r->max);
		value_free(op->core.u_r);
		break;
	case VALUE_BLK:
		length = value_length(*op);
		for (i = 0; i < length; ++i)
			value_clear(&(op->core.u_blk.a[i]));
		if (op->core.u_blk.a)
			value_free(op->core.u_blk.a);
		if (op->core.u_blk.s)
			value_free(op->core.u_blk.s);
		break;
	case VALUE_STOP:
		if (op->core.u_stop.core) {
			value_clear(op->core.u_stop.core);
			value_free(op->core.u_stop.core);
		}
		break;
	case VALUE_BIF:
		if (op->core.u_bif)
			value_free(op->core.u_bif);
		break;
	case VALUE_UDF:
	case VALUE_UDF_SHELL:
		if (op->core.u_udf->name)
			value_free(op->core.u_udf->name);
		value_clear(&op->core.u_udf->vars);
		value_clear(&op->core.u_udf->body);
		value_free(op->core.u_udf);
		break;
	case VALUE_EXC:
		if (op->core.u_exc.name)
			value_free(op->core.u_exc.name);
		if (op->core.u_exc.description)
			value_free(op->core.u_exc.description);
		if (op->core.u_exc.stack_trace) {
			value_clear(op->core.u_exc.stack_trace);
			value_free(op->core.u_exc.stack_trace);
		}
		op->core.u_exc.parent = NULL;
		op->core.u_exc.name = NULL;
		op->core.u_exc.description = NULL;
		op->core.u_exc.stack_trace = NULL;
		break;
	default:
		value_error(1, "Error: In value_clear(), undefined op type %d.", op->type);
		return VALUE_ERROR;
	}
	
	op->type = VALUE_NIL;	
	return 0;
}

value value_set(value op)
{
	value res;
	
	res.type = op.type;
	size_t i;
	
	value ptr;
	size_t length;
	
	switch (op.type) {
	case VALUE_NIL:
		res.core.u_nil = op.core.u_nil;
		break;
	case VALUE_MISSING_ARG: case VALUE_NAN: case VALUE_INF: case VALUE_ERROR:
		// Do nothing.
		break;
	case VALUE_BOO:
		res.core.u_b = op.core.u_b;
		break;
	case VALUE_MPZ:
		mpz_init_set(res.core.u_mz, op.core.u_mz);
		break;
	case VALUE_MPF:
		mpfr_init_set(res.core.u_mf, op.core.u_mf, value_mpfr_round);
		break;
	case VALUE_STR: case VALUE_RGX: case VALUE_SYM: case VALUE_ID: case VALUE_VAR:
		value_malloc(&res, strlen(op.core.u_s)+1);
		return_if_error(res);
		strcpy(res.core.u_s, op.core.u_s);
		break;
	case VALUE_ARY:
		if (op.core.u_a.a) {
			value_malloc(&res, next_size(op.core.u_a.length));
			return_if_error(res);
			for (i = 0; i < op.core.u_a.length; ++i)
				res.core.u_a.a[i] = value_set(op.core.u_a.a[i]);
			res.core.u_a.length = op.core.u_a.length;
		} else res.core.u_a.a = NULL;
		break;
	case VALUE_LST:
		// This is more complicated than the recursive version, but it's nearly twice 
		// as fast. Speed here is crucial.
		res.type = VALUE_LST;
		value_malloc(&res, 2);
		if (res.type == VALUE_ERROR)
			break;
		ptr = res;
		while (TRUE) {
			ptr.core.u_l[0] = value_set(op.core.u_l[0]);
			if (op.core.u_l[1].type == VALUE_LST) {
				ptr.core.u_l[1].type = VALUE_LST;
				value_malloc(&ptr.core.u_l[1], 2);
				if (ptr.core.u_l[1].type == VALUE_ERROR) {
					ptr.core.u_l[1].type = VALUE_NIL;
					value_clear(&res);
					res = value_init_error();
					break;
				}
				ptr = ptr.core.u_l[1];
				op = op.core.u_l[1];
			} else {
				ptr.core.u_l[1] = value_init_nil();
				break;
			}
		}
		break;

	case VALUE_PAR:
		value_malloc(&res, 1);
		return_if_error(res);
		res.core.u_p->head = value_set(op.core.u_p->head);
		res.core.u_p->tail = value_set(op.core.u_p->tail);
		break;

	case VALUE_HSH:
		// Notice that (op.core.u_h.length) will already be a legal size, so a call to next_size() 
		// is not necessary.
		value_malloc(&res, op.core.u_h.length);
		return_if_error(res);
		for (i = 0; i < op.core.u_h.length; ++i)
			res.core.u_h.a[i] = value_set(op.core.u_h.a[i]);
		res.core.u_h.length = op.core.u_h.length;
		res.core.u_h.size = op.core.u_h.size;
		res.core.u_h.occupied = op.core.u_h.occupied;
		break;
	case VALUE_RNG:
		value_malloc(&res, sizeof(struct value_range));
		return_if_error(res);
		res.core.u_r->inclusive_p = op.core.u_r->inclusive_p;
		res.core.u_r->min = value_set(op.core.u_r->min);
		res.core.u_r->max = value_set(op.core.u_r->max);
		break;
	case VALUE_PTR:
		res.core.u_ptr = op.core.u_ptr;
		break;
	case VALUE_BLK:
		length = res.core.u_blk.length = op.core.u_blk.length;
		value_malloc(&res, next_size(length));
		return_if_error(res);
		for (i = 0; i < length; ++i)
			res.core.u_blk.a[i] = value_set(op.core.u_blk.a[i]);
		if (op.core.u_blk.s == NULL)
			res.core.u_blk.s = NULL;
		else {
			value_malloc(&res, strlen(op.core.u_blk.s) + 1);
			return_if_error(res);
			strcpy(res.core.u_blk.s, op.core.u_blk.s);
		}
		break;
	case VALUE_TYP:
		res.core.u_type = op.core.u_type;
		break;
	case VALUE_STOP:
		res.core.u_stop.type = op.core.u_stop.type;
		if (op.core.u_stop.core) {
			res.core.u_stop.core = value_malloc(NULL, sizeof(value));
			return_if_null(res.core.u_stop.core);
			*res.core.u_stop.core = *op.core.u_stop.core;
		}
		break;
	case VALUE_SPEC:
		res.core.u_spec = op.core.u_spec;
		break;
	case VALUE_BIF:
		res.core.u_bif = value_malloc(NULL, sizeof(struct value_bif));
		return_if_null(res.core.u_bif);
		res.core.u_bif->f = op.core.u_bif->f;
		res.core.u_bif->spec = op.core.u_bif->spec;
		break;
	case VALUE_UDF: case VALUE_UDF_SHELL:
		res.core.u_udf = value_malloc(NULL, sizeof(struct value_function));
		return_if_null(res.core.u_udf);
		res.core.u_udf->name = value_malloc(NULL, strlen(op.core.u_udf->name) + 1);
		return_if_null(res.core.u_udf->name);
		strcpy(res.core.u_udf->name, op.core.u_udf->name);
		res.core.u_udf->vars = value_set(op.core.u_udf->vars);
		return_if_error(res.core.u_udf->vars);
		res.core.u_udf->body = value_set(op.core.u_udf->body);
		return_if_error(res.core.u_udf->body);
		res.core.u_udf->spec = op.core.u_udf->spec;
		break;
	case VALUE_EXC:
		res.core.u_exc.parent = op.core.u_exc.parent;
		if (op.core.u_exc.name) {
			res.core.u_exc.name = value_malloc(NULL, strlen(op.core.u_exc.name) + 1);
			return_if_null(res.core.u_exc.name);
			strcpy(res.core.u_exc.name, op.core.u_exc.name);
		} else res.core.u_exc.name = NULL;
		
		if (op.core.u_exc.description) {
			res.core.u_exc.description = value_malloc(NULL, strlen(op.core.u_exc.description) + 1);
			return_if_null(res.core.u_exc.description);
			strcpy(res.core.u_exc.description, op.core.u_exc.description);
		} else res.core.u_exc.description = NULL;
		
		if (op.core.u_exc.stack_trace) {
			res.core.u_exc.stack_trace = value_malloc(NULL, sizeof(value));
			return_if_null(res.core.u_exc.stack_trace);
			*res.core.u_exc.stack_trace = value_set(*op.core.u_exc.stack_trace);
		} else res.core.u_exc.stack_trace = NULL;
		break;
	default:
		value_error(1, "Error: In value_set(), undefined op type %d.", op.type);
		res.type = VALUE_ERROR;
		break;
	}
	
	return res;

}

value value_set_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "set()") ? value_init_error() : value_set(argv[0]);
}

value value_set_bool(int x)
{
	value res;
	res.type = VALUE_BOO;
	if (x) res.core.u_b = TRUE;
	else res.core.u_b = FALSE;
	return res;
}

value value_set_long(long x)
{
	value res;
	res.type = VALUE_MPZ;
	mpz_init_set_si(res.core.u_mz, x);
	return res;
}

value value_set_ulong(unsigned long x)
{
	value res;
	
	res.type = VALUE_MPZ;
	mpz_init_set_ui(res.core.u_mz, x);
	return res;
}

value value_set_double(double x)
{
	value res;
	
	res.type = VALUE_MPF;
	mpfr_init_set_d(res.core.u_mf, x, value_mpfr_round);
	return res;
}

value value_set_str_smart(char *str, int base)
{
	value res = value_init_error();
	int isnum;
	if (same_type_determiner == SAME_TYPE_VALUE)
		isnum = isnumeric(str);
	else isnum = minus_isnumeric(str);
	size_t length;
	
	switch (isnum) {
		case VALUE_ERROR:
			res = value_init_error();
			break;
		case 1:
			res.type = VALUE_MPZ;
			mpz_init(res.core.u_mz);
			mpz_set_str(res.core.u_mz, str, base);
			break;
		case 2:
			res.type = VALUE_MPF;
			// 4 is the first integer over log2(10) ≈ 3.32.
			// If the given number is bigger than the default 
			// precision, make it big enough to hold the given 
			// number.
			if ((length = strlen(str)) * 4 > value_mpfr_default_prec)
				mpfr_init2(res.core.u_mf, length * 4);
			else mpfr_init(res.core.u_mf);
			mpfr_set_str(res.core.u_mf, str, base, value_mpfr_round);
			break;
		default:
			if (is_string_literal(str)) {
				size_t len = strlen(str);
				str[len] = '\0';
				char holder[len];
				strcpy(holder, str+1);
				holder[len-2] = '\0';
				res.type = VALUE_STR;
				res.core.u_s = convert_to_literal(holder);
			} else if (is_regex_literal(str)) {
				size_t len = strlen(str);
				str[len] = '\0';
				char holder[len];
				strcpy(holder, str+1);
				holder[len-2] = '\0';
				res.type = VALUE_RGX;
				res.core.u_x = convert_regex_to_literal(holder);
			} else if (str[0] == ':') {
				size_t len = strlen(str);
				res.type = VALUE_SYM;
				res.core.u_s = value_malloc(NULL, len);
				return_if_null(res.core.u_s);
				strcpy(res.core.u_s, str+1);
				
			} else if (streq(str, "true"))
				res = value_set_bool(TRUE);
			else if (streq(str, "false"))
				res = value_set_bool(FALSE);
			else if (streq(str, "nil"))
				res = value_init_nil();
			else
				return value_init_error();
	}
		
	return res;
}

value value_set_id(char *id)
{
	value res;
	
	res.type = VALUE_ID;
	res.core.u_id = value_malloc(NULL, strlen(id) + 1);
	return_if_null(res.core.u_id);
	strcpy(res.core.u_id, id);
	return res;
}

value value_copy(value op)
{
	value res;
	
	res.type = op.type;
	if (op.type == VALUE_ARY) {
		res.core.u_a.length = op.core.u_a.length;
		value_malloc(&res, next_size(res.core.u_a.length));
		return_if_error(res);
		size_t i;
		for (i = 0; i < res.core.u_a.length; ++i) {
			res.core.u_a.a[i] = op.core.u_a.a[i];
		}
	} else if (op.type == VALUE_LST) {
		value ptr = res;
		// I'm not sure if this will work. It hasn't been tested.
		while (op.type != VALUE_NIL) {
			value_malloc(&ptr, 2);
			return_if_error(res);
			ptr.core.u_l[0] = op.core.u_l[0];
			ptr.core.u_l[1].type = VALUE_LST;
			ptr = ptr.core.u_l[1];
			op = op.core.u_l[1];
		}
	
	} else if (op.type == VALUE_HSH) {
		size_t inner_len, length = value_hash_length(op);
		
		res = value_hash_init_capacity(next_size(length));
		size_t i, j;
		for (i = 0; i < length; ++i) {
			if (op.core.u_h.a[i].type == VALUE_NIL)
				continue;
			inner_len = value_length(op.core.u_h.a[i]);
			for (j = 0; j < inner_len; ++j)
				value_hash_put_refs(&res, &op.core.u_h.a[i].core.u_a.a[j].core.u_a.a[0], &op.core.u_h.a[i].core.u_a.a[j].core.u_a.a[1]);
		}
		
	} else {
		res = value_set(op);
	}
	
	return res;
}

void * value_malloc(value *op, size_t size)
{
	if (op == NULL) {
		
	} else if (op->type == VALUE_STR || op->type == VALUE_RGX || op->type == VALUE_SYM || op->type == VALUE_ID || op->type == VALUE_VAR) {
		op->core.u_s = NULL;
	} else if (op->type == VALUE_ARY) {
		op->core.u_a.a = NULL;
	} else if (op->type == VALUE_LST) {
		op->core.u_l = NULL;
	} else if (op->type == VALUE_PAR) {
		op->core.u_p = NULL;
	} else if (op->type == VALUE_HSH) {
		op->core.u_h.a = NULL;
	} else if (op->type == VALUE_RNG) {
		op->core.u_r = NULL;
	} else if (op->type == VALUE_BLK) {
		op->core.u_blk.a = NULL;
	} else {
		value_error(1, "Type Error: malloc() is undefined where op is %ts (linear container expected).", *op);
		value_clear(op);
		*op = value_init_error();
		return NULL;
	}
	
	return value_realloc(op, size);
}

void * value_realloc(value *op, size_t size)
{
	void *res;
	if (op == NULL) {
		res = malloc(size);
		if (res == NULL) {
			value_error(1, "Memory Error: Allocation failed.");
		}
				
	} else if (op->type == VALUE_STR || op->type == VALUE_RGX || op->type == VALUE_SYM || op->type == VALUE_ID || op->type == VALUE_VAR) {
		res = op->core.u_s = realloc(op->core.u_s, sizeof(char) * size);
		if (op->core.u_s == NULL) {
			value_error(1, "Memory Error: String allocation failed.");
			*op = value_init_error();
		}
	} else if (op->type == VALUE_ARY) {
		res = op->core.u_a.a = realloc(op->core.u_a.a, sizeof(value) * size);
		if (op->core.u_a.a == NULL) {
			value_error(1, "Memory Error: Array allocation failed.");
			*op = value_init_error();
		}
	} else if (op->type == VALUE_LST) {
		res = op->core.u_l = realloc(op->core.u_l, sizeof(value) * size);
		if (op->core.u_l == NULL) {
			value_error(1, "Memory Error: List allocation failed.");
			*op = value_init_error();
		}
	} else if (op->type == VALUE_PAR) {
		res = op->core.u_p = realloc(op->core.u_p, sizeof(struct value_pair) * size);
		if (op->core.u_l == NULL) {
			value_error(1, "Memory Error: Pair allocation failed.");
			*op = value_init_error();
		}
	} else if (op->type == VALUE_HSH) {
		res = op->core.u_h.a = realloc(op->core.u_h.a, sizeof(value) * size);
		if (op->core.u_h.a == NULL) {
			value_error(1, "Memory Error: Hash allocation failed.");
			*op = value_init_error();
		}
	} else if (op->type == VALUE_RNG) {
		res = op->core.u_r = realloc(op->core.u_r, sizeof(struct value_range) * size);
		if (op->core.u_r == NULL) {
			value_error(1, "Memory Error: Range allocation failed.");
			*op = value_init_error();
		}
	} else if (op->type == VALUE_BLK) {
		res = op->core.u_blk.a = realloc(op->core.u_blk.a, sizeof(value) * size);
		if (op->core.u_blk.a == NULL) {
			value_error(1, "Memory Error: Block allocation failed.");
			*op = value_init_error();
		}
	} else {
		value_error(1, "Type Error: malloc() is undefined where op is %ts (linear container expected).", *op);
		value_clear(op);
		*op = value_init_error();
		return res;
	}
	
	if (res == NULL) {
		int x = 0;
		x = 10 / x;
		return &x;
	}
	return res;
}

// This is defined using a macro.
//int value_free(void *ptr)
//{
//	free(ptr);
//	return 0;
//}

value value_import(value op)
{
	if (op.type != VALUE_STR) {
		value_error(1, "Type Error: import is undefined where op is %ts (string expected).", op);
		return value_init_error();
	}
	
	
	FILE *fp = fopen(op.core.u_s, "r");
	if (fp == NULL) {
		value_error(1, "IO Error: Cannot access file %s.", op);
		return value_init_error();
	}
	
	int old_linenum = linenum;
	linenum = 0;
	FILE *old_stream = input_stream;
	input_stream = fp;
	
	run_interpreter();
		
	fclose(fp);
	input_stream = old_stream;
	linenum = old_linenum;
	
	is_eof = FALSE;
	return value_init_nil();
}

value value_import_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "import") ? value_init_error() : value_import(argv[0]);
}

value value_array_arg(int argc, value argv[])
{
	return value_set_ary(argv, argc);
}

value value_list_arg(int argc, value argv[])
{
	int i;
	value res = value_init_nil();
	for (i = argc - 1; 0 <= i; --i)
		if (value_cons_now(argv[i], &res).type == VALUE_ERROR)
			return value_init_error();
	
	return res;
}

value value_hash_arg(int argc, value argv[])
{
	// If only one argument is given and it's an array, construct a hash using 
	// that array.
	if (argc == 1 && argv[0].type == VALUE_ARY) {
		return value_hash_arg(argv[0].core.u_a.length, argv[0].core.u_a.a);
	}
	
	size_t i;
	value res = value_hash_init_capacity(argc); // The capacity should be argc / 2 * 2.
	for (i = 0; i < argc - 1; i += 2)
		// If there is an odd number of arguments, the last element will not be added 
		// to the hash.
		if (i + 1 < argc)
			value_hash_put(&res, argv[i], argv[i+1]);
	
	return res;
}

// This is ugly. It should be refactored.
value value_cast(value op, int type)
{
	value res = value_init_error();
	int error_p = FALSE;
	
	switch (type) {
		case VALUE_NIL:
			value_clear(&res);
			res.type = VALUE_NIL;
			break;
			
		case VALUE_BOO:
			res.type = VALUE_BOO;
			res.core.u_b = value_true_p(op);
			break;
		
		case VALUE_MPZ:
			if (op.type == VALUE_MPZ)
				res = value_set(op);
			else if (op.type == VALUE_MPF) {
				mpz_init(res.core.u_mz);
				mpfr_get_z(res.core.u_mz, op.core.u_mf, value_mpfr_round_cast);
			} else if (op.type == VALUE_STR)
				mpz_init_set_str(res.core.u_mz, op.core.u_s, 0);
			else error_p = TRUE;
			
			res.type = VALUE_MPZ;
			break;
			
		case VALUE_MPF:			
			if (op.type == VALUE_MPF)
				res = value_set(op);
			else if (op.type == VALUE_MPZ) {
				mpfr_init_set_z(res.core.u_mf, op.core.u_mz, value_mpfr_round);
			} else if (op.type == VALUE_STR)
				mpfr_init_set_str(res.core.u_mf, op.core.u_s, 0, value_mpfr_round);
			else error_p = TRUE;
			res.type = VALUE_MPF;
			break;
			
		case VALUE_STR:
			if (op.type == VALUE_STR)
				res = value_set(op);
			else if (op.type == VALUE_RGX || op.type == VALUE_SYM || op.type == VALUE_ID || op.type == VALUE_VAR) {
				res = value_set(op);
				res.type = VALUE_STR;
			} else {
				res.type = VALUE_STR;
				size_t buf_len = BUFSIZE;
				while (TRUE) {
					char buffer[buf_len];
					int error_p = value_put(buffer, buf_len, op, NULL);
					if (error_p == 0) {
						res.core.u_s = value_malloc(NULL, strlen(buffer) + 1);
						return_if_null(res.core.u_s);
						strcpy(res.core.u_s, buffer);
						break;
					}
					
					buf_len <<= 4;
				}
			}
			break;
		
		case VALUE_RGX:
			if (op.type == VALUE_STR) {
				res = value_set(op);
				res.type = VALUE_RGX;
			} else error_p = TRUE;
			break;

		case VALUE_ARY:
			if (op.type == VALUE_ARY)
				res = value_set(op);
			else if (op.type == VALUE_STR) {
				size_t length = strlen(op.core.u_s);
				char str[2];
				value array[length];
				size_t i;
				str[1] = '\0';
				for (i = 0; i < length; ++i) {
					str[0] = op.core.u_s[i];
					array[i] = value_set_str(str);
				}
				
				res = value_set_ary(array, length);
				for (i = 0; i < length; ++i)
					value_clear(&array[i]);
				
			} else if (op.type == VALUE_LST) {
				size_t i, length = value_length(op);
				value array[length];
				value ptr = op;
				for (i = 0; i < length; ++i) {
					array[i] = ptr.core.u_l[0];
					ptr = ptr.core.u_l[1];
				}
				
				res = value_set_ary(array, length);
				
			} else if (op.type == VALUE_PAR) {
				size_t i, length = value_length(op);
				value array[length];
				value ptr = op;
				for (i = 0; i < length; ++i) {
					array[i] = ptr.core.u_p->head;
					ptr = ptr.core.u_p->tail;
				}
				
				res = value_set_ary(array, length);
				
			} else if (op.type == VALUE_HSH) {
				size_t size = op.core.u_h.size;
				// size is too large.
				value bucket, array[size];
				size_t i, j, k;
				for (i = 0, j = 0; i < op.core.u_h.length; ++i) {
					bucket = op.core.u_h.a[i];
					if (bucket.type != VALUE_ARY) continue;
					for (k = 0; k < bucket.core.u_a.length; ++k) {
						if (bucket.core.u_a.a[k].type != VALUE_ARY || bucket.core.u_a.a[k].core.u_a.length != 2)
							continue;
						// Put this pair into the new array.
						array[j++] = bucket.core.u_a.a[k];
					}
				}
				
				res = value_set_ary(array, size);
				
			} else if (op.type == VALUE_RNG) {
				value tmp = value_sub(op.core.u_r->max, op.core.u_r->min);
				value diff = value_abs(tmp);
				value_clear(&tmp);
				size_t length = (size_t) value_get_long(diff);
				if (op.core.u_r->inclusive_p)
					++length;
				value array[length];
				if (value_le(op.core.u_r->min, op.core.u_r->max)) {
					// Ascending values.
					value inc = value_set(op.core.u_r->min); size_t i = 0;
					while (TRUE) {
						array[i++] = inc;
						if (i >= length)
							break;
						inc = value_inc(inc);
					}
					
					res = value_set_ary_ref(array, length);
				} else {
					// Descending values.
					value dec = value_set(op.core.u_r->min); size_t i = 0;
					while (TRUE) {
						array[i++] = dec;
						if (i >= length)
							break;
						dec = value_dec(dec);
					}
					
					res = value_set_ary_ref(array, length);
				}
			
			} else if (op.type == VALUE_BLK) {
				res.type = VALUE_ARY;
				res.core.u_a.length = op.core.u_blk.length;
				value_malloc(&res, next_size(res.core.u_a.length));
				return_if_error(res);
				size_t i;
				for (i = 0; i < res.core.u_a.length; ++i) {
					res.core.u_a.a[i] = value_set(op.core.u_blk.a[i]);
				}

			} else {
				res = value_set_ary(&op, 1);
			}
			
			break;
		
		case VALUE_LST:
			if (op.type == VALUE_LST)
				res = value_set(op);
			else if (op.type == VALUE_ARY) {
				size_t length = value_length(op);
				res = value_init(VALUE_LST);
				if (length == 0)
					break;
				value ptr = res;
				size_t i;
				for (i = 0; i < length-1; ++i) {
					ptr.core.u_l[0] = value_set(op.core.u_a.a[i]);
					ptr = ptr.core.u_l[1] = value_init(VALUE_LST);
				}
				
				ptr.core.u_l[0] = value_set(op.core.u_a.a[length-1]);
				ptr.core.u_l[1] = value_init_nil();
			} else if (op.type == VALUE_RNG) {
				res = value_init_nil();
				value min = value_set(op.core.u_r->min);
				if (value_le(op.core.u_r->min, op.core.u_r->max)) {
					// Ascending values.
					value dec = value_set(op.core.u_r->max);
					if (op.core.u_r->inclusive_p == FALSE)
						value_dec_now(&dec);
					while (value_ge(dec, min)) {
						value_cons_now2(&dec, &res);
						dec = value_dec(dec);
					}
				} else {
					// Descending values.
					value_inc_now(&min);
					value inc = value_set(op.core.u_r->max);
					if (op.core.u_r->inclusive_p == FALSE)
						value_inc_now(&inc);
					while (value_lt(inc, min)) {
						value_cons_now2(&inc, &res);
						inc = value_inc(inc);
					}
				}
				value_clear(&min);
				
			} else if (op.type == VALUE_BLK) {
				size_t length = value_length(op);
				res = value_init(VALUE_LST);
				if (length == 0)
					break;
				value ptr = res;
				size_t i;
				for (i = 0; i < length-1; ++i) {
					ptr.core.u_l[0] = value_set(op.core.u_blk.a[i]);
					ptr = ptr.core.u_l[1] = value_init(VALUE_LST);
				}
				
				ptr.core.u_l[0] = value_set(op.core.u_blk.a[length-1]);
				ptr.core.u_l[1] = value_init_nil();
			} else {
				res = value_init(VALUE_LST);
				res.core.u_l[0] = value_set(op);
				res.core.u_l[1] = value_init_nil();
			}
			break;
		
		case VALUE_HSH:
			if (op.type == VALUE_HSH)
				res = value_set(op);
			else if (op.type == VALUE_ARY) {
				size_t length = value_length(op);
				res = value_hash_init_capacity(length * 2);
				size_t i;
				for (i = 0; i < length; ++i)
					value_hash_put(&res, op.core.u_a.a[i], value_init_nil());
			} else if (op.type == VALUE_LST) {
				res = value_hash_init_capacity(value_length(op) * 2);
				value ptr = op;
				while (!value_empty_p(ptr)) {
					value_hash_put(&res, ptr.core.u_l[0], value_init_nil());
					ptr = ptr.core.u_l[1];
				}
			} else {
				res = value_hash_init();
				value_hash_put(&res, op, value_init_nil());
			}

			break;
			
		default:
			error_p = TRUE;
			break;
	}
	
	if (error_p) {
		value_error(1, "Argument Error: Unsupported cast from %ts to %ts.", op, type);
		value_clear(&res);
		return value_init_error();
	} else return res;
}

value value_to_a_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "to_a()") ? value_init_error() : value_cast(argv[0], VALUE_ARY);
}

value value_to_f_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "to_f()") ? value_init_error() : value_cast(argv[0], VALUE_MPF);
}

value value_to_h_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "to_h()") ? value_init_error() : value_cast(argv[0], VALUE_HSH);
}

value value_to_i_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "to_i()") ? value_init_error() : value_cast(argv[0], VALUE_MPZ);
}

value value_to_l_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "to_l()") ? value_init_error() : value_cast(argv[0], VALUE_LST);
}

value value_to_r_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "to_r()") ? value_init_error() : value_cast(argv[0], VALUE_RGX);
}

value value_to_s_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "to_s()") ? value_init_error() : value_cast(argv[0], VALUE_STR);
}

value value_to_s_base_arg(int argc, value argv[])
{
	if (missing_arguments(argc, argv, "to_s_base()")) {
		return value_init_error();
	} else {
		char *res = value_to_string_base(argv[0], argv[1]);
		if (res)
			return value_set_str(res);
		return value_init_error();
	}
}

value value_type(value op)
{
	value res;
	
	res.type = VALUE_TYP;
	res.core.u_type = op.type;
	return res;
}

value value_type_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "type()") ? value_init_error() : value_type(argv[0]);
}


int value_true_p(value op)
{
	switch (op.type) {
		case VALUE_NIL:
		case VALUE_ERROR:
			return FALSE;
		case VALUE_BOO:
			return op.core.u_b;
		case VALUE_MPZ:
		case VALUE_MPF:
			return value_ne(op, value_zero);
		case VALUE_STR:
		case VALUE_ARY:
		case VALUE_LST:
		case VALUE_HSH:
		case VALUE_TRE:
		case VALUE_RNG:
			return !value_empty_p(op);
		default:
			return TRUE;
	}
}

value value_true_p_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "true?()") ? value_init_error() : value_set_bool(value_true_p(argv[0]));
}

value value_assign(value *variables, value op1, value op2)
{
	if (op1.type == VALUE_VAR) {
		if (op2.type != VALUE_ERROR) {
			if (op1.core.u_var[0] == '$')
				value_hash_put(&global_variables, op1, op2);
			else value_hash_put(variables, op1, op2);
			return value_set(op2);
		} else
			return value_init_error();
	} else {
		value_error(1, "Argument Error: assignment is undefined for %ts (variable expected).", op1);
		return value_init_error();
	}
}

value value_assign_arg(int argc, value argv[])
{
	value *tmp = value_deref(argv[0]);
	return missing_arguments(argc-1, argv+1, "assignment") ? value_init_error() : value_assign(tmp, argv[1], argv[2]);
}

value value_assign_add_arg(int argc, value argv[])
{
	if (missing_arguments(argc-1, argv+1, "+="))
		return value_init_error();
	if (argv[1].type != VALUE_VAR) {
		value_error(1, "Type Error: += is undefined where op1 is %ts (variable expected).", argv[1]);
		return value_init_error();
	}
	
	value *variables = value_deref(argv[0]);
	if (value_hash_exists(*variables, argv[1])) {
		value *op1 = value_hash_get_ref(*variables, argv[1]);
		value res = value_add(*op1, argv[2]);
		return_if_error(res);
		value_hash_put(variables, argv[1], res);
		return res;
	} else if (value_hash_exists(global_variables, argv[1])) {
		value *op1 = value_hash_get_ref(global_variables, argv[1]);
		value res = value_add(*op1, argv[2]);
		return_if_error(res);
		value_hash_put(&global_variables, argv[1], res);
		return res;
	} else {
		value_error(1, "Error: In +=, unrecognized variable %s.", argv[1]);
		return value_init_error();
	}

}

value value_assign_sub_arg(int argc, value argv[])
{
	if (missing_arguments(argc-1, argv+1, "-="))
		return value_init_error();
	if (argv[1].type != VALUE_VAR) {
		value_error(1, "Type Error: -= is undefined where op1 is %ts (variable expected).", argv[1]);
		return value_init_error();
	}
	
	value *variables = value_deref(argv[0]);
	if (value_hash_exists(*variables, argv[1])) {
		value *op1 = value_hash_get_ref(*variables, argv[1]);
		value res = value_sub(*op1, argv[2]);
		return_if_error(res);
		value_hash_put(variables, argv[1], res);
		return res;
	} else if (value_hash_exists(global_variables, argv[1])) {
		value *op1 = value_hash_get_ref(global_variables, argv[1]);
		value res = value_sub(*op1, argv[2]);
		return_if_error(res);
		value_hash_put(&global_variables, argv[1], res);
		return res;
	} else {
		value_error(1, "Error: In -=, unrecognized variable %s.", argv[1]);
		return value_init_error();
	}
}

value value_assign_mul_arg(int argc, value argv[])
{
	if (missing_arguments(argc-1, argv+1, "*="))
		return value_init_error();
	if (argv[1].type != VALUE_VAR) {
		value_error(1, "Type Error: *= is undefined where op1 is %ts (variable expected).", argv[1]);
		return value_init_error();
	}
	
	value *variables = value_deref(argv[0]);
	if (value_hash_exists(*variables, argv[1])) {
		value *op1 = value_hash_get_ref(*variables, argv[1]);
		value res = value_mul(*op1, argv[2]);
		return_if_error(res);
		value_hash_put(variables, argv[1], res);
		return res;
	} else if (value_hash_exists(global_variables, argv[1])) {
		value *op1 = value_hash_get_ref(global_variables, argv[1]);
		value res = value_mul(*op1, argv[2]);
		return_if_error(res);
		value_hash_put(&global_variables, argv[1], res);
		return res;
	} else {
		value_error(1, "Error: In *=, unrecognized variable %s.", argv[1]);
		return value_init_error();
	}
}

value value_assign_div_arg(int argc, value argv[])
{
	if (missing_arguments(argc-1, argv+1, "/="))
		return value_init_error();
	if (argv[1].type != VALUE_VAR) {
		value_error(1, "Type Error: /= is undefined where op1 is %ts (variable expected).", argv[1]);
		return value_init_error();
	}
	
	value *variables = value_deref(argv[0]);
	if (value_hash_exists(*variables, argv[1])) {
		value *op1 = value_hash_get_ref(*variables, argv[1]);
		value res = value_div(*op1, argv[2]);
		return_if_error(res);
		value_hash_put(variables, argv[1], res);
		return res;
	} else if (value_hash_exists(global_variables, argv[1])) {
		value *op1 = value_hash_get_ref(global_variables, argv[1]);
		value res = value_div(*op1, argv[2]);
		return_if_error(res);
		value_hash_put(&global_variables, argv[1], res);
		return res;
	} else {
		value_error(1, "Error: In /=, unrecognized variable %s.", argv[1]);
		return value_init_error();
	}
}

value value_assign_mod_arg(int argc, value argv[])
{
	if (missing_arguments(argc-1, argv+1, "%="))
		return value_init_error();
	if (argv[1].type != VALUE_VAR) {
		value_error(1, "Type Error: %= is undefined where op1 is %ts (variable expected).", argv[1]);
		return value_init_error();
	}
	
	value *variables = value_deref(argv[0]);
	if (value_hash_exists(*variables, argv[1])) {
		value *op1 = value_hash_get_ref(*variables, argv[1]);
		value res = value_mod(*op1, argv[2]);
		return_if_error(res);
		value_hash_put(variables, argv[1], res);
		return res;
	} else if (value_hash_exists(global_variables, argv[1])) {
		value *op1 = value_hash_get_ref(global_variables, argv[1]);
		value res = value_mod(*op1, argv[2]);
		return_if_error(res);
		value_hash_put(&global_variables, argv[1], res);
		return res;
	} else {
		value_error(1, "Error: In %=, unrecognized variable %s.", argv[1]);
		return value_init_error();
	}

}

value value_assign_and_arg(int argc, value argv[])
{
	if (missing_arguments(argc-1, argv+1, "&="))
		return value_init_error();
	if (argv[1].type != VALUE_VAR) {
		value_error(1, "Type Error: &= is undefined where op1 is %ts (variable expected).", argv[1]);
		return value_init_error();
	}
	
	value *variables = value_deref(argv[0]);
	if (value_hash_exists(*variables, argv[1])) {
		value *op1 = value_hash_get_ref(*variables, argv[1]);
		value res = value_and(*op1, argv[2]);
		return_if_error(res);
		value_hash_put(variables, argv[1], res);
		return res;
	} else if (value_hash_exists(global_variables, argv[1])) {
		value *op1 = value_hash_get_ref(global_variables, argv[1]);
		value res = value_and(*op1, argv[2]);
		return_if_error(res);
		value_hash_put(&global_variables, argv[1], res);
		return res;
	} else {
		value_error(1, "Error: In &=, unrecognized variable %s.", argv[1]);
		return value_init_error();
	}
}

value value_assign_xor_arg(int argc, value argv[])
{
	if (missing_arguments(argc-1, argv+1, "^="))
		return value_init_error();
	if (argv[1].type != VALUE_VAR) {
		value_error(1, "Type Error: ^= is undefined where op1 is %ts (variable expected).", argv[1]);
		return value_init_error();
	}
	
	value *variables = value_deref(argv[0]);
	if (value_hash_exists(*variables, argv[1])) {
		value *op1 = value_hash_get_ref(*variables, argv[1]);
		value res = value_xor(*op1, argv[2]);
		return_if_error(res);
		value_hash_put(variables, argv[1], res);
		return res;
	} else if (value_hash_exists(global_variables, argv[1])) {
		value *op1 = value_hash_get_ref(global_variables, argv[1]);
		value res = value_xor(*op1, argv[2]);
		return_if_error(res);
		value_hash_put(&global_variables, argv[1], res);
		return res;
	} else {
		value_error(1, "Error: In ^=, unrecognized variable %s.", argv[1]);
		return value_init_error();
	}
}

value value_assign_or_arg(int argc, value argv[])
{
	if (missing_arguments(argc-1, argv+1, "|="))
		return value_init_error();
	if (argv[1].type != VALUE_VAR) {
		value_error(1, "Type Error: |= is undefined where op1 is %ts (variable expected).", argv[1]);
		return value_init_error();
	}
	
	value *variables = value_deref(argv[0]);
	if (value_hash_exists(*variables, argv[1])) {
		value *op1 = value_hash_get_ref(*variables, argv[1]);
		value res = value_or(*op1, argv[2]);
		return_if_error(res);
		value_hash_put(variables, argv[1], res);
		return res;
	} else if (value_hash_exists(global_variables, argv[1])) {
		value *op1 = value_hash_get_ref(global_variables, argv[1]);
		value res = value_or(*op1, argv[2]);
		return_if_error(res);
		value_hash_put(&global_variables, argv[1], res);
		return res;
	} else {
		value_error(1, "Error: In |=, unrecognized variable %s.", argv[1]);
		return value_init_error();
	}
}

value value_assign_shl_arg(int argc, value argv[])
{
	if (missing_arguments(argc-1, argv+1, "<<="))
		return value_init_error();
	if (argv[1].type != VALUE_VAR) {
		value_error(1, "Type Error: <<= is undefined where op1 is %ts (variable expected).", argv[1]);
		return value_init_error();
	}
	
	value *variables = value_deref(argv[0]);
	if (value_hash_exists(*variables, argv[1])) {
		value *op1 = value_hash_get_ref(*variables, argv[1]);
		value res = value_shl_std(*op1, argv[2]);
		return_if_error(res);
		value_hash_put(variables, argv[1], res);
		return res;
	} else if (value_hash_exists(global_variables, argv[1])) {
		value *op1 = value_hash_get_ref(global_variables, argv[1]);
		value res = value_shl_std(*op1, argv[2]);
		return_if_error(res);
		value_hash_put(&global_variables, argv[1], res);
		return res;
	} else {
		value_error(1, "Error: In <<=, unrecognized variable %s.", argv[1]);
		return value_init_error();
	}
}

value value_assign_shr_arg(int argc, value argv[])
{
	if (missing_arguments(argc-1, argv+1, ">>="))
		return value_init_error();
	if (argv[1].type != VALUE_VAR) {
		value_error(1, "Type Error: >>= is undefined where op1 is %ts (variable expected).", argv[1]);
		return value_init_error();
	}
	
	value *variables = value_deref(argv[0]);
	if (value_hash_exists(*variables, argv[1])) {
		value *op1 = value_hash_get_ref(*variables, argv[1]);
		value res = value_shr_std(*op1, argv[2]);
		return_if_error(res);
		value_hash_put(variables, argv[1], res);
		return res;
	} else if (value_hash_exists(global_variables, argv[1])) {
		value *op1 = value_hash_get_ref(global_variables, argv[1]);
		value res = value_shr_std(*op1, argv[2]);
		return_if_error(res);
		value_hash_put(&global_variables, argv[1], res);
		return res;
	} else {
		value_error(1, "Error: In >>=, unrecognized variable %s.", argv[1]);
		return value_init_error();
	}
}



value value_make_pair(value op1, value op2)
{
	value res;
	res.type = VALUE_PAR;
	value_malloc(&res, 1);
	return_if_error(res);
	
	res.core.u_p->head = value_set(op1);
	res.core.u_p->tail = value_set(op2);
	return res;
}

value value_make_pair_refs(value *op1, value *op2)
{
	value res;
	res.type = VALUE_PAR;
	value_malloc(&res, 1);
	return_if_error(res);
	
	res.core.u_p->head = *op1;
	res.core.u_p->tail = *op2;
	return res;
}

value value_make_pair_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "make_pair") ? value_init_error() : value_make_pair(argv[0], argv[1]);
}

value value_refer(value *op)
{
	value res;
	res.type = VALUE_PTR;
	res.core.u_ptr = op;
	return res;
}

value * value_deref(value op)
{
	if (op.type == VALUE_PTR) {
		if (op.core.u_ptr == NULL) {
			value_error(1, "Error: Cannot dereference a null pointer.");
			return NULL;
		}
		return op.core.u_ptr;
	} else {
		value_error(1, "Argument Error: Cannot dereference %ts (pointer expected).", op);
		return NULL;
	}
}

value value_refer_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "refer()") ? value_init_error() : value_refer(&argv[0]);	
}

value value_gets()
{
	char str[BUFSIZE];
	char *ptr = fgets(str, BUFSIZE, stdin);
	if (ptr == NULL)
		return value_init_nil();
	value res = value_set_str(str);
	return res;
}

value value_gets_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "gets()") ? value_init_error() : value_gets();
}

value value_set_default_prec(value prec)
{
	if (prec.type == VALUE_MPZ) {
		mpfr_set_default_prec(value_get_ulong(prec));
		return value_init_nil();
	} else {
		value_error(1, "Type Error: set_default_prec() is undefined where prec is %ts (integer expected).", prec);
		return value_init_error();
	}
}

value value_set_default_prec_arg(int argc, value argv[])
{
	return missing_arguments(argc, argv, "set_default_prec()") ? value_init_error() : value_set_default_prec(argv[0]);
}




/* 
 * IO, setter and getter functions.
 */

double value_get_double(value op)
{
	if (op.type == VALUE_MPZ)
		return mpz_get_d(op.core.u_mz);
	else if (op.type == VALUE_MPF)
		return mpfr_get_d(op.core.u_mf, value_mpfr_round);
	else {
		value_error(1, "Argument Error: Cannot get a double from %ts (number expected).", op);
		return 0;
	}
}

long value_get_long(value op)
{
	if (op.type == VALUE_MPZ)
		return mpz_get_si(op.core.u_mz);
	else if (op.type == VALUE_MPF)
		return mpfr_get_si(op.core.u_mf, value_mpfr_round);
	else {
		value_error(1, "Argument Error: Cannot get a long from %ts (number expected).", op);
		return 0;
	}
}

char * value_get_string(value op)
{
	if (op.type == VALUE_STR || op.type == VALUE_ID || op.type == VALUE_VAR) {
		char *str = value_malloc(NULL, value_length(op));
		if (str == NULL) return NULL;
		strcpy(str, op.core.u_s);
		return str;
	}
	
	value_error(1, "Argument Error: Cannot get a string from %ts (string expected).", op);
	return NULL;
}

unsigned long value_get_ulong(value op)
{
	switch (op.type) {
		case VALUE_MPZ:
			return mpz_get_ui(op.core.u_mz);
		case VALUE_MPF:
			return mpfr_get_ui(op.core.u_mf, value_mpfr_round);
		default:
			value_error(1, "Argument Error: Cannot get an unsigned long from non-number %ts.", op);
			return 0;
	}
}

/* 
 * Only integers and floats have been tested where buffer is too small to hold 
 * the string.
 * 
 * Return Codes
 * 0: Success.
 * -1: (buffer) not long enough to hold (op).
 * -2: Undefined specifier (format).
 * -3: No memory available for malloc().
 * -4: mpfr_get_str() returned NULL.
 */
int value_put(char buffer[], size_t length, value op, char *format)
{
	if (length < 1) return VALUE_ERROR;
	buffer[0] = '\0';
	
	char *fptr = format;
	int op_base = 10;
	char specifier = 's';
	size_t width = length-1;
	size_t precision = 10;
	int is_precision_default = TRUE;
	int is_width_default = TRUE;
		
	// GOTO might strike fear into the hearts of men, but it's still better than putting 
	// a big if statement over a bunch of stuff, which would be ugly and unclear.
	if (format == NULL)
		goto done_with_format;
	
	if (isdigit(*fptr)) {
		is_width_default = FALSE;
		width = *fptr - '0';
		while (isdigit(*(++fptr)))
			width = 10*width + *fptr - '0';
	}
	
	if (*fptr == '.') {
		is_precision_default = FALSE;
		precision = 0;
		while (isdigit(*(++fptr)))
			precision = 10*precision + *fptr - '0';
	}
	
	char print_type = 0;
	if (*fptr == 'r' || *fptr == 't') {
		print_type = *fptr;
		if (is_width_default)
			width = 72;
		++fptr;
	}

	switch (*fptr) {
	case 'b': 
	case 'e': 
	case 'o': 
	case 's': 
	case 'v': 
	case 'x': 
		specifier = *fptr;
		break;
	default:
		;
		char buf[2];
		buf[0] = *fptr;
		buf[1] = '\0';
		value_error(1, "Error: In format string, undefined format specifier %c.", buf);
		return -2;
	}
		
	if (specifier == 'b')
		op_base = 2;
	else if (specifier == 'o')
		op_base = 8;
	else if (specifier == 'x')
		op_base = 16;
	
	// Only print the type of the outermost value. This prevents recursive type prints.
	if (print_type == 't')
		*(--fptr) = 's';
	else if (print_type)
		--fptr;

done_with_format: 
	
	
	if (op.type == VALUE_NIL) {
		if (specifier == 's') {
			if (length < 4) return VALUE_ERROR;
			sprintf(buffer, "nil");
		}
	} else if (op.type == VALUE_BOO) {
		if (op.core.u_b)
			if (length < 5) return VALUE_ERROR;
			else sprintf(buffer, "true");
		else
			if (length < 6) return VALUE_ERROR;
			else sprintf(buffer, "false");
		
	} else if (op.type == VALUE_MPZ) {
		if (length < mpz_sizeinbase(op.core.u_mz, op_base)) return VALUE_ERROR;
		mpz_get_str(buffer, op_base, op.core.u_mz);
		
	} else if (op.type == VALUE_MPF) {		
		if (length < 8) return VALUE_ERROR;
		
		size_t int_size = 0;
		
		if (specifier != 'e') {
			// Convert the number to MPZ so we'll know how many digits the integer part 
			// is, and can make sure the string is big enough.
			mpz_t int_op;
			mpz_init(int_op);
			mpfr_get_z(int_op, op.core.u_mf, value_mpfr_round_cast);
			size_t int_size = mpz_sizeinbase(int_op, op_base);
			mpz_clear(int_op);
			if (length < int_size) return VALUE_ERROR;
		}
		
		// n is the number of characters to be output.
		// (precision) decimals plus (int_size) digits plus 1 decimal point.
		size_t n = precision + int_size + 1;
		if (mpfr_sgn(op.core.u_mf) < 0)
			++n;
		
		if (length < int_size + 3) return VALUE_ERROR;
		
		// + 2 because 1 for null terminator, 1 for minus sign
		if (length < n + 2) n = length - 3;
		
		mp_exp_t *expptr = value_malloc(NULL, sizeof(mp_exp_t));
		if (expptr == NULL) return -3;
		if (mpfr_get_str(buffer, expptr, op_base, n, op.core.u_mf, value_mpfr_round) == NULL) {
			value_free(expptr);
			return -4;
		}
		
		mp_exp_t i, buflen = strlen(buffer);
		
		if (specifier == 'e') {
			char old2, old = '.';
			for (i = 1; i < buflen; ++i) {
				old2 = buffer[i];
				buffer[i] = old;
				old = old2;
			}
			
			char expstr[100];
			--*expptr;
			sprintf(expstr, "%ld", *expptr);
			if (length - buflen < strlen(expstr) + 2) return VALUE_ERROR;
			
			// Don't print out any trailing zeros.
			char *bufptr = buffer + buflen - 1;
			while (*bufptr == '0')
				--bufptr;
			sprintf(bufptr + 1, "e%s", expstr);
			
		} else {
			mpfr_sprintf(buffer, "%Rf", op.core.u_mf);
//			printf("buffer before: %s\n", buffer);
//			
//			// Insert a decimal point into the output buffer.
//			char ctmp, old = '.';
//			i = *expptr;
//			if (mpfr_sgn(op.core.u_mf) < 0)
//				++i;
//			printf("i = %ld\n", i);
//			if (i <= 0) {
//				--i;
//				// If the exponent is negative, insert zeros at the beginning.
//				if (length <= buflen + -i) return VALUE_ERROR;
//				memmove(buffer + -i, buffer, sizeof(char) * -i);
//				buflen += -i;
//				size_t j;
//				for (j = 0; j < -i; ++j)
//					buffer[j] = '0';
//				printf("buffer in between: %s\n", buffer);
//				i = (i + 1) + -i;
//			}
//			
//			// Make room for the decimal point.
//			memmove(buffer + i + 1, buffer + i, sizeof(char) * (buflen - i));
//			buffer[i] = '.';
//			++buflen;
//						
//			if (is_precision_default) {
//				printf("buflen = %ld\n", buflen);
//				// Unless a precision is explicitly given, remove trailing zeros.
//				while (buflen > 2 && buffer[buflen-1] == '0' && buffer[buflen-2] != '.')
//					buffer[--buflen] = '\0';
//			}
		}
		
		value_free(expptr);
		
	} else if (op.type == VALUE_STR) {
		if (specifier == 's') {
			// + 3 because one for each quotation mark and one for the null terminator.
			size_t i = 0;
			char *ptr = op.core.u_s - 1;
			if (i >= length) return VALUE_ERROR;
			buffer[i++] = '"';
			
			while (*(++ptr)) {
				if (i >= length) return VALUE_ERROR;
				if (isprint(*ptr)) buffer[i++] = *ptr;
				else {
					switch (*ptr) {
					case '\n': 
						buffer[i++] = '\\';
						if (i >= length) return VALUE_ERROR;
						buffer[i++] = 'n';
						break;
					case '\r': 
						buffer[i++] = '\\';
						if (i >= length) return VALUE_ERROR;
						buffer[i++] = 'r';
						break;
					case '\t':
						buffer[i++] = '\\';
						if (i >= length) return VALUE_ERROR;
						buffer[i++] = 't';
						break;
					}
				}

			}
			
			if (i >= length) return VALUE_ERROR;
			buffer[i++] = '"';
			if (i >= length) return VALUE_ERROR;
			buffer[i] = '\0';
			
//			if (strlen(op.core.u_s) + 3 > length) return VALUE_ERROR;
//			sprintf(buffer, "\"%s\"", op.core.u_s);
		} else {
			if (strlen(op.core.u_s) + 1 > length) return VALUE_ERROR;
			sprintf(buffer, "%s", op.core.u_s);
		}

	} else if (op.type == VALUE_RGX) {
		if (specifier == 's') {
			if (strlen(op.core.u_x) + 3 > length) return VALUE_ERROR;
			sprintf(buffer, "'%s'", op.core.u_x);
		} else {
			if (strlen(op.core.u_x) + 1 > length) return VALUE_ERROR;
			sprintf(buffer, "%s", op.core.u_x);
		}
	
	} else if (op.type == VALUE_SYM) {
		if (strlen(op.core.u_s) + 2 > length) return VALUE_ERROR;
		sprintf(buffer, ":%s", op.core.u_s);

	} else if (op.type == VALUE_ARY) {
		if (strlen("(array)") + 1 > length) return VALUE_ERROR;
		sprintf(buffer, "(array");
		size_t added_len = strlen(buffer);
		char *ptr = buffer + added_len;
		size_t i, ptrlen = length - added_len;
		
		for (i = 0; i < op.core.u_a.length; ++i) {
			if (ptrlen < 3) return VALUE_ERROR;
			*(ptr++) = ' '; --ptrlen;
			
			int error_p = value_put(ptr, ptrlen, op.core.u_a.a[i], format);
			if (error_p) return error_p;
			added_len = strlen(ptr);
			ptr += added_len;
			ptrlen -= added_len;
		}
		
		if (ptrlen < 2) return VALUE_ERROR;
		sprintf(ptr, ")");
		
	} else if (op.type == VALUE_LST) {
		if (strlen("(list)") + 1 > length) return VALUE_ERROR;
		sprintf(buffer, "(list");
		size_t added_len = strlen(buffer);
		char *ptr = buffer + added_len;
		size_t ptrlen = length - added_len;
		
		value opptr;
		for (opptr = op; opptr.type != VALUE_NIL; opptr = opptr.core.u_l[1]) {
			if (ptrlen < 3) return VALUE_ERROR;
			*(ptr++) = ' '; --ptrlen;
			
			int error_p = value_put(ptr, ptrlen, opptr.core.u_l[0], format);
			if (error_p) return error_p;
			added_len = strlen(ptr);
			ptr += added_len;
			ptrlen -= added_len;
		}
		
		if (ptrlen < 2) return VALUE_ERROR;
		sprintf(ptr, ")");
		
	} else if (op.type == VALUE_PAR) {
		int error_p = value_put(buffer, length, op.core.u_p->head, format);
		if (error_p) return VALUE_ERROR;
		size_t added_len = strlen(buffer);
		char *ptr = buffer + added_len;
		size_t ptrlen = length - added_len;
		
		if (ptrlen < 6) return VALUE_ERROR;
		sprintf(ptr, " -> ");
		
		added_len = strlen(ptr);
		ptr += added_len;
		ptrlen -= added_len;
		
		error_p = value_put(ptr, ptrlen, op.core.u_p->tail, format);
		if (error_p) return error_p;	
		
	} else if (op.type == VALUE_HSH) {
		if (strlen("(hash)") + 1 > length) return VALUE_ERROR;
		sprintf(buffer, "(hash");
		size_t added_len = strlen(buffer);
		char *ptr = buffer + added_len;
		size_t i, j, ptrlen = length - added_len;
		int first_p = TRUE;
		
		for (i = 0; i < op.core.u_h.length; ++i) 
		if (op.core.u_h.a[i].type != VALUE_NIL) {
			for (j = 0; j < op.core.u_h.a[i].core.u_a.length; ++j)
			if (op.core.u_h.a[i].core.u_a.a[j].type != VALUE_NIL) {
				if (first_p) {
					if (ptrlen < 3) return VALUE_ERROR;
					*(ptr++) = ' '; --ptrlen;
					first_p = FALSE;
				} else {
					if (ptrlen < 4) return VALUE_ERROR;
					*(ptr++) = ','; --ptrlen;		
					*(ptr++) = ' '; --ptrlen;		
				}

				
				int error_p = value_put(ptr, ptrlen, op.core.u_h.a[i].core.u_a.a[j].core.u_a.a[0], format);
				if (error_p) return error_p;
				added_len = strlen(ptr);
				ptr += added_len;
				ptrlen -= added_len;

				if (ptrlen < 5) return VALUE_ERROR;
				*(ptr++) = ' '; --ptrlen;
				*(ptr++) = '-'; --ptrlen;
				*(ptr++) = '>'; --ptrlen;
				*(ptr++) = ' '; --ptrlen;
				
				error_p = value_put(ptr, ptrlen, op.core.u_h.a[i].core.u_a.a[j].core.u_a.a[1], format);
				if (error_p) return error_p;
				added_len = strlen(ptr);
				ptr += added_len;
				ptrlen -= added_len;
			}
		}
		
		if (ptrlen < 2) return VALUE_ERROR;
		sprintf(ptr, ")");
		
	} else if (op.type == VALUE_PTR) {
		
		// WARNING: This has not been tested.
		
		if (strlen("pointer ()") + 1 > length) return VALUE_ERROR;
		sprintf(buffer, "pointer (");
		size_t added_len = strlen(buffer);
		
		int error_p = value_put(buffer+added_len, length-added_len, *op.core.u_ptr, format);
		if (error_p) return error_p;
		
		added_len = strlen(buffer);
		if (added_len + 2 > length) return VALUE_ERROR;
		sprintf(buffer+added_len, ")");
		
	} else if (op.type == VALUE_RNG) {
		int error_p = value_put(buffer, length, op.core.u_r->min, format);
		if (error_p) return VALUE_ERROR;
		size_t added_len = strlen(buffer);
		char *ptr = buffer + added_len;
		size_t ptrlen = length - added_len;
		
		if (ptrlen < 4) return VALUE_ERROR;
		if (op.core.u_r->inclusive_p)
			sprintf(ptr, "..");
		else sprintf(ptr, "...");
		
		added_len = strlen(ptr);
		ptr += added_len;
		ptrlen -= added_len;
		
		error_p = value_put(ptr, ptrlen, op.core.u_r->max, format);
		if (error_p) return error_p;
			
	} else if (op.type == VALUE_BLK) {
		if (strlen("()") + 1 > length) return VALUE_ERROR;
		sprintf(buffer, "(");
		size_t added_len = strlen(buffer);
		char *ptr = buffer + added_len;
		size_t i, ptrlen = length - added_len;
		
		if (op.core.u_blk.s) {
			if (strlen(op.core.u_blk.s) + 2 > ptrlen) return VALUE_ERROR;
			sprintf(ptr, "%s)", op.core.u_blk.s);
			
		} else {
			for (i = 0; i < op.core.u_blk.length; ++i) {
				if (ptrlen < 3) return VALUE_ERROR;
				if (i) { *(ptr++) = ' '; --ptrlen; }
				
				int error_p = value_put(ptr, ptrlen, op.core.u_blk.a[i], format);
				if (error_p) return error_p;
				added_len = strlen(ptr);
				ptr += added_len;
				ptrlen -= added_len;
			}
			
			if (ptrlen < 2) return VALUE_ERROR;
			sprintf(ptr, ")");
			added_len = strlen(ptr);
			ptr += added_len;
			ptrlen -= added_len;
		}
		
		*ptr = '\0';
		
	} else if (op.type == VALUE_NAN) {
		if (strlen("NaN") > length + 1) return VALUE_ERROR;
		sprintf(buffer, "NaN");
		
	} else if (op.type == VALUE_INF) {
		if (strlen("infinity") > length + 1) return VALUE_ERROR;
		sprintf(buffer, "infinity");
		
	} else if (op.type == VALUE_TYP) {
		const char *tstr = type_to_string(op.core.u_type);
		if (strlen(tstr) > length + 1) return VALUE_ERROR;
		strcpy(buffer, tstr);
	
	} else if (op.type == VALUE_ID) {
		if (strlen(op.core.u_id) + 1 > length) return VALUE_ERROR;
		sprintf(buffer, "%s", op.core.u_id);		
	
	} else if (op.type == VALUE_VAR) {
		if (strlen(op.core.u_var) + 1 > length) return VALUE_ERROR;
		sprintf(buffer, "%s", op.core.u_var);
	
	} else if (op.type == VALUE_SPEC) {
		if (length < 100) return VALUE_ERROR;
		sprintf(buffer, "Spec [ changes cope? %d, needs variables? %d, keep arg? %d, delay eval? %d, argc %d, optional %d, rest? %d, associativity %c, precedence %d ]", 
				op.core.u_spec.change_scope_p, op.core.u_spec.needs_variables_p, op.core.u_spec.keep_arg_p, op.core.u_spec.delay_eval_p, 
				op.core.u_spec.argc, op.core.u_spec.optional, op.core.u_spec.rest_p, op.core.u_spec.associativity, op.core.u_spec.precedence);
		
		
	} else if (op.type == VALUE_BIF) {
		value *ref = value_hash_get_ref(primitive_names, op);
		if (ref == NULL)
			sprintf(buffer, "unknown");
		else {
			int error_p = value_put(buffer, length, *ref, format);
			if (error_p) return error_p;
		}
		
	} else if (op.type == VALUE_UDF || op.type == VALUE_UDF_SHELL) {
		if (op.core.u_udf->name == NULL) {
			if (strlen("(unnamed)") + 1 >= length) return VALUE_ERROR;
			else sprintf(buffer, "(unnamed)");
		} else if (strlen(op.core.u_udf->name) + 1 >= length) return VALUE_ERROR;
		else sprintf(buffer, "%s", op.core.u_udf->name);
		
		if (specifier == 's') {
			size_t added_len = strlen(buffer);
			int error_p = value_put(buffer + added_len, length - added_len, op.core.u_udf->vars, format);
			if (error_p) return VALUE_ERROR;
		}
		
		// Print out the body of the function.
//		added_len += strlen(buffer + added_len);
//		error_p = value_put(buffer + added_len, length - added_len, op.core.u_udf->body, format);
//		if (error_p) return VALUE_ERROR;	
		
	} else if (op.type == VALUE_ERROR) {
		if (strlen("error") > length + 1) return VALUE_ERROR;
		sprintf(buffer, "error");
	} else {
		if (strlen("unknown") > length + 1) return VALUE_ERROR;
		sprintf(buffer, "unknown");		
	}
	
	size_t buflen = strlen(buffer);
	
	if (print_type) {
		char *ptr = buffer + buflen;
		if (length - (ptr - buffer) <= strlen(type_to_string(op.type))) return VALUE_ERROR;
		sprintf(ptr, ":%s", type_to_string(op.type));
		buflen += strlen(ptr);
	}
	
	if (buflen > width) {
		size_t middle = width / 2 - 2;
		if (width - middle < 5) middle = width - 5;
		if (middle < 0) middle = 0;
		
		if (length - middle <= 5) return VALUE_ERROR;
		if (width < 5) width = 5;
		sprintf(buffer + middle, "(...)%s", buffer + buflen - (width - middle - 5));
	}
	
	buffer[width] = '\0';
	
	return 0;
}

/* 
 * This returns the address of a local variable, which is kind of a bad idea. But it's also 
 * currently the best way to get a string.
 */
char * value_to_string(value op)
{
	size_t buf_len = BUFSIZE;
	
	while (buf_len <= BIGBUFSIZE) {
		char buffer[buf_len];
		int error_p = value_put(buffer, buf_len, op, NULL);
		if (error_p == 0) return buffer;
		
		buf_len <<= 4;
	}
	
	value_error(1, "IO Error: In to_string(), op is too big to output.");
	return value_to_string(value_init_error());
}

/* 
 * A NULL string indicates that there was an error.
 */
char * value_to_string_base(value op, value base)
{
	char str[BIGBUFSIZE];
	
	int error_p = FALSE;
	if (base.type != VALUE_MPZ) {
		value_error(1, "Type Error: to_string_base() is undefined where base is %ts (integer expected).", base);
		error_p = TRUE;
	}
	
	value zero = value_set_long(0), 
		one = value_set_long(1), 
		thirty_six = value_set_long(36);
	if (error_p == FALSE && (value_lt(base, zero) || value_eq(base, one) || value_gt(base, thirty_six))) {
		value_error(1, "Type Error: to_string_base() is undefined where base equals %s (0 or 2-36 expected).", base);
		error_p = TRUE;
	}
	value_clear(&zero); value_clear(&one); value_clear(&thirty_six);
	
	int b = (int) value_get_ulong(base);
	
	if (op.type == VALUE_MPZ) {
		if (error_p == FALSE)
			mpz_get_str(str, b, op.core.u_mz);
	} else {
		value_error(1, "Type Error: to_string_base() is undefined where op is %ts (integer expected).", op);
		error_p = TRUE;
	}
	
	if (error_p)
		return NULL;
	return str;
}

char * value_to_string_safe(value op)
{
	size_t buf_len = BUFSIZE;
	
	while (buf_len <= BIGBUFSIZE) {
		char *buffer = value_malloc(NULL, buf_len);
		if (buffer == NULL) return NULL;
		int error_p = value_put(buffer, buf_len, op, NULL);
		if (error_p == 0) return buffer;
		
		buf_len <<= 4;
		value_free(buffer);
	}
	
	value_error(1, "IO Error: In to_string(), op is too big to output.");
	return value_to_string_safe(value_init_error());
}

int value_print(value op)
{
	return value_printf("%v", op);
}

int value_println(value op)
{
	value_print(op);
	printf("\n");
	return 0;
}

int value_printf(const char *format, ...)
{
	va_list ap;
	va_start(ap, format);
	return value_vfprintf(stdout, format, ap);
}

int value_fprintf(FILE *fp, const char *format, ...)
{
	va_list ap;
	va_start(ap, format);	
	return value_vfprintf(fp, format, ap);
}

int value_vfprintf(FILE *fp, const char *format, va_list ap)
{
	return value_vprintf_generic(fp, NULL, format, 0, NULL, ap);
}

int value_sprintf(char *str, const char *format, ...)
{
	va_list ap;
	va_start(ap, format);
	return value_vprintf_generic(NULL, str, format, 0, NULL, ap);
}

int value_vprintf_generic(FILE *fp, char *str, const char *format, int argc, value *argv, va_list ap)
{
	value op;
	const char *ptr = format - 1;
	int argi = 0;
	
	while (*(++ptr)) {
		if (*ptr != '%') {
			if (fp) fputc(*ptr, fp);
			else *(str++) = *ptr;
			continue;
		}
		
		if (argv) {
			if (argi >= argc) {
				value_error(1, "Error: In formatted output, too many format tags.");
				return VALUE_ERROR;
			}
			op = argv[argi++];
		} else op = va_arg(ap, value);
		
		// Put the format into the one_fmt string, to be passed into value_put().
		char one_fmt[BUFSIZE];
		size_t i = 0;
		while (*(++ptr)) {
			one_fmt[i++] = *ptr;
			if (!(*ptr == '.' || isdigit(*ptr) || *ptr == 'r' || *ptr == 't')) {
				++ptr;
				break;
			}
		}
		one_fmt[i] = '\0';
		
		--ptr;
		
		if (one_fmt[0] == '%') {
			--argi; // %% doesn't count as a format tag.
			if (fp) fprintf(fp, "%%");
			else *(str++) = '%';
			continue;
		}
		
		size_t buf_len = BUFSIZE;
		
		while (buf_len <= BIGBUFSIZE) {
			char buffer[buf_len];
			int error_p = value_put(buffer, buf_len, op, one_fmt);
			if (error_p == 0) {
				if (fp) {
					fprintf(fp, "%s", buffer);
				} else {
					sprintf(str, "%s", buffer);
					str += strlen(str);
				}
				break;
			} else if (error_p != VALUE_ERROR) {
				// There was an error not related to buffer size.
				char error_buf[100];
				
				if (error_p == -2) sprintf(error_buf, "(error in output: undefined format specifier %s)", one_fmt);
				else if (error_p == -3) sprintf(error_buf, "(error in output: ran out of memory)");
				else if (error_p == -4) sprintf(error_buf, "(error in output: error in mpfr_get_str())");
				
				if (fp) {
					fprintf(fp, error_buf);
				} else {
					sprintf(str, error_buf);
				}
				if (argv == NULL) va_end(ap);
				return VALUE_ERROR;
			}
			
			buf_len <<= 4;
		}
		
		if (buf_len > BIGBUFSIZE) {
			value_error(1, "IO Error: In print, op is too big to output.");
			va_end(ap);
			return VALUE_ERROR;
		}
	}
	
	va_end(ap);
	
	return 0;
}

int value_error(int severity, char *format, ...)
{
	if (print_errors_p == FALSE)
		return 1;
	
	va_list ap;
	va_start(ap, format);

	error_count += severity;
	
	if (linenum != 0)
		fprintf(stderr, "From line %d, ", linenum);
	char *ptr = format - 1;
	while (*(++ptr)) {
		if (*ptr != '%') {
			fputc(*ptr, stderr);
			continue;
		}
		
		++ptr;
		if (*ptr == 'd') {
			int val = va_arg(ap, int);
			fprintf(stderr, "%d", val);
		} else if (*ptr == 'c') {
			char *val = va_arg(ap, char *);
			fprintf(stderr, "%s", val);
		} else if (*ptr == 'l') {
			++ptr;
			if (*ptr == 'd') {
				long val = va_arg(ap, long);
				fprintf(stderr, "%ld", val);
			}
		} else {
			char one_fmt[50];
			int i = 0;
			one_fmt[i++] = '%';
			while (*ptr == '.' || isdigit(*ptr) || *ptr == 'r' || *ptr == 't')
				one_fmt[i++] = *ptr++;
			one_fmt[i++] = *ptr;
			one_fmt[i] = '\0';
			value_vfprintf(stderr, one_fmt, ap);
		}

	}
	
	fprintf(stderr, "\n");
	va_end(ap);
	
	return 0;
}

value value_print_arg(int argc, value argv[])
{
	if (missing_arguments(argc, argv, "print"))
		return value_init_error();
	value_print(argv[0]);
	return value_set(argv[0]);
}

value value_println_arg(int argc, value argv[])
{
	int new_p = FALSE;
	if (argv[0].type == VALUE_MISSING_ARG) {
		new_p = TRUE;
		argv[0] = value_set_str("");
	}
	if (missing_arguments(argc, argv, "println"))
		return value_init_error();
	value_println(argv[0]);
	if (new_p)
		return argv[0];
	else return value_set(argv[0]);
}

value value_printf_arg(int argc, value argv[])
{
	if (missing_arguments(argc, argv, "println"))
		return value_init_error();
	if (argv[0].type != VALUE_STR) {
		value_error(1, "Type Error: printf() is undefined where op1 is %ts (string expected.", argv[0]);
	}
	int error_p = value_vprintf_generic(stdout, NULL, argv[0].core.u_s, argc-1, argv+1, 0);
	if (error_p) return value_init_error();
	return value_init_nil();
}

int print_values(value words[], size_t length)
{
	size_t i;
	for (i = 0; i < length; ++i)
		value_printf("%s ", words[i]);
	printf("\n");
	return 0;
}
/*
 *  value.h
 *  Simfpl
 *
 *  Created by Michael Dickens on 1/23/10.
 *
 */

#ifndef TOOLS_H
#include "tools.h"
#endif

/* Single-value types. */
#define VALUE_NIL 0
#define VALUE_NAN 1
#define VALUE_INF 2

#define VALUE_TYP 3

#define VALUE_SPEC 4

/* General types. */
#define VALUE_BOO 10
#define VALUE_MPZ 11
#define VALUE_MPF 12
#define VALUE_STR 13
#define VALUE_ID  14
#define VALUE_VAR 15
#define VALUE_RGX 16	// Regular expression.
#define VALUE_SYM 17	// Symbol.

/* Containers and iterables. */
#define VALUE_ARY 18
#define VALUE_LST 19
#define VALUE_PAR 20	// Pair.
#define VALUE_HSH 21
#define VALUE_TRE 22	// Tree.
#define VALUE_PTR 23
#define VALUE_RNG 24	// Range.
#define VALUE_BLK 25	// Block, in the form of an S-expression.

#define VALUE_STOP 26	// Stop the execution of a loop or iterator.

#define VALUE_BIF 30	// Built-in function.
#define VALUE_UDF 31	// User-defined function.
#define VALUE_UDF_SHELL 32

#define VALUE_EXC 40	// Exception.
#define VALUE_MISSING_ARG 41


#define VALUE_ERROR -1


/*
 * A structure for holding a dynamic value. The types it supports can be seen in the macros 
 * above, named VALUE_XYZ.
 * 
 * See "using the value type.rtf" for more information.
 */



/* 
 * A Note on The Categorization of Functions: 
 * 
 * Functions are placed in several different files.
 * 
 * Some functions can be applied to multiple types. For example, addition typically refers to 
 * addition of numbers, but it is also possible to add (concat) strings or arrays. In such cases, 
 * the function is placed in the file of whichever type it is most used for. If there is no clear 
 * most-used type, then it is placed in whichever file comes first in the below list.
 * 
 * value.c: Generic functions and functions for types too small to warrant their own file. 
 *   Includes pointers and I/O.
 * value_number.c: Numeric functions for integers and floats.
 * value_string.c: String functions.
 * value_regex.c: Functions for regular expressions and strings.
 * value_array.c: Functions for arrays. All of these functions should work on lists as well.
 * value_list.c: Functions for lists. Optimized for lists, but should work on arrays as well.
 * value_hash.c: Functions for hashes. Many of these have special names, and work fairly 
 *   independently of the other value functions. This is primarily because hashes are used 
 *   internally so it's easier if they work somewhat differently.
 * value_range.c: Functions for ranges.
 * value_block.c: Functions for blocks, control structures, and user-defined functions.
 * value_exception.c: Functions for exceptions.
 */

// The actual definition for the value type is in tools.h.

/* 
 * These have to be put here because C's file hierarchy is stupid.
 */

value global_variables;

// These are initialized in init_interpreter().
value primitive_funs;
value primitive_specs;
value primitive_names;
value symbol_ids;
value function_ids;

/* 
 * Evaluates the given S-expression.
 */
#define eval(variables, sexp) eval_generic(variables, sexp, FALSE)

/* The generic version of eval(), which takes additional arguments.
 * outer_was_block_p: If the outer sexp was a block, then a stack trace is 
 * not printed. when the program throws an error. This prevents excessively 
 * deep stack traces.
 */
value eval_generic(value *variables, value sexp, int outer_was_block_p);

struct value_spec compile_spec(char *str);

/* These only deal with references to values, so be sure to make a copy if you 
 * need to.
 */
value line_queue;
value line_queue_back;
void line_enqueue(value op);
void line_enqueue_front(value op);
value line_dequeue();

/* Returns an array containing the next word. May contain multiple values in the case 
 * of parentheses or brackets.
 */
value get_next_word(value words[], size_t length);


/* 
 * Declarations for optimize.c
 * 
 * See optimize.c for documentation.
 */

#define O_1 0x1
#define O_2 0x2
#define O_3 0x4
#define O_4 0x8
#define O_ASSUME_NUMERIC 0x10

value value_optimize(value op, int flags);
value value_optimize_std(value op, value flags);
value value_optimize_now(value *op, int flags);
value value_optimize1_now(value *op, int flags);
value value_optimize2_now(value *op, int flags);
value value_optimize3_now(value *op, int flags);
value value_optimize4_now(value *op, int flags);

int optimize_put_constants_first(value *op, value words[], size_t length, int assume_numeric);
int optimize_simplify_constant_across_block(value *op, value words[], size_t length, int assume_numeric);

value value_optimize_arg(int argc, value argv[]);


/* 
 * Declarations for the Value Type
 */


// These are initialized in init_values().
mpfr_prec_t value_mpfr_default_prec;
mpfr_rnd_t value_mpfr_round, value_mpfr_round_cast;
value value_int_min, value_zero, value_one, value_int_max, value_nil;
value value_symbol_in, value_symbol_dotimes, value_symbol_if;
struct value_spec value_nil_function_spec;

exception argument_error, generic_error, memory_error, runtime_error, syntax_error, type_error;


/* 
 * Initializes the value type. This should be done before any value is used.
 */
int init_values();

#define return_if_error(op) if ((op).type == VALUE_ERROR) return (op)
#define return_if_null(op) if ((op) == NULL) return value_init_error()

/* 
 * Determines whether the function called (name) has any missing arguments. This is 
 * mostly for internal use.
 */
int missing_arguments(int argc, value argv[], char *name);

const char * type_to_string(int type);

int value_array_id_index(value vals[], int length, char *val);
int value_array_copy(value target[], value source[], int size);

/* Initializes a value to nil.
 */
value value_init_nil();

/* Initializes a value to (error).
 */
value value_init_error();

/* Initializes a value of the given type. Allocates memory, sets containers to 
 * empty and sets numbers to 0.
 */
value value_init(int type);

/* Clears the given value. Values must be cleared after you are done using them.
 */
int value_clear(value *op);

/* Returns a deep copy of (op).
 */
value value_set(value op);
value value_set_arg(int argc, value argv[]);

value switch_value_set(value op);
value if_value_set(value op);

value value_set_bool(int x);
value value_set_long(long x);
value value_set_bigint(long x);
value value_set_ulong(unsigned long x);
value value_set_double(double x);
value value_set_str(char *str);
value value_set_str_length(char *str, size_t length);
value value_set_symbol(char *str);
value value_set_ary(value array[], size_t length);
value value_set_ary_ref(value array[], size_t length);
value value_set_ary_bool(int array[], size_t length);
value value_set_ary_long(long array[], size_t length);
value value_set_ary_ulong(unsigned long array[], size_t length);
value value_set_ary_double(double array[], size_t length);
value value_set_ary_str(char *array[], size_t length);
value value_set_block(value array[], size_t length);

/* Returns a shallow copy of (op).
 */
value value_copy(value op);

/* Set the value based on (str). It automatically converts to an integer, a double, or whatever 
 * is necessary.
 */
value value_set_str_smart(char *str, int base);
value value_set_id(char *id);
value value_set_fun(value (*fun)(int argc, value argv[]));

/* If the given function is commutative, returns TRUE. If not, or if the given value is 
 * not a function, returns FALSE.
 */
int value_commutative_p(value fun);

// value_malloc() and related functions are declared in tools.c.


/* 
 * 
 * 
 * External functions start here.
 * 
 * 
 */
 
 
/* Imports a file and runs its contents. op is a string representing the file nmae.
 */
value value_import(value op);
value value_import_arg(int argc, value argv[]);

/* 
 * Constructor functions for data structures.
 */
value value_array_arg(int argc, value argv[]);
value value_list_arg(int argc, value argv[]);
value value_hash_arg(int argc, value argv[]);


/* 
 * Conversion functions.
 */
value value_cast(value op, int type);

/* to array */
value value_to_a_arg(int argc, value argv[]);

/* to float */
value value_to_f_arg(int argc, value argv[]);

/* to hash */
value value_to_h_arg(int argc, value argv[]);

/* to integer */
value value_to_i_arg(int argc, value argv[]);

/* to list */
value value_to_l_arg(int argc, value argv[]);

/* to string */
value value_to_s_arg(int argc, value argv[]);

/* to regex */
value value_to_r_arg(int argc, value argv[]);

/* Converts op1 to a string in the given base.
 */
value value_to_s_base_arg(int argc, value argv[]);

/* Returns the value's type.
 */
value value_type(value op);
value value_type_arg(int argc, value argv[]);

/* Determines whether (op) is considered true.
 */
int value_true_p(value op);
value value_true_p_arg(int argc, value argv[]);


/* 
 * Assignment and data manipulation functions.
 */
value value_assign(value *variables, value op1, value op2);
value value_assign_arg(int argc, value argv[]);

// These functions are not implemented, as I see no need to implement them.
// assign_(operation)_arg works just fine.
value value_assign_add(value *variables, value op1, value op2);
value value_assign_sub(value *variables, value op1, value op2);
value value_assign_mul(value *variables, value op1, value op2);
value value_assign_div(value *variables, value op1, value op2);
value value_assign_mod(value *variables, value op1, value op2);
value value_assign_and(value *variables, value op1, value op2);
value value_assign_xor(value *variables, value op1, value op2);
value value_assign_or(value *variables, value op1, value op2);
value value_assign_shl(value *variables, value op1, value op2);
value value_assign_shr(value *variables, value op1, value op2);

value value_assign_add_arg(int argc, value argv[]);
value value_assign_sub_arg(int argc, value argv[]);
value value_assign_mul_arg(int argc, value argv[]);
value value_assign_div_arg(int argc, value argv[]);
value value_assign_mod_arg(int argc, value argv[]);
value value_assign_and_arg(int argc, value argv[]);
value value_assign_xor_arg(int argc, value argv[]);
value value_assign_or_arg(int argc, value argv[]);
value value_assign_shl_arg(int argc, value argv[]);
value value_assign_shr_arg(int argc, value argv[]);

/* 
 * Pair functions.
 */
value value_make_pair(value op1, value op2);

// These need better names.
value value_pair_first(value op);
value value_pair_second(value op);

value value_make_pair_arg(int argc, value argv[]);

/* 
 * Pointer functions.
 */
// It would be nice to get these to work externally.
value value_refer(value *op);
value * value_deref(value op);

value value_refer_arg(int argc, value argv[]);

/* 
 * I/O Functions.
 */
value value_gets();

value value_gets_arg(int argc, value argv[]);

//value value_point_arg(int argc, value argv[]);
//value value_deref_arg(int argc, value argv[]);

value value_set_default_prec(value prec);
void value_set_prec_now(value *op, value prec);
value value_set_prec_arg(int argc, value argv[]);
value value_set_default_prec_arg(int argc, value argv[]);

/* 
 * Arithmetic functions. Nearly all functions use GMP and MPFR to perform 
 * computations, so see the GMP and MPFR manuals for further details. Uses 
 * GMP version 4.3.2 and MPFR version 2.4.2.
 * 
 * http://www.gnu.org/software/gmp/manual/html_mono/gmp.html
 * http://www.mpfr.org/mpfr-current/mpfr.html
 * 
 */

/* Adds two values together. It is defined differently for different types. 
 * In order of precedence: 
 * 
 * number and number: Numeric addition. If one or more of the numbers is a 
 *   float, the result is a float; otherwise, the result is an integer.
 * string and any: Converts op2 to a string and concatenates it to op1.
 * (regex, array or list) and same: Concatenates op1 and op2.
 * array and any: Appends op2 to op1.
 * list and any: Appends op2 to op1.
 * any and array: Prepends op1 to op2.
 * any and list: Conses op1 to op2.
 * any and string: Converts op1 to a string and concatenates it to op2.
 * 
 * Because this function cannot tell whether nil is supposed to represent 
 * a null value or the end of a list, addition with nil as an argument will 
 * return an error. This function will NOT assume that nil is the end of 
 * a list. If you want to construct a list, use (cons).
 */
value value_add(value op1, value op2);
value value_add_now(value *op1, value op2);

/* Subtracts op2 from op1. Only defined where op1 and op2 are numbers.
 */
value value_sub(value op1, value op2);
value value_sub_now(value *op1, value op2);

/* Multiplies op1 by op2. Defined differently for different types. In 
 * order of precedence: 
 * 
 * number and number: Numeric multiplication, as you'd expect.
 * (string, array or list) and integer: Concatenates op1 to itself op2 times.
 * integer and (string, array or list): Concatenates op2 to itself op1 times.
 */
value value_mul(value op1, value op2);
value value_mul_now(value *op1, value op2);

/* Divides op1 by op2. Only defined for numbers. If op2 is zero, returns NaN.
 */
value value_div(value op1, value op2);
value value_div_now(value *op1, value op2);

/* Calculates op1 modulo op2. Only defined for numbers. if op2 is zero, 
 * returns NaN.
 */
value value_mod(value op1, value op2);
value value_mod_now(value *op1, value op2);

value value_add_arg(int argc, value argv[]);
value value_sub_arg(int argc, value argv[]);
value value_mul_arg(int argc, value argv[]);
value value_div_arg(int argc, value argv[]);
value value_mod_arg(int argc, value argv[]);

/* Increments op.
 */
value value_inc(value op);
value value_inc_now(value *op);

/* Decrements op.
 */
value value_dec(value op);
value value_dec_now(value *op);

value value_inc_arg(int argc, value argv[]);
value value_dec_arg(int argc, value argv[]);

/* Returns negative (op).
 */
value value_uminus(value op);

/* Returns positive (op). This is NOT absolute value; uplus(1) will 
 * return 1, and uplus(-1) will return -1.
 */
value value_uplus(value op);

/* Returns the absolute value of op.
 */
value value_abs(value op);

value value_uminus_arg(int argc, value argv[]);
value value_uplus_arg(int argc, value argv[]);
value value_abs_arg(int argc, value argv[]);


/* 
 * Comparison functions.
 * 
 * For integers and floats: The values of the numbers are compared. If 
 * the types otherwise do not match, the types themselves are compared.
 * 
 * For single-type values such as nil and infinity: the values are 
 * considered equal.
 * 
 * For booleans: false is considered less than true.
 * 
 * For arrays and for lists; Each element of the data set is compared. 
 * If they are not equal, the result of the comparison is returned. If 
 * every value is equal up to length(op1) or length(op2), whichever is 
 * smaller, then the lengths are compared.
 * 
 * For pointers: The values inside the pointers are compared.
 */
int value_cmp(value op1, value op2);
value value_cmp_std(value op1, value op2);
int value_cmp_any(value op1, value op2);
int value_lt(value op1, value op2);
value value_lt_std(value op1, value op2);
int value_le(value op1, value op2);
value value_le_std(value op1, value op2);
int value_eq(value op1, value op2);
value value_eq_std(value op1, value op2);
int value_ne(value op1, value op2);
value value_ne_std(value op1, value op2);
int value_ge(value op1, value op2);
value value_ge_std(value op1, value op2);
int value_gt(value op1, value op2);
value value_gt_std(value op1, value op2);

/* Tests for equality based on object identity. Usually you want to use 
 * (eq) when comparing two values.
 */
int velue_equal_p(value op1, value op2);
value value_equal_p_std(value op1, value op2);

value value_cmp_arg(int argc, value argv[]);
value value_lt_arg(int argc, value argv[]);
value value_le_arg(int argc, value argv[]);
value value_eq_arg(int argc, value argv[]);
value value_ne_arg(int argc, value argv[]);
value value_ge_arg(int argc, value argv[]);
value value_gt_arg(int argc, value argv[]);


/*
 * Logical operations. The std versions of these return not a boolean, but 
 * whichever of the operands is the deciding factor. For instance: 
 * 
 * ("hi" || 10) returns "hi", because "hi" makes the expression true
 * (false || 10) returns 10
 * ("hi" && 10) returns 10, because 10 makes the expression true
 * (false && "hi") returns (false), because (false) makes the expression false
 * 
 * The versions that return ints merely return true (nonzero) or false (zero).
 */
int value_and_p(value op1, value op2);
value value_and_p_std(value op1, value op2);
int value_or_p(value op1, value op2);
value value_or_p_std(value op1, value op2);
int value_not_p(value op);
value value_not_p_std(value op);

value value_and_p_arg(int argc, value argv[]);
value value_or_p_arg(int argc, value argv[]);
value value_not_p_arg(int argc, value argv[]);


/* 
 * Bitwise operations.
 */

/* Calculate (op1) * 2**(op2) using bit shifts.
 */
value value_2exp(value op1, long op2);

/* Returns op1 shifted left by op2 bits.
 */
value value_shl(value op1, unsigned long op2);
value value_shl_std(value op1, value op2);

/* Returns op1 shifted right by op2 bits.
 */
value value_shr(value op1, unsigned long op2);
value value_shr_std(value op1, value op2);

/* Returns the bitwise AND of op1 and op2.
 */
value value_and(value op1, value op2);

/* Returns the bitwise inclusive-OR of op1 and op2.
 */
value value_or(value op1, value op2);

/* Returns the bitwise exclusive-OR of op1 and op2.
 */
value value_xor(value op1, value op2);

/* Returns the bitwise NOT of op.
 */
value value_not(value op);

value value_2exp_arg(int argc, value argv[]);
value value_shl_arg(int argc, value argv[]);
value value_shr_arg(int argc, value argv[]);
value value_and_arg(int argc, value argv[]);
value value_or_arg(int argc, value argv[]);
value value_xor_arg(int argc, value argv[]);
value value_not_arg(int argc, value argv[]);


/* 
 * Number theory functions.
 */
 
/* Returns TRUE if op is probably prime, and FALSE if it is definitely 
 * composite.
 */
int value_probab_prime_p(value op);
value value_probab_prime_p_std(value op);

/* Returns the next probable prime after op.
 */
value value_nextprime(value op);

/* Calculates the greatest common divisor of op1 and op2.
 */
value value_gcd(value op1, value op2);

value value_probab_prime_p_arg(int argc, value argv[]);
value value_nextprime_arg(int argc, value argv[]);
value value_gcd_arg(int argc, value argv[]);

/* Returns the number of seconds on the system clock.
 */
value value_seconds();
value value_seconds_arg(int argc, value argv[]);

/* 
 * Exponential functions.
 */

/* Calculates op1 to the op2 power.
 */
value value_pow(value op1, value op2);

/* Calculates the modular exponent with base (base), exponent (exp), and 
 * modulo (mod). Equivaleant to (base**exp % mod).
 */
value value_modexp(value base, value exp, value mod);

/* Calculates the binomial coefficient (n choose k) of op1 and op2.
 */
value value_choose(value op1, value op2);

/* Calculates e to the power of op.
 */
value value_exp(value op);

/* Calculates the natural logarithm of op.
 */
value value_log(value op);

/* Calculates the logarithm base 2 of op.
 */
value value_log2(value op);

/* Calculates the logarithm base 10 of op.
 */
value value_log10(value op);

/* Calculates the square root of op.
 */
value value_sqrt(value op);

/* Calculates the factorial of op.
 */
value value_factorial(value op);
value value_product_private(int n); /* A helper function for factorial(). */

value value_pow_arg(int argc, value argv[]);
value value_modexp_arg(int argc, value argv[]);
value value_choose_arg(int argc, value argv[]);
value value_exp_arg(int argc, value argv[]);
value value_log_arg(int argc, value argv[]);
value value_log10_arg(int argc, value argv[]);
value value_log2_arg(int argc, value argv[]);
value value_sqrt_arg(int argc, value argv[]);
value value_factorial_arg(int argc, value argv[]);



/* A function to perform any of the trigonometric or hyperbolic functions. 
 * Having them  all in one function is not quite as fast, but it is more 
 * concise.
 */
value value_trig(value op, int func);

value value_sin_arg(int argc, value argv[]);
value value_cos_arg(int argc, value argv[]);
value value_tan_arg(int argc, value argv[]);
value value_csc_arg(int argc, value argv[]);
value value_sec_arg(int argc, value argv[]);
value value_cot_arg(int argc, value argv[]);
value value_asin_arg(int argc, value argv[]);
value value_acos_arg(int argc, value argv[]);
value value_atan_arg(int argc, value argv[]);

value value_sinh_arg(int argc, value argv[]);
value value_cosh_arg(int argc, value argv[]);
value value_tanh_arg(int argc, value argv[]);
value value_csch_arg(int argc, value argv[]);
value value_sech_arg(int argc, value argv[]);
value value_coth_arg(int argc, value argv[]);
value value_asinh_arg(int argc, value argv[]);
value value_acosh_arg(int argc, value argv[]);
value value_atanh_arg(int argc, value argv[]);

/* 
 * Calculus functions.
 */

/* Calculates the single-variable derivative of a given function. It must 
 * be in standard S-expression notation.
 */
value value_deriv(value op);
value value_deriv_2(value op);
value value_deriv_3(value op);

value value_deriv_arg(int argc, value argv[]);

/* 
 * Special functions for floating-point numbers.
 * See http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions
 */
value value_eint(value op);
value value_li2(value op);
value value_gamma(value op);
value value_lngamma(value op);
value value_zeta(value op);
value value_erf(value op);
value value_erfc(value op);

value value_srand(value seed);
value value_rand(value op);

value value_srand_arg(int argc, value argv[]);
value value_rand_arg(int argc, value argv[]);

/* 
 * Numeric iterators.
 */

/* Repeatedly calls (func), (op) times.
 */
value value_times(value *variables, value op, value func);

/* Calculates the summation over (op) of the result of (func). (op) 
 * should be an array or range. For example, summation(1..10, 2*n)
 * will calculate the summation from n=1 to 10 of 2*n.
 */
value value_summation(value *variables, value op, value func);

value value_times_arg(int argc, value argv[]);
value value_summation_arg(int argc, value argv[]);


#define VALUE_SIN 0
#define VALUE_COS 1
#define VALUE_TAN 2
#define VALUE_CSC 3
#define VALUE_SEC 4
#define VALUE_COT 5
#define VALUE_ASIN 6
#define VALUE_ACOS 7
#define VALUE_ATAN 8

#define VALUE_SINH 9
#define VALUE_COSH 10
#define VALUE_TANH 11
#define VALUE_CSCH 12
#define VALUE_SECH 13
#define VALUE_COTH 14
#define VALUE_ASINH 15
#define VALUE_ACOSH 16
#define VALUE_ATANH 17

// These are done with macros instead of functions because it is more concise.
#define value_sin(op) value_trig(op, 0)
#define value_cos(op) value_trig(op, 1)
#define value_tan(op) value_trig(op, 2)
#define value_csc(op) value_trig(op, 3)
#define value_sec(op) value_trig(op, 4)
#define value_cot(op) value_trig(op, 5)
#define value_asin(op) value_trig(op, 6)
#define value_acos(op) value_trig(op, 7)
#define value_atan(op) value_trig(op, 8)

#define value_sinh(op) value_trig(op, 9)
#define value_cosh(op) value_trig(op, 10)
#define value_tanh(op) value_trig(op, 11)
#define value_csch(op) value_trig(op, 12)
#define value_sech(op) value_trig(op, 13)
#define value_coth(op) value_trig(op, 14)
#define value_asinh(op) value_trig(op, 15)
#define value_acosh(op) value_trig(op, 16)
#define value_atanh(op) value_trig(op, 17)


/* 
 * 
 * String functions.
 * 
 */

/* Converts the first character to uppercase and every 
 * other character to lowercase.
 */
value value_capitalize(value op);

/* Returns a new string with the last character removed.
 */
value value_chop(value op);
value value_chop_now(value *op);

/* Converts an ASCII character to a number.
 */
value value_asc(value op);

/* Converts a number to an ASCII character.
 */
value value_chr(value op);

/* If op1 contains op2, returns true. Otherwise, returns false.
 */
int value_contains_p(value op1, value op2);
value value_contains_p_std(value op1, value op2);

/* If op1 ends with 2, returns true. Otherwise, returns false.
 */
int value_ends_with_p(value op1, value op2);
value value_ends_with_p_std(value op1, value op2);

/* Returns the index of op2 in op1. If not found, returns nil or -1.
 */
size_t value_index(value op1, value op2);
value value_index_std(value op1, value op2);

/* Inserts op2 into op1 at (index).
 */
value value_insert(value op1, value index, value op3);
value value_insert_now(value *op1, value index, value op3);

/* If op is an alphabetical character (a-zA-Z), returns true. Otherwise, 
 * returns false.
 */
int value_alpha_p(value op);
value value_alpha_p_std(value op);

/* If op is an alphanumeric character (a-zA-Z0-9), returns true. Otherwise, 
 * returns false.
 */
int value_alnum_p(value op);
value value_alnum_p_std(value op);

/* If op is a numeric character (0-9), returns true. Otherwise, returns 
 * false.
 */
int value_num_p(value op);
value value_num_p_std(value op);

/* Returns the length of the sequence.
 */
size_t value_length(value op);
value value_length_std(value op);

/* Strips whitespace from the left side of the string.
 */
value value_lstrip(value op);

/* Returns a sub-array with the first element at (start) and the last element 
 * at (end-1).
 */
value value_range(value op, value start, value end);

/* Returns a copy of (op1) where all instances of (op2) are replaced with (op3).
 */
value value_replace(value op1, value op2, value op3);
value value_replace_now(value *op1, value op2, value op3);

/* Reverses the order of op.
 */
value value_reverse(value op);
value value_reverse_now(value *op);

/* Strips whitespace from the right side of the string.
 */
value value_rstrip(value op);

value value_scan(value op1, value op2);

/* Splits string (op1) at every occurrence of (op2).
 */
value value_split(value op1, value op2);

/* If op1 starts with op2, returns true. Otherwise, returns false.
 */
int value_starts_with_p(value op1, value op2);
value value_starts_with_p_std(value op1, value op2);

/* Strips the whitespace from both sides of the string.
 */
value value_strip(value op);
value value_strip_now(value *op);

/* Converts every lowercase character to uppercase.
 */
value value_to_upper(value op);

/* Converts evey uppercase character to lowercase.
 */
value value_to_lower(value op);

value value_asc_arg(int argc, value argv[]);
value value_capitalize_arg(int argc, value argv[]);
value value_chop_arg(int argc, value argv[]);
value value_chop_now_arg(int argc, value argv[]);
value value_chr_arg(int argc, value argv[]);
value value_contains_p_arg(int argc, value argv[]);
value value_ends_with_p_arg(int argc, value argv[]);
value value_index_arg(int argc, value argv[]);
value value_insert_arg(int argc, value argv[]);
value value_insert_now_arg(int argc, value argv[]);
value value_alpha_p_arg(int argc, value argv[]);
value value_alnum_p_arg(int argc, value argv[]);
value value_num_p_arg(int argc, value argv[]);
value value_length_arg(int argc, value argv[]);
value value_lstrip_arg(int argc, value argv[]);
value value_range_arg(int argc, value argv[]);
value value_replace_arg(int argc, value argv[]);
value value_replace_now_arg(int argc, value argv[]);
value value_reverse_arg(int argc, value argv[]);
value value_reverse_now_arg(int argc, value argv[]);
value value_rstrip_arg(int argc, value argv[]);
value value_scan_arg(int argc, value argv[]);
value value_split_arg(int argc, value argv[]);
value value_starts_with_p_arg(int argc, value argv[]);
value value_strip_arg(int argc, value argv[]);
value value_strip_now_arg(int argc, value argv[]);
value value_to_upper_arg(int argc, value argv[]);
value value_to_lower_arg(int argc, value argv[]);

/* 
 * 
 * Regular expression functions.
 *
 */

/* Compiles the regular expression given in (regex) into (compiled).
 */
int compile_regex(regex_t *compiled, char *regex, int flags);


/* If (regex) matches (str), return true. Otherwise, returns false.
 */
int value_match_p(value regex, value str);
value value_match_p_std(value regex, value str);
value value_match_p_arg(int argc, value argv[]);

/* Returns the index in (str) first matched by (regex).
 */
regmatch_t value_match(value regex, value str);
regmatch_t value_match_str(value regex, char *str);
value value_match_std(value regex, value str);
value value_match_arg(int argc, value argv[]);


/* 
 * 
 * Array functions.
 * 
 */
 
value block_array_cast(value op);

/* Appends (op2) to the back of (op1). */
value value_append(value op1, value op2);
value value_append_now(value *op1, value op2);
value value_append_now2(value *op1, value *op2);

/* 
 * Returns the value in (op) at (index).
 * 
 * more: An array containing zero or more indices. Used for repeated calls. 
 *   value_at_ref(op, 0, { 2, 1 }, 2) is equivalent to op[0][2][1].
 * length: The length of (more).
 * 
 * If you only wish to call at() one time, pass in NULL and 0 for (more) and 
 * (length).
 */
value value_at(value op, value index, value more[], size_t length);
value * value_at_ref(value op, value index, value more[], size_t length);

/* Assigns the value in (op1) at (index) to (op2).
 */
value value_at_assign_do(value *variables, value *op1, value index, value more[], size_t length, value func, value op2);

// I see no need to implement these functions. See value_assign_add_arg(), etc.
value value_at_assign_add(value *op1, value index, value op2);
value value_at_assign_sub(value *op1, value index, value op2);
value value_at_assign_mul(value *op1, value index, value op2);
value value_at_assign_div(value *op1, value index, value op2);
value value_at_assign_mod(value *op1, value index, value op2);
value value_at_assign_and(value *op1, value index, value op2);
value value_at_assign_xor(value *op1, value index, value op2);
value value_at_assign_or(value *op1, value index, value op2);
value value_at_assign_shl(value *op1, value index, value op2);
value value_at_assign_shr(value *op1, value index, value op2);

/* Concatenates op1 and op2.
 */
value value_concat(value op1, value op2);
value value_concat_now(value *op1, value op2);

/* Doesn't modify (op2), but if you later modify (op2), the resulting (op1) 
 * from this function will be modified.
 */
value value_concat_now2(value *op1, value *op2);

/* Returns a new version of (op1) with the first instance of (op2) deleted.
 */
value value_delete(value op1, value op2);

/* Deletes the first instance of (op2) in (op1). If it existed, return true.
 * Otherwise, return false.
 */
value value_delete_now(value *op1, value op2);

value value_delete_all(value op1, value op2);

/* Deletes all instances of (op2) in (op1).
 */
value value_delete_all_now(value *op1, value op2);

value value_delete_at(value op, value index);

/* Deletes the element op[index] and returns it.
 */
value value_delete_at_now(value *op, value index);

/* Iterates over each element in (op) and calls (func) for each one. (func) 
 * must be a type that can be called with value_call().
 */
value value_each(value *variables, value op, value func);

/* Iterates through each index in (op) and calls (func) for each one. (func) 
 * must be a type that can be called with value_call().
 */
value value_each_index(value *variables, value op, value func);

/* If (op) contains no elements, returns true. Otherwise, returns false.
 */
int value_empty_p(value op);
value value_empty_p_std(value op);

/* Returns a new container of the same type as (op). Each element is passed 
 * as an argument to (func), and only elements for which (func) returns true 
 * are put into the new container.
 */
value value_filter(value *variables, value op, value func);
value value_filter_f(value op, int (*f)(value));

/* Returns the first element of (op) for which (func) returns true, or nil 
 * if no such value is found.
 */
value value_find(value *variables, value op, value func);

/* Maps an array of arrays to a single array, or a list of lists to a single 
 * list. Unlike flatten(), this only flattens one layer, so an array of arrays 
 * of arrays would end up as an array of arrays.
 */
value value_flatmap(value *variables, value op, value func);

/* If (op) is a container that contains other containers, flattens all the 
 * containers so that there is only one level of depth.
 */
value value_flatten(value op);
value value_flatten_now(value *op);
size_t value_private_flatten_recursive(value array[], value op, size_t index);
size_t value_private_total_length(value op);

/* Combine all elements of (op) by calculating block(prev, op[i]).
 */
value value_fold(value *variables, value op, value initial, value func);

value value_join(value op1, value op2);

/* Returns the last element of (op).
 */
value value_last(value op);

/* Returns a new array where each element is transformed by the function f().
 */
value value_map(value *variables, value op, value func);

/* Similar to map(), but drops all elements equal to (drop).
 */
value value_map_drop(value *variables, value op, value func, value drop);

/* Returns a new array with the last element removed.
 */
value value_pop(value op);

/* Removes the last element and returns it.
 */
value value_pop_now(value *op);

/* Shuffles (op) randomly.
 */
value value_shuffle(value op);
value value_shuffle_now(value *op);

/* Returns the number of items contained in op. If op is not a container, 
 * returns 1.
 */
size_t value_size(value op);
value value_size_std(value op);

/* 
 * Sorts an array or list.
 */
value value_sort(value op);
value value_sort_now(value *op);
value value_private_sort_pivot;
int value_private_sort_lt(value op);
int value_private_sort_eq(value op);
int value_private_sort_gt(value op);
int value_private_sort_recursive(value array[], int left, int right);
int value_private_sort_list(value *op);

value value_swap_now(value *op, size_t i, size_t j);

/* Removes all duplicate values in (op) while preserving the order.
 */
value value_uniq(value op);
value value_uniq_now(value *op);

/* Removes all duplicate values and sorts the array. This is more efficient than 
 * just removing unique elements.
 */
value value_uniq_sort(value op);
value value_uniq_sort_now(value *op);

value value_append_arg(int argc, value argv[]);
value value_append_now_arg(int argc, value argv[]);
value value_array_with_length_arg(int argc, value argv[]);

/* Takes at least three arguments: op1, index[, more], op2.
 */
value value_at_arg(int argc, value argv[]);
value value_at_assign_arg(int argc, value argv[]);
value value_at_assign_add_arg(int argc, value argv[]);
value value_at_assign_sub_arg(int argc, value argv[]);
value value_at_assign_mul_arg(int argc, value argv[]);
value value_at_assign_div_arg(int argc, value argv[]);
value value_at_assign_mod_arg(int argc, value argv[]);
value value_at_assign_and_arg(int argc, value argv[]);
value value_at_assign_xor_arg(int argc, value argv[]);
value value_at_assign_or_arg(int argc, value argv[]);
value value_at_assign_shl_arg(int argc, value argv[]);
value value_at_assign_shr_arg(int argc, value argv[]);

value value_concat_arg(int argc, value argv[]);
value value_delete_arg(int argc, value argv[]);
value value_delete_all_arg(int argc, value argv[]);
value value_delete_at_arg(int argc, value argv[]);
value value_delete_at_now_arg(int argc, value argv[]);
value value_each_arg(int argc, value argv[]);
value value_each_index_arg(int argc, value argv[]);
value value_empty_p_arg(int argc, value argv[]);
value value_filter_arg(int argc, value argv[]);
value value_find_arg(int argc, value argv[]);
value value_flatmap_arg(int argc, value argv[]);
value value_flatten_arg(int argc, value argv[]);
value value_flatten_now_arg(int argc, value argv[]);
value value_fold_arg(int argc, value argv[]);
value value_join_arg(int argc, value argv[]);
value value_last_arg(int argc, value argv[]);
value value_map_arg(int argc, value argv[]);
value value_map_now_arg(int argc, value argv[]);
value value_map_drop_arg(int argc, value argv[]);
value value_pop_arg(int argc, value argv[]);
value value_pop_now_arg(int argc, value argv[]);
value value_shuffle_arg(int argc, value argv[]);
value value_shuffle_now_arg(int argc, value argv[]);
value value_size_arg(int argc, value argv[]);
value value_sort_arg(int argc, value argv[]);
value value_sort_now_arg(int argc, value argv[]);
value value_uniq_arg(int argc, value argv[]);
value value_uniq_now_arg(int argc, value argv[]);
value value_uniq_sort_arg(int argc, value argv[]);
value value_uniq_sort_now_arg(int argc, value argv[]);

/* 
 * 
 * List functions.
 *
 */

/* Attaches (op1) to the front of (op2).
 */
value value_cons(value op1, value op2);
value value_cons_now(value op1, value *op2);

/* If (op1) is modified later, it will also modify the copy contained 
 * in (op2).
 */
value value_cons_now2(value *op1, value *op2);

/* Returns a list without the first (n) elements of (op). If 
 * (n) is greater than the length of the list, returns nil.
 */
value value_drop(value op, value n);
value value_drop_now(value *op, value n);

/* Returns the first element of the list.
 */
value value_head(value op);

/* Returns a list containing every element but the first one.
 */
value value_tail(value op);
value value_tail_now(value *op);

/* Returns a list containing the first (n) elements of (op). If 
 * (n) is greater than the length of the list, returns the whole 
 * list.
 */
value value_take(value op, value n);
value value_take_now(value *op, value n);

value value_cons_arg(int argc, value argv[]);
value value_cons_now_arg(int argc, value argv[]);
value value_drop_arg(int argc, value argv[]);
value value_head_arg(int argc, value argv[]);
value value_tail_arg(int argc, value argv[]);
value value_take_arg(int argc, value argv[]);

/* 
 * 
 * Hash functions. These are defined separately because internal function rely 
 * so heavily upon hashes.
 * 
 */

#define HASH_DEFAULT_CAPACITY 10 // If this is 0, bad things will happen.

/* Initializes a hash with the default capacity.
 */
value value_hash_init();

/* Initializes a hash with the given capacity.
 */
value value_hash_init_capacity(size_t capacity);

/* Clears (hash).
 */
void value_hash_clear(value *hash);

/* Returns the length of the array in (hash).
 */
size_t value_hash_length(value hash);

/* Returns the number of occupied buckets in (hash).
 */
size_t value_hash_occupied(value hash);

/* Returns the number of elements in (hash).
 */
size_t value_hash_size(value hash);

/* Resizes (hash) to be able to hold more buckets.
 */
value value_hash_resize(value *hash);

/* Puts copies of (key) and (val) into (hash).
 */
value value_hash_put(value *hash, value key, value val);

/* Puts (key) and (val) directly into (hash). If you modify (key) or (val), 
 * its value inside the hash will be changed.
 */
value value_hash_put_refs(value *hash, value *key, value *val);
value value_hash_put_refs_override(value *hash, value *key, value *val);
value value_hash_put_refs_generic(value *hash, value *key, value *val, int clear_p);

/* Converts (key) into a VALUE_STR and calls value_hash_put() on the new key and (val).
 */
value value_hash_put_str(value *hash, const char *key, value val);

/* Converts (key) into a VALUE_VAR and calls value_hash_put() on the new key and (val).
 */
value value_hash_put_var(value *hash, const char *key, value val);

/* Converts (key) and (value) into VALUE_STRs and puts them into (hash).
 */
value value_hash_put_str_str(value *hash, const char *key, const char *val);

/* If (key) exists inside of (hash), returns TRUE. Otherwise, returns FALSE.
 */
int value_hash_exists(value hash, value key);

/* Converts (key) into a VALUE_STR and determines if it exists inside of (hash).
 */
int value_hash_exists_str(value hash, char *key);

/* If (op) contains (val) as a value, returns TRUE. Otherwise, returns FALSE.
 */
int value_contains_value(value op, value val);
value value_contains_value_std(value op, value val);
value value_contains_value_arg(int argc, value argv[]);

/* 
 * Deletes (key) in (hash) and returns the deleted value.
 */
value value_hash_delete_at(value *hash, value key);

/* 
 * Deletes (key) in (hash).
 */
void value_hash_delete_at_void(value *hash, value key);

/* Returns a reference to the corresponding value for key (key) in (hash). If 
 * none is found, returns NULL.
 */
value * value_hash_get_ref(value hash, value key);
value value_hash_get(value hash, value key);
value * value_hash_get_ref_str(value hash, char *key);
value value_hash_get_str(value hash, char *key);
value * value_hash_get_pair_ref(value hash, value key);

/* Returns the key-value pair for key (key) in (hash).
 */
value value_hash_get_pair(value hash, value key);

int value_private_put_pair_in_bucket(value *bucket, value *key, value *val, int clear_p);
value value_private_find_pair_in_bucket(value bucket, value key);
size_t value_private_hash_function(value op);

int value_hash_print(value hash);
int value_hash_println(value hash);


/* 
 * Range functions.
 */

/* Constructs a range on [op1, op2].
 */
value value_range_to(value op1, value op2);

/* Constructs a range on [op1, op2).
 */
value value_range_until(value op1, value op2);

value value_range_to_arg(int argc, value argv[]);
value value_range_until_arg(int argc, value argv[]);


/* 
 * Block and function functions.
 */

void value_add_to_line_queue(value op); // This function is defined in interpreter.c.

/* Call (func) and pass (argv) as the arguments. Must be a callable data 
 * type: BIF, UDF, or BLK.
 */
value value_call(value *variables, value func, int argc, value argv[]);

/* Takes a sexp with a BIF as the first element and calls value_bifcall().
 */
value value_bifcall_sexp(value *variables, value *ud_functions, value sexp);

/* Call a built-in function (op) with arguments (argv).
 */
value value_bifcall(value op, int argc, value argv[]);

/* Call a user-defined function.
 * variables: Pointer to a hash containing whatever the variable scope is at the 
 *   time of the function call.
 * op: User-defined function to be called.
 * argv: Argument list.
 */
value value_udfcall(value *variables, value op, int argc, value argv[]);

/* Defines a user-defined function.
 */
value value_def(value *variables, value name, value vars, value body);

/* Defines a macro.
 */
value value_defmacro(value *variables, value name, value vars, value body);

/* Do not evaluate (op), except for anything inside a call to (dq) or (dv). 
 * (dq x): Evaluates x.
 * (dv x): If x is a variable, returns the contents of x. Otherwise, returns x.
 */
value value_quote(value *variables, value op);

value value_def_arg(int argc, value argv[]);

/* Do not evaluate (op), including anything inside a call to (dq) or (dv).
 */
value value_quote_all_arg(int argc, value argv[]);

value value_quote_arg(int argc, value argv[]);
value value_dequote_arg(int argc, value argv[]);
value value_devar_arg(int argc, value argv[]);
value value_eval_arg(int argc, value argv[]);

/* 
 * Control functions. These take s-expressions as arguments, which are then evaluated.
 */

value value_break_arg(int argc, value argv[]);
value value_continue_arg(int argc, value argv[]);
value value_yield_arg(int argc, value argv[]);
value value_return_arg(int argc, value argv[]);
value value_exit_arg(int argc, value argv[]);

/* If (condition) is true, evaluates and returns (body). Otherwise, evaluates and returns 
 * (else_body). That is, unless (reverse) is true, in which case (body) and (else_body) 
 * are reversed -- this is like an (unless) call.
 */
value value_if(value *variables, value condition, value body, value else_body, int reverse);

/* Calls (body) as long as (condition) is true. That is, unless (reverse) is true, in 
 * which case it calls (body) as long as (condition) is false.
 */
value value_while(value *variables, value condition, value body, int reverse);

/* Calls a (body) with one or more conditions, which acts like the switch statement in C 
 * or Java. However, it is more flexible. If (val) and (body) are both given, then it acts 
 * almost exactly like a switch statement in C or Java. If (val) contains a block and (body) 
 * is nil, then (val) is put into body and each condition acts as a single part of an if-else 
 * chain.
 * 
 * In the body, the :if symbol followed by two values serves as a single condition. If (val) 
 * is given then the first value is compared to (val). If they are equal, the second value is 
 * evaluated and returned. If (val) is not given, then it is treated as an if expression. 
 * The first value is evaluated, and if it returns a true value then the second value is 
 * evaluated and returned.
 * 
 * The other possible symbol is the :else symbol, which is followed by a single value. The 
 * value will always be evaluated and returned.
 * 
 * If the execution of an :if symbol and its two values returns false, execution moves on to 
 * the next :if symbol. If an :else symbol is found, its value is evaluated and returned, and 
 * execution ends. If every :if symbol returns false and there is no :else symbol, nil is 
 * returned.
 * 
 * examples: 
 * 
 * switch (x) (:if 0 "zero" :if 1 "one" :if 2 "two" :else "I don't know")
 *   If x == 0, returns "zero". If x == 1, returns "one". If x == 2, returns "two". Otherwise, 
 *   returns "I don't know".
 * 
 * switch (x) (:if "zero" 0)
 *   If x == "zero", returns 0. Otherwise, returns nil.
 * 
 * switch (:if (x type != Integer) "not an integer" :if (x % 2 == 0) "even" :else "odd")
 *   Acts as a series of if expressions. Equivalent to
 *     if (x type != Integer) "not an integer" (if (x % 2 == 0) "even" "odd")
 * 
 */
value value_switch(value *variables, value val, value body);

/* A sophisticated loop that at its most simple works like a (while) loop, but can do much 
 * more.
 */
value value_for(value *variables, value condition, value body);

/* Evaluates every value in (todo), and returns the last value evaluated.
 */
value value_do(value *variables, value todo[], size_t length);

value value_comma(value op1, value op2);

value value_if_arg(int argc, value argv[]);
value value_unless_arg(int argc, value argv[]);
value value_while_arg(int argc, value argv[]);
value value_until_arg(int argc, value argv[]);
value value_switch_arg(int argc, value argv[]);
value value_for_arg(int argc, value argv[]);
value value_do_both_arg(int argc, value argv[]);
value value_do_all_arg(int argc, value argv[]);
value value_comma_arg(int argc, value argv[]);





/* 
 * Exception functions.
 */
exception exception_init(exception *parent, char *name);
value value_throw(exception op, char *description);


/*
 * 
 * General-purpose output functions.
 * 
 */

double value_get_double(value op);
value value_get_from_index(value op, size_t index);
long value_get_long(value op);

char * value_get_string(value op);

/* 
 * Prints op as a string into the given buffer. This is the core function 
 * used by value_to_string(), value_print(), and most other output functions.
 * 
 * format: A format string that tells how to output (op). See value_printf() 
 *         for a detailed description of the possible formats. In this case, 
 *         no preceding '%' should be included in the format string.
 * 
 * 
 * Return Values
 * 
 * 0: op was successfully written to the buffer.
 * VALUE_ERROR: buffer was not large enough to hold op. The contents of buffer 
 * are undefined.
 * 
 */
int value_put(char buffer[], size_t length, value op, char *format);

/* Converts a value to a string. This is unsafe, as it does not allocate any 
 * memory so the contents of the returned string may change or be erased.
 */
char * value_to_string(value op);
char * value_to_string_base(value op, value base);

/* Allocates memory for the string, and is therefore safer than to_string().
 */
char * value_to_string_safe(value op);
unsigned long value_get_ulong(value op);

/* Print out a single value using the %v format specifier. See value_printf().
 */
int value_print(value op);
int value_println(value op);

/* 
 * Writes a formatted string to the standard output. A format tag looks like 
 * this: 
 * 
 * %[width][.precision]type
 * 
 * (width) indicates the maximum number of characters to be output. It is 
 * not guaranteed that exactly (width) characters will be output, even if 
 * the string would be longer than (width); but it is guaranteed that no 
 * more than (width) characters will be output. If the output string would 
 * have been longer than (width), an ellipsis "(...)" is used to indicate 
 * which part of the string was not printed. It is not guaranteed that the 
 * printed string will ever be shorter than 5 characters.
 * 
 * (precision) indicates the precision of a floating-point number. If the 
 * value is not a float, this is ignored. If it is a container, every float 
 * that is printed out is given this precision.
 * 
 * Although the format tag looks a lot like in C, it works differently --  
 * which you would expect from a dynamically-typed interface. The following  
 * types are available.
 * 
 * e: Prints floats in exponential notation. For non-floats, acts as 'v'.
 * s: The simplest format. Prints out the parameter the way it would look if  
 *    you used to_s().
 * v: Prints the value of the parameter. Works like 's', but it is printed 
 *    out more as a direct value. For example, the string "hello" is printed 
 *    as hello instead of as "hello" (with quotes). This is recommended for 
 *    most purposes. It is what print() and println() use.
 * b, o, x: Prints numbers as binary, octal, hex rather than decimal. 
 *    For non-numbers, acts as 'v'.
 * 
 * There are also two possible modifiers, which precede the type.
 * t: Prints the type of the value in addition to the value itself. By default, 
 *    restricts the output to 72 characters.
 * r: Recursive type printing. Acts like t, but also prints the types of any 
 *    values inside of the first value. For example, it will print the type of 
 *    each element in an array.

 */
int value_printf(const char *format, ...);
int value_fprintf(FILE *fp, const char *format, ...);
int value_vfprintf(FILE *fp, const char *format, va_list ap);
int value_sprintf(char *str, const char *format, ...);

/* 
 * This is the output function that does all the work. Every other output function 
 * eventually calls this one. It's a little bit complex, but it saves effort in 
 * the long run.
 * 
 * fp: File stream to print to. If NULL, output goes to (str) instead.
 * str: String to print to. Only used if (fp) is NULL.
 * format: Format string that determines what to print.
 * argc: Number of arguments in argv.
 * argv: Arguments that are printed by (format) tags. If NULL, (ap) is used instead.
 * ap: Variable argument list for arguments that are printed by (format) tags. Only 
 *     used if (argv) is NULL.
 * 
 * This function may be called with either an array as an argument list or a va_list.
 */
int value_vprintf_generic(FILE *fp, char *str, const char *format, int argc, value *argv, va_list ap);

/* 
 * Prints out an error message.
 * 
 * severity: How many errors to add to the error count. This is most commonly 0 or 1. 
 * If 0, then the error is considered only a warning.
 * 
 * value_error's format supports everything that value_printf supports. In addition, %d is 
 * a C int and %c is a C string (NOT a char -- %s was already taken by value_printf, and if 
 * you want to print out a character in an error message for some reason then you'll just 
 * have to figure out some other way to do it).
 */ 
int value_error(int severity, char *format, ...);

value value_print_arg(int argc, value argv[]);
value value_println_arg(int argc, value argv[]);
value value_printf_arg(int argc, value argv[]);

/* Prints every value in (values), separated by spaces.
 */
int print_values(value values[], size_t length);

